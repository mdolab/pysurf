!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!
!     ******************************************************************
!     *                                                                *
!     * file:          hypsurfmain.f90                                 *
!     * authors:       john jasa and ney secco                         *
!     * starting date: 08-11-2016                                      *
!     * last modified: 09-25-2016                                      *
!     *                                                                *
!     ******************************************************************
!
!
!     ******************************************************************
!     *                                                                *
!     * contains subroutines for hyperbolic surface mesh generation.   *
!     *                                                                *
!     ******************************************************************
!
module hypsurfmain_b
  use precision
  implicit none

contains
!  differentiation of computematrices_main in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: f
!   with respect to varying inputs: f s0 sm1 n0 rm1 r0
!   rw status of diff variables: f:in-zero s0:out sm1:out n0:out
!                rm1:out r0:out
!=================================================================
!=================================================================
  subroutine computematrices_main_b(r0, r0b, n0, n0b, s0, s0b, rm1, rm1b&
&   , sm1, sm1b, layerindex, theta, sigmasplay, bc1, bc2, numlayers, &
&   epse0, guideindices, retainspacing, f, fb, numnodes, numguides)
    use solveroutines, only : solve_b
    implicit none
    integer(kind=inttype), intent(in) :: layerindex, numnodes, numlayers
    real(kind=realtype), intent(in) :: r0(3*numnodes), n0(3, numnodes), &
&   s0(numnodes)
    real(kind=realtype) :: r0b(3*numnodes), n0b(3, numnodes), s0b(&
&   numnodes)
    real(kind=realtype), intent(in) :: rm1(3*numnodes), sm1(numnodes), &
&   theta
    real(kind=realtype) :: rm1b(3*numnodes), sm1b(numnodes)
    real(kind=realtype), intent(in) :: sigmasplay, epse0
    character(len=32), intent(in) :: bc1, bc2
    real(kind=realtype) :: f(3*numnodes)
    real(kind=realtype) :: fb(3*numnodes)
    integer(kind=inttype), intent(in) :: numguides
    integer(kind=inttype), intent(in) :: guideindices(numguides)
    logical, intent(in) :: retainspacing
    real(kind=realtype) :: r_curr(3), r_next(3), r_prev(3), d_vec(3), &
&   d_vec_rot(3), eye(3, 3)
    real(kind=realtype) :: r_currb(3), r_nextb(3), r_prevb(3), d_vecb(3)&
&   , d_vec_rotb(3)
    real(kind=realtype) :: k(3*numnodes, 3*numnodes)
    real(kind=realtype) :: kb(3*numnodes, 3*numnodes)
    integer(kind=inttype) :: index, i
    integer(kind=inttype) :: ipiv(3*numnodes)
    integer(kind=inttype) :: n, nrhs, ldk, ldf, info
    real(kind=realtype) :: one, zero, rhs(3*numnodes)
    real(kind=realtype) :: rhsb(3*numnodes)
    logical :: guide
    integer :: branch
    one = 1.
    zero = 0.
! initialize arrays
    k(:, :) = zero
    call pushreal8array(f, realtype*3*numnodes/8)
    f(:) = zero
    eye(:, :) = zero
    do i=1,3
      eye(i, i) = one
    end do
! now loop over each node
    index = 1
    if (bc1 .eq. 'splay') then
! get coordinates
      r_curr = r0(:3)
      r_next = r0(4:6)
! get vector that connects r_next to r_curr
      d_vec = r_next - r_curr
! get marching direction vector (orthogonal to the curve and to the surface normal)
      call cross(n0(:, 1), d_vec, d_vec_rot)
! populate matrix
      k(1, :3) = d_vec_rot
      k(2, :3) = n0(:, index)
      k(3, :3) = d_vec
      f(:3) = zero
      f(1) = s0(1)*(1-sigmasplay)
      call pushcontrol3b(5)
    else if (bc1 .eq. 'constx') then
      call pushcontrol3b(4)
! populate matrix
      k(2, 4) = zero
      k(2, 5) = -one
      k(2, 6) = zero
      k(3, 4) = zero
      k(3, 5) = zero
      k(3, 6) = -one
      do i=1,3
        k(i, i) = one
      end do
    else if (bc1 .eq. 'consty') then
      call pushcontrol3b(3)
! populate matrix
      k(1, 4) = -one
      k(1, 5) = zero
      k(1, 6) = zero
      k(3, 4) = zero
      k(3, 5) = zero
      k(3, 6) = -one
      do i=1,3
        k(i, i) = one
      end do
    else if (bc1 .eq. 'constz') then
      call pushcontrol3b(2)
! populate matrix
      k(1, 4) = -one
      k(1, 5) = zero
      k(1, 6) = zero
      k(2, 4) = zero
      k(2, 5) = -one
      k(2, 6) = zero
      do i=1,3
        k(i, i) = one
      end do
    else if (bc1(:5) .eq. 'curve') then
! populate matrix
      do i=1,3
        k(i, i) = one
      end do
      f(:3) = s0(1)*n0(:, 1)
      call pushcontrol3b(1)
    else
! call assembly routine
      call matrixbuilder(index, bc1, bc2, r0, rm1, n0, s0, sm1, &
&                  numlayers, epse0, layerindex, theta, numnodes, k, f)
      call pushcontrol3b(0)
    end if
    call pushinteger4array(index, inttype/4)
    do index=2,numnodes-1
      if (retainspacing) then
        guide = .false.
        do i=1,numguides
          if (index .eq. guideindices(i)) guide = .true.
        end do
      else
        guide = .false.
      end if
      if (guide) then
        k(3*(index-1)+1, 3*(index-1)+1) = one
        k(3*(index-1)+2, 3*(index-1)+2) = one
        k(3*(index-1)+3, 3*(index-1)+3) = one
        f(3*(index-1)+1:3*(index-1)+3) = s0(index)*n0(:, index)
        call pushcontrol1b(1)
      else
! call assembly routine
        call matrixbuilder(index, bc1, bc2, r0, rm1, n0, s0, sm1, &
&                    numlayers, epse0, layerindex, theta, numnodes, k, f&
&                   )
        call pushcontrol1b(0)
      end if
    end do
    index = numnodes
    if (bc2 .eq. 'continuous') then
! populate matrix (use same displacements of first node)
      k(3*(index-1)+1:, 3*(index-1)+1:) = eye
      k(3*(index-1)+1:, :3) = -eye
      call pushcontrol3b(0)
    else if (bc2 .eq. 'splay') then
! get coordinates
      r_curr = r0(3*(index-1)+1:)
      r_prev = r0(3*(index-2)+1:3*(index-2)+3)
! get vector that connects r_next to r_curr
      d_vec = r_curr - r_prev
! get marching direction vector (orthogonal to the curve and to the surface normal)
      call cross(n0(:, index), d_vec, d_vec_rot)
! populate matrix
      k(3*index-2, 3*index-2:) = d_vec_rot
      k(3*index-1, 3*index-2:) = n0(:, index)
      k(3*index-0, 3*index-2:) = d_vec
      f(3*(index-1)+1:3*index) = zero
      f(3*(index-1)+1) = s0(index)*(1-sigmasplay)
      call pushcontrol3b(1)
    else if (bc2 .eq. 'constx') then
! populate matrix
      k(3*index-0, 3*(index-2)+1) = zero
      k(3*index-0, 3*(index-2)+2) = zero
      k(3*index-0, 3*(index-2)+3) = -one
      k(3*index-1, 3*(index-2)+1) = zero
      k(3*index-1, 3*(index-2)+2) = -one
      k(3*index-1, 3*(index-2)+3) = zero
      do i=3*index-2,3*index
        k(i, i) = one
      end do
      call pushcontrol3b(2)
    else if (bc2 .eq. 'consty') then
! populate matrix
      k(3*index-2, 3*(index-2)+1) = -one
      k(3*index-2, 3*(index-2)+2) = zero
      k(3*index-2, 3*(index-2)+3) = zero
      k(3*index-0, 3*(index-2)+1) = zero
      k(3*index-0, 3*(index-2)+2) = zero
      k(3*index-0, 3*(index-2)+3) = -one
      do i=3*index-2,3*index
        k(i, i) = one
      end do
      call pushcontrol3b(3)
    else if (bc2 .eq. 'constz') then
! populate matrix
      k(3*index-2, 3*(index-2)+1) = -one
      k(3*index-2, 3*(index-2)+2) = zero
      k(3*index-2, 3*(index-2)+3) = zero
      k(3*index-1, 3*(index-2)+1) = zero
      k(3*index-1, 3*(index-2)+2) = -one
      k(3*index-1, 3*(index-2)+3) = zero
      do i=3*index-2,3*index
        k(i, i) = one
      end do
      call pushcontrol3b(4)
    else if (bc2(:5) .eq. 'curve') then
! populate matrix
      do i=3*index-2,3*index
        k(i, i) = one
      end do
      f(3*index-2:) = s0(index)*n0(:, index)
      call pushcontrol3b(5)
    else
! call assembly routine
      call matrixbuilder(index, bc1, bc2, r0, rm1, n0, s0, sm1, &
&                  numlayers, epse0, layerindex, theta, index, k, f)
      call pushcontrol3b(6)
    end if
! set other parameters
! problem size
    n = 3*numnodes
! number of right hand sides in f
! leading dimension of k (should be = n unless we work with submatrices)
! leading dimension of f (should be = n unless we work with submatrices)
! call dgesv(n, nrhs, k, ldk, ipiv, f, ldf, info)
    rhs = f
! note that this f is rnext when outputted from computematrices_main
    r0b = r0b + fb
    kb = 0.0_8
    rhsb = 0.0_8
    call solve_b(k, kb, f, fb, rhs, rhsb, n, ipiv)
    fb = fb + rhsb
    call popcontrol3b(branch)
    if (branch .lt. 3) then
      if (branch .eq. 0) then
        kb(3*(index-1)+1:3*numnodes, 1:3) = 0.0_8
        kb(3*(index-1)+1:3*numnodes, 3*(index-1)+1:3*numnodes) = 0.0_8
        sm1b = 0.0_8
        n0b = 0.0_8
        rm1b = 0.0_8
        d_vec_rotb = 0.0_8
        goto 100
      else if (branch .eq. 1) then
        s0b(index) = s0b(index) + (1-sigmasplay)*fb(3*(index-1)+1)
        fb(3*(index-1)+1) = 0.0_8
        fb(3*(index-1)+1:3*index) = 0.0_8
        d_vecb = 0.0_8
        d_vecb = kb(3*index-0, 3*index-2:)
        kb(3*index-0, 3*index-2:3*numnodes) = 0.0_8
        n0b = 0.0_8
        n0b(:, index) = n0b(:, index) + kb(3*index-1, 3*index-2:3*&
&         numnodes)
        kb(3*index-1, 3*index-2:3*numnodes) = 0.0_8
        d_vec_rotb = 0.0_8
        d_vec_rotb = kb(3*index-2, 3*index-2:)
        kb(3*index-2, 3*index-2:3*numnodes) = 0.0_8
        call cross_b(n0(:, index), n0b(:, index), d_vec, d_vecb, &
&              d_vec_rot, d_vec_rotb)
        r_currb = 0.0_8
        r_prevb = 0.0_8
        r_currb = d_vecb
        r_prevb = -d_vecb
        r0b(3*(index-2)+1:3*(index-2)+3) = r0b(3*(index-2)+1:3*(index-2)&
&         +3) + r_prevb
        r0b(3*(index-1)+1:3*numnodes) = r0b(3*(index-1)+1:3*numnodes) + &
&         r_currb
        sm1b = 0.0_8
        rm1b = 0.0_8
        goto 100
      else
        do i=3*index,3*index-2,-1
          kb(i, i) = 0.0_8
        end do
        kb(3*index-1, 3*(index-2)+3) = 0.0_8
        kb(3*index-1, 3*(index-2)+2) = 0.0_8
        kb(3*index-1, 3*(index-2)+1) = 0.0_8
        kb(3*index-0, 3*(index-2)+3) = 0.0_8
        kb(3*index-0, 3*(index-2)+2) = 0.0_8
        kb(3*index-0, 3*(index-2)+1) = 0.0_8
        sm1b = 0.0_8
        n0b = 0.0_8
        rm1b = 0.0_8
      end if
    else if (branch .lt. 5) then
      if (branch .eq. 3) then
        do i=3*index,3*index-2,-1
          kb(i, i) = 0.0_8
        end do
        kb(3*index-0, 3*(index-2)+3) = 0.0_8
        kb(3*index-0, 3*(index-2)+2) = 0.0_8
        kb(3*index-0, 3*(index-2)+1) = 0.0_8
        kb(3*index-2, 3*(index-2)+3) = 0.0_8
        kb(3*index-2, 3*(index-2)+2) = 0.0_8
        kb(3*index-2, 3*(index-2)+1) = 0.0_8
        sm1b = 0.0_8
        n0b = 0.0_8
        rm1b = 0.0_8
      else
        do i=3*index,3*index-2,-1
          kb(i, i) = 0.0_8
        end do
        kb(3*index-1, 3*(index-2)+3) = 0.0_8
        kb(3*index-1, 3*(index-2)+2) = 0.0_8
        kb(3*index-1, 3*(index-2)+1) = 0.0_8
        kb(3*index-2, 3*(index-2)+3) = 0.0_8
        kb(3*index-2, 3*(index-2)+2) = 0.0_8
        kb(3*index-2, 3*(index-2)+1) = 0.0_8
        sm1b = 0.0_8
        n0b = 0.0_8
        rm1b = 0.0_8
      end if
    else if (branch .eq. 5) then
      n0b = 0.0_8
      s0b(index) = s0b(index) + sum(n0(:, index)*fb(3*index-2:))
      n0b(:, index) = n0b(:, index) + s0(index)*fb(3*index-2:3*numnodes)
      fb(3*index-2:3*numnodes) = 0.0_8
      do i=3*index,3*index-2,-1
        kb(i, i) = 0.0_8
      end do
      sm1b = 0.0_8
      rm1b = 0.0_8
    else
      rm1b = 0.0_8
      n0b = 0.0_8
      sm1b = 0.0_8
      call matrixbuilder_b(index, bc1, bc2, r0, r0b, rm1, rm1b, n0, n0b&
&                    , s0, s0b, sm1, sm1b, numlayers, epse0, layerindex&
&                    , theta, index, k, kb, f, fb)
    end if
    d_vec_rotb = 0.0_8
 100 do index=numnodes-1,2,-1
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        call matrixbuilder_b(index, bc1, bc2, r0, r0b, rm1, rm1b, n0, &
&                      n0b, s0, s0b, sm1, sm1b, numlayers, epse0, &
&                      layerindex, theta, numnodes, k, kb, f, fb)
      else
        s0b(index) = s0b(index) + sum(n0(:, index)*fb(3*(index-1)+1:3*(&
&         index-1)+3))
        n0b(:, index) = n0b(:, index) + s0(index)*fb(3*(index-1)+1:3*(&
&         index-1)+3)
        fb(3*(index-1)+1:3*(index-1)+3) = 0.0_8
        kb(3*(index-1)+3, 3*(index-1)+3) = 0.0_8
        kb(3*(index-1)+2, 3*(index-1)+2) = 0.0_8
        kb(3*(index-1)+1, 3*(index-1)+1) = 0.0_8
      end if
    end do
    call popinteger4array(index, inttype/4)
    call popcontrol3b(branch)
    if (branch .lt. 3) then
      if (branch .eq. 0) then
        index = 1
        call matrixbuilder_b(index, bc1, bc2, r0, r0b, rm1, rm1b, n0, &
&                      n0b, s0, s0b, sm1, sm1b, numlayers, epse0, &
&                      layerindex, theta, numnodes, k, kb, f, fb)
      else if (branch .eq. 1) then
        s0b(1) = s0b(1) + sum(n0(:, 1)*fb(:3))
        n0b(:, 1) = n0b(:, 1) + s0(1)*fb(1:3)
      end if
    else if (branch .ne. 3) then
      if (branch .ne. 4) then
        s0b(1) = s0b(1) + (1-sigmasplay)*fb(1)
        r_curr = r0(:3)
        d_vec = r_next - r_curr
        d_vecb = 0.0_8
        d_vecb = kb(3, :3)
        kb(3, 1:3) = 0.0_8
        index = 1
        n0b(:, index) = n0b(:, index) + kb(2, 1:3)
        kb(2, 1:3) = 0.0_8
        d_vec_rotb = d_vec_rotb + kb(1, 1:3)
        call cross_b(n0(:, 1), n0b(:, 1), d_vec, d_vecb, d_vec_rot, &
&              d_vec_rotb)
        r_currb = 0.0_8
        r_nextb = 0.0_8
        r_nextb = d_vecb
        r_currb = -d_vecb
        r0b(4:6) = r0b(4:6) + r_nextb
        r0b(1:3) = r0b(1:3) + r_currb
      end if
    end if
    call popreal8array(f, realtype*3*numnodes/8)
    fb = 0.0_8
  end subroutine computematrices_main_b
!=================================================================
!=================================================================
  subroutine computematrices_main(r0, n0, s0, rm1, sm1, layerindex, &
&   theta, sigmasplay, bc1, bc2, numlayers, epse0, guideindices, &
&   retainspacing, f, numnodes, numguides)
    use solveroutines, only : solve
    implicit none
    integer(kind=inttype), intent(in) :: layerindex, numnodes, numlayers
    real(kind=realtype), intent(in) :: r0(3*numnodes), n0(3, numnodes), &
&   s0(numnodes)
    real(kind=realtype), intent(in) :: rm1(3*numnodes), sm1(numnodes), &
&   theta
    real(kind=realtype), intent(in) :: sigmasplay, epse0
    character(len=32), intent(in) :: bc1, bc2
    real(kind=realtype), intent(out) :: f(3*numnodes)
    integer(kind=inttype), intent(in) :: numguides
    integer(kind=inttype), intent(in) :: guideindices(numguides)
    logical, intent(in) :: retainspacing
    real(kind=realtype) :: r_curr(3), r_next(3), r_prev(3), d_vec(3), &
&   d_vec_rot(3), eye(3, 3)
    real(kind=realtype) :: k(3*numnodes, 3*numnodes)
    integer(kind=inttype) :: index, i
    integer(kind=inttype) :: ipiv(3*numnodes)
    integer(kind=inttype) :: n, nrhs, ldk, ldf, info
    real(kind=realtype) :: one, zero, rhs(3*numnodes)
    logical :: guide
    one = 1.
    zero = 0.
! initialize arrays
    k(:, :) = zero
    f(:) = zero
    eye(:, :) = zero
    do i=1,3
      eye(i, i) = one
    end do
! now loop over each node
    index = 1
    if (bc1 .eq. 'splay') then
! get coordinates
      r_curr = r0(:3)
      r_next = r0(4:6)
! get vector that connects r_next to r_curr
      d_vec = r_next - r_curr
! get marching direction vector (orthogonal to the curve and to the surface normal)
      call cross(n0(:, 1), d_vec, d_vec_rot)
! populate matrix
      k(1, :3) = d_vec_rot
      k(2, :3) = n0(:, index)
      k(3, :3) = d_vec
      f(:3) = zero
      f(1) = s0(1)*(1-sigmasplay)
    else if (bc1 .eq. 'constx') then
! populate matrix
      k(2, 4) = zero
      k(2, 5) = -one
      k(2, 6) = zero
      k(3, 4) = zero
      k(3, 5) = zero
      k(3, 6) = -one
      do i=1,3
        k(i, i) = one
      end do
    else if (bc1 .eq. 'consty') then
! populate matrix
      k(1, 4) = -one
      k(1, 5) = zero
      k(1, 6) = zero
      k(3, 4) = zero
      k(3, 5) = zero
      k(3, 6) = -one
      do i=1,3
        k(i, i) = one
      end do
    else if (bc1 .eq. 'constz') then
! populate matrix
      k(1, 4) = -one
      k(1, 5) = zero
      k(1, 6) = zero
      k(2, 4) = zero
      k(2, 5) = -one
      k(2, 6) = zero
      do i=1,3
        k(i, i) = one
      end do
    else if (bc1(:5) .eq. 'curve') then
! populate matrix
      do i=1,3
        k(i, i) = one
      end do
      f(:3) = s0(1)*n0(:, 1)
    else
! call assembly routine
      call matrixbuilder(index, bc1, bc2, r0, rm1, n0, s0, sm1, &
&                  numlayers, epse0, layerindex, theta, numnodes, k, f)
    end if
    do index=2,numnodes-1
      if (retainspacing) then
        guide = .false.
        do i=1,numguides
          if (index .eq. guideindices(i)) guide = .true.
        end do
      else
        guide = .false.
      end if
      if (guide) then
        k(3*(index-1)+1, 3*(index-1)+1) = one
        k(3*(index-1)+2, 3*(index-1)+2) = one
        k(3*(index-1)+3, 3*(index-1)+3) = one
        f(3*(index-1)+1:3*(index-1)+3) = s0(index)*n0(:, index)
      else
! call assembly routine
        call matrixbuilder(index, bc1, bc2, r0, rm1, n0, s0, sm1, &
&                    numlayers, epse0, layerindex, theta, numnodes, k, f&
&                   )
      end if
    end do
    index = numnodes
    if (bc2 .eq. 'continuous') then
! populate matrix (use same displacements of first node)
      k(3*(index-1)+1:, 3*(index-1)+1:) = eye
      k(3*(index-1)+1:, :3) = -eye
    else if (bc2 .eq. 'splay') then
! get coordinates
      r_curr = r0(3*(index-1)+1:)
      r_prev = r0(3*(index-2)+1:3*(index-2)+3)
! get vector that connects r_next to r_curr
      d_vec = r_curr - r_prev
! get marching direction vector (orthogonal to the curve and to the surface normal)
      call cross(n0(:, index), d_vec, d_vec_rot)
! populate matrix
      k(3*index-2, 3*index-2:) = d_vec_rot
      k(3*index-1, 3*index-2:) = n0(:, index)
      k(3*index-0, 3*index-2:) = d_vec
      f(3*(index-1)+1:3*index) = zero
      f(3*(index-1)+1) = s0(index)*(1-sigmasplay)
    else if (bc2 .eq. 'constx') then
! populate matrix
      k(3*index-0, 3*(index-2)+1) = zero
      k(3*index-0, 3*(index-2)+2) = zero
      k(3*index-0, 3*(index-2)+3) = -one
      k(3*index-1, 3*(index-2)+1) = zero
      k(3*index-1, 3*(index-2)+2) = -one
      k(3*index-1, 3*(index-2)+3) = zero
      do i=3*index-2,3*index
        k(i, i) = one
      end do
    else if (bc2 .eq. 'consty') then
! populate matrix
      k(3*index-2, 3*(index-2)+1) = -one
      k(3*index-2, 3*(index-2)+2) = zero
      k(3*index-2, 3*(index-2)+3) = zero
      k(3*index-0, 3*(index-2)+1) = zero
      k(3*index-0, 3*(index-2)+2) = zero
      k(3*index-0, 3*(index-2)+3) = -one
      do i=3*index-2,3*index
        k(i, i) = one
      end do
    else if (bc2 .eq. 'constz') then
! populate matrix
      k(3*index-2, 3*(index-2)+1) = -one
      k(3*index-2, 3*(index-2)+2) = zero
      k(3*index-2, 3*(index-2)+3) = zero
      k(3*index-1, 3*(index-2)+1) = zero
      k(3*index-1, 3*(index-2)+2) = -one
      k(3*index-1, 3*(index-2)+3) = zero
      do i=3*index-2,3*index
        k(i, i) = one
      end do
    else if (bc2(:5) .eq. 'curve') then
! populate matrix
      do i=3*index-2,3*index
        k(i, i) = one
      end do
      f(3*index-2:) = s0(index)*n0(:, index)
    else
! call assembly routine
      call matrixbuilder(index, bc1, bc2, r0, rm1, n0, s0, sm1, &
&                  numlayers, epse0, layerindex, theta, index, k, f)
    end if
! set other parameters
! problem size
    n = 3*numnodes
! number of right hand sides in f
    nrhs = 1
! leading dimension of k (should be = n unless we work with submatrices)
    ldk = n
! leading dimension of f (should be = n unless we work with submatrices)
    ldf = n
! call dgesv(n, nrhs, k, ldk, ipiv, f, ldf, info)
    rhs = f
    call solve(k, f, rhs, n, ipiv)
! note that this f is rnext when outputted from computematrices_main
    f = r0 + f
  end subroutine computematrices_main
!  differentiation of matrixbuilder in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: f k s0 sm1 n0 rm1 r0
!   with respect to varying inputs: f k s0 sm1 n0 rm1 r0
  subroutine matrixbuilder_b(curr_index, bc1, bc2, r0, r0b, rm1, rm1b, &
&   n0, n0b, s0, s0b, sm1, sm1b, numlayers, epse0, layerindex, theta, &
&   numnodes, k, kb, f, fb)
    implicit none
    integer(kind=inttype), intent(in) :: curr_index, numnodes, numlayers&
&   , layerindex
    real(kind=realtype), intent(in) :: r0(3*numnodes), rm1(3*numnodes), &
&   n0(3, numnodes)
    real(kind=realtype) :: r0b(3*numnodes), rm1b(3*numnodes), n0b(3, &
&   numnodes)
    real(kind=realtype), intent(in) :: sm1(numnodes), epse0, s0(numnodes&
&   ), theta
    real(kind=realtype) :: sm1b(numnodes), s0b(numnodes)
    character(len=32), intent(in) :: bc1, bc2
    real(kind=realtype), intent(inout) :: k(3*numnodes, 3*numnodes), f(3&
&   *numnodes)
    real(kind=realtype) :: kb(3*numnodes, 3*numnodes), fb(3*numnodes)
    real(kind=realtype) :: r_curr(3), r_next(3), d_vec(3), d_vec_rot(3)
    real(kind=realtype) :: r0_xi(3), pi, angle, b0(3, 3), b0inv(3, 3)
    real(kind=realtype) :: r0_xib(3), angleb, b0b(3, 3), b0invb(3, 3)
    real(kind=realtype) :: r0_xi_n(3), point(3), neigh1_point(3), &
&   neigh2_point(3)
    real(kind=realtype) :: r0_xi_nb(3), neigh1_pointb(3), neigh2_pointb(&
&   3)
    real(kind=realtype) :: r0_eta_n(3), a0(3, 3), r0_eta(3)
    real(kind=realtype) :: r0_eta_nb(3), a0b(3, 3), r0_etab(3)
    real(kind=realtype) :: dsensor, dnum, dden, eye(3, 3), b0invg(3), c0&
&   (3, 3)
    real(kind=realtype) :: dsensorb, dnumb, ddenb, b0invgb(3), c0b(3, 3)
    real(kind=realtype) :: epse, epsi, de(3), numnorm1, numnorm2, &
&   numnorm3, numnorm4
    real(kind=realtype) :: epseb, epsib, deb(3), numnorm1b, numnorm2b, &
&   numnorm3b, numnorm4b
    integer(kind=inttype) :: index, i, j, neighbor1_index, &
&   neighbor2_index
    real(kind=realtype) :: one, zero
    real(kind=realtype), dimension(3) :: arg1
    real(kind=realtype), dimension(3) :: arg1b
    integer :: branch
    real(kind=realtype) :: tempb4(3)
    real(kind=realtype) :: tempb3(3)
    real(kind=realtype) :: tempb2(3)
    real(kind=realtype) :: tempb1(3)
    real(kind=realtype) :: tempb0(3)
    real(kind=realtype) :: tempb(3)
    one = 1.
    zero = 0.
    pi = 3.1415926535897932384626
    eye(:, :) = zero
    do i=1,3
      eye(i, i) = one
    end do
    if (curr_index .eq. 1) then
! forward case
      if (bc1 .ne. 'continuous') then
        neighbor1_index = 2
        neighbor2_index = 3
! using forward differencing for xi = 1
        r0_xi = 0.5*(-(3*r0(:3))+4*r0(4:6)-r0(7:9))
        angle = pi
        call pushcontrol2b(0)
      else
        neighbor1_index = numnodes - 1
        neighbor2_index = 2
! using central differencing for zeta = 2:numnodes-1
        r0_xi = 0.5*(r0(4:6)-r0(3*(neighbor1_index-1)+1:3*(&
&         neighbor1_index-1)+3))
! compute the local grid angle based on the neighbors
        call giveangle(r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+&
&                3), r0(:3), r0(4:6), n0(:, 1), angle)
        call pushcontrol2b(1)
      end if
    else if (curr_index .eq. numnodes) then
! backward case
      neighbor1_index = curr_index - 1
      neighbor2_index = curr_index - 2
! using backward differencing for xi = numnodes
      r0_xi = 0.5*(3*r0(3*(curr_index-1)+1:3*(curr_index-1)+3)-4*r0(3*(&
&       neighbor1_index-1)+1:3*(neighbor1_index-1)+3)+r0(3*(&
&       neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
      angle = pi
      call pushcontrol2b(2)
    else
! central case
      neighbor1_index = curr_index - 1
      neighbor2_index = curr_index + 1
      neigh2_point = r0(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3)
      neigh1_point = r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)
! using central differencing for zeta = 2:numnodes-1
      r0_xi = 0.5*(neigh2_point-neigh1_point)
! compute the local grid angle based on the neighbors
      call giveangle(neigh1_point, r0(3*(curr_index-1)+1:3*(curr_index-1&
&              )+3), neigh2_point, n0(:, curr_index), angle)
      call pushcontrol2b(3)
    end if
    call cross(n0(:, curr_index), r0_xi, r0_xi_n)
! assemble b0 matrix
    b0(1, :) = r0_xi
    b0(2, :) = r0_xi_n
    b0(3, :) = n0(:, curr_index)
! invert b0
    call matinv3(b0, b0inv)
! compute eta derivatives
    r0_eta = b0inv(:, 2)*sm1(curr_index)
    call cross(n0(:, curr_index), r0_eta, r0_eta_n)
! assemble a0 matrix
    a0(1, :) = r0_eta
    a0(2, :) = r0_eta_n
    a0(3, :) = zero
    arg1(:) = rm1(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) - rm1&
&     (3*(curr_index-1)+1:3*(curr_index-1)+3)
    call norm(arg1(:), numnorm1)
    call pushreal8array(arg1, realtype*3/8)
    arg1(:) = rm1(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) - rm1&
&     (3*(curr_index-1)+1:3*(curr_index-1)+3)
    call norm(arg1(:), numnorm2)
    call pushreal8array(arg1, realtype*3/8)
    arg1(:) = r0(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) - r0(3&
&     *(curr_index-1)+1:3*(curr_index-1)+3)
    call norm(arg1(:), numnorm3)
    call pushreal8array(arg1, realtype*3/8)
    arg1(:) = r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) - r0(3&
&     *(curr_index-1)+1:3*(curr_index-1)+3)
    call norm(arg1(:), numnorm4)
! compute grid distribution sensor (eq. 6.8a)
    dnum = numnorm1 + numnorm2
    dden = numnorm3 + numnorm4
    dsensor = dnum/dden
! sharp convex corner detection
    if (angle .lt. 70.*pi/180.) then
      fb(3*(curr_index-1)+1:3*(curr_index-1)+3) = 0.0_8
      kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)+1:&
&     3*(neighbor1_index-1)+3) = 0.0_8
      kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*(&
&     curr_index-1)+3) = 0.0_8
      kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)+1:&
&     3*(neighbor2_index-1)+3) = 0.0_8
      r0_etab = 0.0_8
      dsensorb = 0.0_8
      a0b = 0.0_8
      b0invb = 0.0_8
      angleb = 0.0_8
      r0_xib = 0.0_8
    else
! compute smoothing coefficients
      call dissipationcoefficients(layerindex, r0_xi, r0_eta, dsensor, &
&                            angle, numlayers, epse0, epse, epsi)
! compute rhs components
      if (curr_index .eq. 1) then
        if (bc1 .ne. 'continuous') then
          deb = 0.0_8
          b0invgb = 0.0_8
          b0invgb = fb(3*(curr_index-1)+1:3*(curr_index-1)+3)
          deb = fb(3*(curr_index-1)+1:3*(curr_index-1)+3)
          fb(3*(curr_index-1)+1:3*(curr_index-1)+3) = 0.0_8
          c0b = 0.0_8
          epsib = -sum(eye*kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(&
&           curr_index-1)+1:3*(curr_index-1)+3))
          c0b = -((theta+1)*1.5*kb(3*(curr_index-1)+1:3*(curr_index-1)+3&
&           , 3*(curr_index-1)+1:3*(curr_index-1)+3))
          kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3&
&         *(curr_index-1)+3) = 0.0_8
          c0b = c0b + (theta+1)*2*kb(3*(curr_index-1)+1:3*(curr_index-1)&
&           +3, 3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)
          epsib = epsib + sum(eye*2*kb(3*(curr_index-1)+1:3*(curr_index-&
&           1)+3, 3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3))
          kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1&
&         )+1:3*(neighbor1_index-1)+3) = 0.0_8
          c0b = c0b - (theta+1)*0.5*kb(3*(curr_index-1)+1:3*(curr_index-&
&           1)+3, 3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3)
          epsib = epsib - sum(eye*kb(3*(curr_index-1)+1:3*(curr_index-1)&
&           +3, 3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
          kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1&
&         )+1:3*(neighbor2_index-1)+3) = 0.0_8
          tempb1 = epse*deb
          epseb = sum((r0(3*(curr_index-1)+1:3*(curr_index-1)+3)-2*r0(3*&
&           (neighbor1_index-1)+1:3*(neighbor1_index-1)+3)+r0(3*(&
&           neighbor2_index-1)+1:3*(neighbor2_index-1)+3))*deb)
          r0b(3*(curr_index-1)+1:3*(curr_index-1)+3) = r0b(3*(curr_index&
&           -1)+1:3*(curr_index-1)+3) + tempb1
          r0b(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) = r0b(3*(&
&           neighbor1_index-1)+1:3*(neighbor1_index-1)+3) - 2*tempb1
          r0b(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) = r0b(3*(&
&           neighbor2_index-1)+1:3*(neighbor2_index-1)+3) + tempb1
        else
          deb = 0.0_8
          b0invgb = 0.0_8
          b0invgb = fb(3*(curr_index-1)+1:3*(curr_index-1)+3)
          deb = fb(3*(curr_index-1)+1:3*(curr_index-1)+3)
          fb(3*(curr_index-1)+1:3*(curr_index-1)+3) = 0.0_8
          c0b = 0.0_8
          c0b = (theta+1)*0.5*kb(3*(curr_index-1)+1:3*(curr_index-1)+3, &
&           3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3)
          epsib = -sum(eye*kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(&
&           neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
          kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1&
&         )+1:3*(neighbor2_index-1)+3) = 0.0_8
          epsib = epsib + 2*sum(eye*kb(3*(curr_index-1)+1:3*(curr_index-&
&           1)+3, 3*(curr_index-1)+1:3*(curr_index-1)+3))
          kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3&
&         *(curr_index-1)+3) = 0.0_8
          c0b = c0b - (theta+1)*0.5*kb(3*(curr_index-1)+1:3*(curr_index-&
&           1)+3, 3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)
          epsib = epsib - sum(eye*kb(3*(curr_index-1)+1:3*(curr_index-1)&
&           +3, 3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3))
          kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1&
&         )+1:3*(neighbor1_index-1)+3) = 0.0_8
          tempb2 = epse*deb
          epseb = sum((r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+&
&           3)-2*r0(3*(curr_index-1)+1:3*(curr_index-1)+3)+r0(3*(&
&           neighbor2_index-1)+1:3*(neighbor2_index-1)+3))*deb)
          r0b(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) = r0b(3*(&
&           neighbor1_index-1)+1:3*(neighbor1_index-1)+3) + tempb2
          r0b(3*(curr_index-1)+1:3*(curr_index-1)+3) = r0b(3*(curr_index&
&           -1)+1:3*(curr_index-1)+3) - 2*tempb2
          r0b(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) = r0b(3*(&
&           neighbor2_index-1)+1:3*(neighbor2_index-1)+3) + tempb2
        end if
      else if (curr_index .eq. numnodes) then
        deb = 0.0_8
        b0invgb = 0.0_8
        b0invgb = fb(3*(curr_index-1)+1:3*(curr_index-1)+3)
        deb = fb(3*(curr_index-1)+1:3*(curr_index-1)+3)
        fb(3*(curr_index-1)+1:3*(curr_index-1)+3) = 0.0_8
        c0b = 0.0_8
        c0b = (theta+1)*1.5*kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*&
&         (curr_index-1)+1:3*(curr_index-1)+3)
        epsib = -sum(eye*kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(&
&         curr_index-1)+1:3*(curr_index-1)+3))
        kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*(&
&       curr_index-1)+3) = 0.0_8
        epsib = epsib + sum(eye*2*kb(3*(curr_index-1)+1:3*(curr_index-1)&
&         +3, 3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3))
        c0b = c0b - (theta+1)*2*kb(3*(curr_index-1)+1:3*(curr_index-1)+3&
&         , 3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)
        kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)+&
&       1:3*(neighbor1_index-1)+3) = 0.0_8
        c0b = c0b + (theta+1)*0.5*kb(3*(curr_index-1)+1:3*(curr_index-1)&
&         +3, 3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3)
        epsib = epsib - sum(eye*kb(3*(curr_index-1)+1:3*(curr_index-1)+3&
&         , 3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
        kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)+&
&       1:3*(neighbor2_index-1)+3) = 0.0_8
        tempb3 = epse*deb
        epseb = sum((r0(3*(curr_index-1)+1:3*(curr_index-1)+3)-2*r0(3*(&
&         neighbor1_index-1)+1:3*(neighbor1_index-1)+3)+r0(3*(&
&         neighbor2_index-1)+1:3*(neighbor2_index-1)+3))*deb)
        r0b(3*(curr_index-1)+1:3*(curr_index-1)+3) = r0b(3*(curr_index-1&
&         )+1:3*(curr_index-1)+3) + tempb3
        r0b(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) = r0b(3*(&
&         neighbor1_index-1)+1:3*(neighbor1_index-1)+3) - 2*tempb3
        r0b(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) = r0b(3*(&
&         neighbor2_index-1)+1:3*(neighbor2_index-1)+3) + tempb3
      else
        deb = 0.0_8
        b0invgb = 0.0_8
        b0invgb = fb(3*(curr_index-1)+1:3*(curr_index-1)+3)
        deb = fb(3*(curr_index-1)+1:3*(curr_index-1)+3)
        fb(3*(curr_index-1)+1:3*(curr_index-1)+3) = 0.0_8
        c0b = 0.0_8
        c0b = (theta+1)*0.5*kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*&
&         (neighbor2_index-1)+1:3*(neighbor2_index-1)+3)
        epsib = -sum(eye*kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(&
&         neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
        kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)+&
&       1:3*(neighbor2_index-1)+3) = 0.0_8
        epsib = epsib + 2*sum(eye*kb(3*(curr_index-1)+1:3*(curr_index-1)&
&         +3, 3*(curr_index-1)+1:3*(curr_index-1)+3))
        kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*(&
&       curr_index-1)+3) = 0.0_8
        c0b = c0b - (theta+1)*0.5*kb(3*(curr_index-1)+1:3*(curr_index-1)&
&         +3, 3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)
        epsib = epsib - sum(eye*kb(3*(curr_index-1)+1:3*(curr_index-1)+3&
&         , 3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3))
        kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)+&
&       1:3*(neighbor1_index-1)+3) = 0.0_8
        tempb4 = epse*deb
        epseb = sum((r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)&
&         -2*r0(3*(curr_index-1)+1:3*(curr_index-1)+3)+r0(3*(&
&         neighbor2_index-1)+1:3*(neighbor2_index-1)+3))*deb)
        r0b(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) = r0b(3*(&
&         neighbor1_index-1)+1:3*(neighbor1_index-1)+3) + tempb4
        r0b(3*(curr_index-1)+1:3*(curr_index-1)+3) = r0b(3*(curr_index-1&
&         )+1:3*(curr_index-1)+3) - 2*tempb4
        r0b(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) = r0b(3*(&
&         neighbor2_index-1)+1:3*(neighbor2_index-1)+3) + tempb4
      end if
      b0invb = 0.0_8
      b0invb(:, 2) = b0invb(:, 2) + s0(curr_index)*b0invgb
      s0b(curr_index) = s0b(curr_index) + sum(b0inv(:, 2)*b0invgb)
      call dissipationcoefficients_b(layerindex, r0_xi, r0_xib, r0_eta, &
&                              r0_etab, dsensor, dsensorb, angle, angleb&
&                              , numlayers, epse0, epse, epseb, epsi, &
&                              epsib)
      a0b = 0.0_8
      do i=3,1,-1
        do j=3,1,-1
          call dot_b0(b0inv(i, :), b0invb(i, :), a0(:, j), a0b(:, j), c0&
&               (i, j), c0b(i, j))
          c0b(i, j) = 0.0_8
        end do
      end do
    end if
    dnumb = dsensorb/dden
    ddenb = -(dnum*dsensorb/dden**2)
    numnorm3b = ddenb
    numnorm4b = ddenb
    numnorm1b = dnumb
    numnorm2b = dnumb
    call norm_b0(arg1(:), arg1b(:), numnorm4, numnorm4b)
    call popreal8array(arg1, realtype*3/8)
    r0b(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) = r0b(3*(&
&     neighbor1_index-1)+1:3*(neighbor1_index-1)+3) + arg1b
    r0b(3*(curr_index-1)+1:3*(curr_index-1)+3) = r0b(3*(curr_index-1)+1:&
&     3*(curr_index-1)+3) - arg1b
    call norm_b0(arg1(:), arg1b(:), numnorm3, numnorm3b)
    call popreal8array(arg1, realtype*3/8)
    r0b(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) = r0b(3*(&
&     neighbor2_index-1)+1:3*(neighbor2_index-1)+3) + arg1b
    r0b(3*(curr_index-1)+1:3*(curr_index-1)+3) = r0b(3*(curr_index-1)+1:&
&     3*(curr_index-1)+3) - arg1b
    call norm_b0(arg1(:), arg1b(:), numnorm2, numnorm2b)
    call popreal8array(arg1, realtype*3/8)
    rm1b(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) = rm1b(3*(&
&     neighbor1_index-1)+1:3*(neighbor1_index-1)+3) + arg1b
    rm1b(3*(curr_index-1)+1:3*(curr_index-1)+3) = rm1b(3*(curr_index-1)+&
&     1:3*(curr_index-1)+3) - arg1b
    call norm_b0(arg1(:), arg1b(:), numnorm1, numnorm1b)
    rm1b(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) = rm1b(3*(&
&     neighbor2_index-1)+1:3*(neighbor2_index-1)+3) + arg1b
    rm1b(3*(curr_index-1)+1:3*(curr_index-1)+3) = rm1b(3*(curr_index-1)+&
&     1:3*(curr_index-1)+3) - arg1b
    a0b(3, :) = 0.0_8
    r0_eta_nb = 0.0_8
    r0_eta_nb = a0b(2, :)
    a0b(2, :) = 0.0_8
    r0_etab = r0_etab + a0b(1, :)
    call cross_b(n0(:, curr_index), n0b(:, curr_index), r0_eta, r0_etab&
&          , r0_eta_n, r0_eta_nb)
    b0invb(:, 2) = b0invb(:, 2) + sm1(curr_index)*r0_etab
    sm1b(curr_index) = sm1b(curr_index) + sum(b0inv(:, 2)*r0_etab)
    call matinv3_b(b0, b0b, b0inv, b0invb)
    n0b(:, curr_index) = n0b(:, curr_index) + b0b(3, :)
    b0b(3, :) = 0.0_8
    r0_xi_nb = 0.0_8
    r0_xi_nb = b0b(2, :)
    b0b(2, :) = 0.0_8
    r0_xib = r0_xib + b0b(1, :)
    call cross_b(n0(:, curr_index), n0b(:, curr_index), r0_xi, r0_xib, &
&          r0_xi_n, r0_xi_nb)
    call popcontrol2b(branch)
    if (branch .lt. 2) then
      if (branch .eq. 0) then
        tempb = 0.5*r0_xib
        r0b(4:6) = r0b(4:6) + 4*tempb
        r0b(1:3) = r0b(1:3) - 3*tempb
        r0b(7:9) = r0b(7:9) - tempb
      else
        call giveangle_b(r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1&
&                  )+3), r0b(3*(neighbor1_index-1)+1:3*(neighbor1_index-&
&                  1)+3), r0(:3), r0b(:3), r0(4:6), r0b(4:6), n0(:, 1), &
&                  angle, angleb)
        r0b(4:6) = r0b(4:6) + 0.5*r0_xib
        r0b(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) = r0b(3*(&
&         neighbor1_index-1)+1:3*(neighbor1_index-1)+3) - 0.5*r0_xib
      end if
    else if (branch .eq. 2) then
      tempb0 = 0.5*r0_xib
      r0b(3*(curr_index-1)+1:3*(curr_index-1)+3) = r0b(3*(curr_index-1)+&
&       1:3*(curr_index-1)+3) + 3*tempb0
      r0b(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) = r0b(3*(&
&       neighbor1_index-1)+1:3*(neighbor1_index-1)+3) - 4*tempb0
      r0b(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) = r0b(3*(&
&       neighbor2_index-1)+1:3*(neighbor2_index-1)+3) + tempb0
    else
      neigh1_pointb = 0.0_8
      neigh2_pointb = 0.0_8
      call giveangle_b(neigh1_point, neigh1_pointb, r0(3*(curr_index-1)+&
&                1:3*(curr_index-1)+3), r0b(3*(curr_index-1)+1:3*(&
&                curr_index-1)+3), neigh2_point, neigh2_pointb, n0(:, &
&                curr_index), angle, angleb)
      neigh2_pointb = neigh2_pointb + 0.5*r0_xib
      neigh1_pointb = neigh1_pointb - 0.5*r0_xib
      r0b(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) = r0b(3*(&
&       neighbor1_index-1)+1:3*(neighbor1_index-1)+3) + neigh1_pointb
      r0b(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) = r0b(3*(&
&       neighbor2_index-1)+1:3*(neighbor2_index-1)+3) + neigh2_pointb
    end if
  end subroutine matrixbuilder_b
  subroutine matrixbuilder(curr_index, bc1, bc2, r0, rm1, n0, s0, sm1, &
&   numlayers, epse0, layerindex, theta, numnodes, k, f)
    implicit none
    integer(kind=inttype), intent(in) :: curr_index, numnodes, numlayers&
&   , layerindex
    real(kind=realtype), intent(in) :: r0(3*numnodes), rm1(3*numnodes), &
&   n0(3, numnodes)
    real(kind=realtype), intent(in) :: sm1(numnodes), epse0, s0(numnodes&
&   ), theta
    character(len=32), intent(in) :: bc1, bc2
    real(kind=realtype), intent(inout) :: k(3*numnodes, 3*numnodes), f(3&
&   *numnodes)
    real(kind=realtype) :: r_curr(3), r_next(3), d_vec(3), d_vec_rot(3)
    real(kind=realtype) :: r0_xi(3), pi, angle, b0(3, 3), b0inv(3, 3)
    real(kind=realtype) :: r0_xi_n(3), point(3), neigh1_point(3), &
&   neigh2_point(3)
    real(kind=realtype) :: r0_eta_n(3), a0(3, 3), r0_eta(3)
    real(kind=realtype) :: dsensor, dnum, dden, eye(3, 3), b0invg(3), c0&
&   (3, 3)
    real(kind=realtype) :: epse, epsi, de(3), numnorm1, numnorm2, &
&   numnorm3, numnorm4
    integer(kind=inttype) :: index, i, j, neighbor1_index, &
&   neighbor2_index
    real(kind=realtype) :: one, zero
    real(kind=realtype), dimension(3) :: arg1
    one = 1.
    zero = 0.
    pi = 3.1415926535897932384626
    eye(:, :) = zero
    do i=1,3
      eye(i, i) = one
    end do
    if (curr_index .eq. 1) then
! forward case
      if (bc1 .ne. 'continuous') then
        neighbor1_index = 2
        neighbor2_index = 3
! using forward differencing for xi = 1
        r0_xi = 0.5*(-(3*r0(:3))+4*r0(4:6)-r0(7:9))
        angle = pi
      else
        neighbor1_index = numnodes - 1
        neighbor2_index = 2
! using central differencing for zeta = 2:numnodes-1
        r0_xi = 0.5*(r0(4:6)-r0(3*(neighbor1_index-1)+1:3*(&
&         neighbor1_index-1)+3))
! compute the local grid angle based on the neighbors
        call giveangle(r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+&
&                3), r0(:3), r0(4:6), n0(:, 1), angle)
      end if
    else if (curr_index .eq. numnodes) then
! backward case
      neighbor1_index = curr_index - 1
      neighbor2_index = curr_index - 2
! using backward differencing for xi = numnodes
      r0_xi = 0.5*(3*r0(3*(curr_index-1)+1:3*(curr_index-1)+3)-4*r0(3*(&
&       neighbor1_index-1)+1:3*(neighbor1_index-1)+3)+r0(3*(&
&       neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
      angle = pi
    else
! central case
      neighbor1_index = curr_index - 1
      neighbor2_index = curr_index + 1
      neigh2_point = r0(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3)
      neigh1_point = r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)
! using central differencing for zeta = 2:numnodes-1
      r0_xi = 0.5*(neigh2_point-neigh1_point)
! compute the local grid angle based on the neighbors
      call giveangle(neigh1_point, r0(3*(curr_index-1)+1:3*(curr_index-1&
&              )+3), neigh2_point, n0(:, curr_index), angle)
    end if
    call cross(n0(:, curr_index), r0_xi, r0_xi_n)
! assemble b0 matrix
    b0(1, :) = r0_xi
    b0(2, :) = r0_xi_n
    b0(3, :) = n0(:, curr_index)
! invert b0
    call matinv3(b0, b0inv)
! compute eta derivatives
    r0_eta = b0inv(:, 2)*sm1(curr_index)
    call cross(n0(:, curr_index), r0_eta, r0_eta_n)
! assemble a0 matrix
    a0(1, :) = r0_eta
    a0(2, :) = r0_eta_n
    a0(3, :) = zero
    arg1(:) = rm1(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) - rm1&
&     (3*(curr_index-1)+1:3*(curr_index-1)+3)
    call norm(arg1(:), numnorm1)
    arg1(:) = rm1(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) - rm1&
&     (3*(curr_index-1)+1:3*(curr_index-1)+3)
    call norm(arg1(:), numnorm2)
    arg1(:) = r0(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) - r0(3&
&     *(curr_index-1)+1:3*(curr_index-1)+3)
    call norm(arg1(:), numnorm3)
    arg1(:) = r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) - r0(3&
&     *(curr_index-1)+1:3*(curr_index-1)+3)
    call norm(arg1(:), numnorm4)
! compute grid distribution sensor (eq. 6.8a)
    dnum = numnorm1 + numnorm2
    dden = numnorm3 + numnorm4
    dsensor = dnum/dden
! sharp convex corner detection
    if (angle .lt. 70.*pi/180.) then
! corner detected
! populate matrix with eq 8.3
      k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)+1:3&
&     *(neighbor2_index-1)+3) = -eye
      k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*(&
&     curr_index-1)+3) = 2*eye
      k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)+1:3&
&     *(neighbor1_index-1)+3) = -eye
      f(3*(curr_index-1)+1:3*(curr_index-1)+3) = zero
    else
! compute c0 = b0inv*a0
      do i=1,3
        do j=1,3
          call dot(b0inv(i, :), a0(:, j), c0(i, j))
        end do
      end do
! compute smoothing coefficients
      call dissipationcoefficients(layerindex, r0_xi, r0_eta, dsensor, &
&                            angle, numlayers, epse0, epse, epsi)
! compute rhs components
      b0invg = b0inv(:, 2)*s0(curr_index)
      if (curr_index .eq. 1) then
        if (bc1 .ne. 'continuous') then
! forwards
          de = epse*(r0(3*(curr_index-1)+1:3*(curr_index-1)+3)-2*r0(3*(&
&           neighbor1_index-1)+1:3*(neighbor1_index-1)+3)+r0(3*(&
&           neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
! populate matrix
          k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)&
&         +1:3*(neighbor2_index-1)+3) = -(0.5*(1+theta)*c0) - epsi*eye
          k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)&
&         +1:3*(neighbor1_index-1)+3) = 2*(1+theta)*c0 + 2*epsi*eye
          k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*&
&         (curr_index-1)+3) = -(1.5*(1+theta)*c0) + (1-epsi)*eye
          f(3*(curr_index-1)+1:3*(curr_index-1)+3) = b0invg + de
        else
          de = epse*(r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)&
&           -2*r0(3*(curr_index-1)+1:3*(curr_index-1)+3)+r0(3*(&
&           neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
! populate matrix
          k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)&
&         +1:3*(neighbor1_index-1)+3) = -(0.5*(1+theta)*c0) - epsi*eye
          k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*&
&         (curr_index-1)+3) = (1+2*epsi)*eye
          k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)&
&         +1:3*(neighbor2_index-1)+3) = 0.5*(1+theta)*c0 - epsi*eye
          f(3*(curr_index-1)+1:3*(curr_index-1)+3) = b0invg + de
        end if
      else if (curr_index .eq. numnodes) then
! backwards
        de = epse*(r0(3*(curr_index-1)+1:3*(curr_index-1)+3)-2*r0(3*(&
&         neighbor1_index-1)+1:3*(neighbor1_index-1)+3)+r0(3*(&
&         neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
! populate matrix
        k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)+1&
&       :3*(neighbor2_index-1)+3) = 0.5*(1+theta)*c0 - epsi*eye
        k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)+1&
&       :3*(neighbor1_index-1)+3) = -(2*(1+theta)*c0) + 2*epsi*eye
        k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*(&
&       curr_index-1)+3) = 1.5*(1+theta)*c0 + (1-epsi)*eye
        f(3*(curr_index-1)+1:3*(curr_index-1)+3) = b0invg + de
      else
! central
        de = epse*(r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)-2&
&         *r0(3*(curr_index-1)+1:3*(curr_index-1)+3)+r0(3*(&
&         neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
        k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)+1&
&       :3*(neighbor1_index-1)+3) = -(0.5*(1+theta)*c0) - epsi*eye
        k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*(&
&       curr_index-1)+3) = (1+2*epsi)*eye
        k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)+1&
&       :3*(neighbor2_index-1)+3) = 0.5*(1+theta)*c0 - epsi*eye
        f(3*(curr_index-1)+1:3*(curr_index-1)+3) = b0invg + de
      end if
    end if
  end subroutine matrixbuilder
!  differentiation of dissipationcoefficients in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: epse epsi
!   with respect to varying inputs: r0_eta dsensor angle r0_xi
  subroutine dissipationcoefficients_b(layerindex, r0_xi, r0_xib, r0_eta&
&   , r0_etab, dsensor, dsensorb, angle, angleb, numlayers, epse0, epse&
&   , epseb, epsi, epsib)
    implicit none
    integer(kind=inttype), intent(in) :: layerindex, numlayers
    real(kind=realtype), intent(in) :: dsensor, angle, epse0, r0_xi(3), &
&   r0_eta(3)
    real(kind=realtype) :: dsensorb, angleb, r0_xib(3), r0_etab(3)
    real(kind=realtype) :: epse, epsi
    real(kind=realtype) :: epseb, epsib
    real(kind=realtype) :: sl, dbar, a, pi, n, r, normeta, normxi
    real(kind=realtype) :: dbarb, ab, nb, rb, normetab, normxib
    integer(kind=inttype) :: l, ltrans
    intrinsic int
    intrinsic float
    intrinsic dsqrt
    intrinsic max
    intrinsic cos
    integer :: branch
    real(kind=realtype) :: temp
    pi = 3.14159265358979323846264338
! compute n (eq. 6.3)
    call norm(r0_eta, normeta)
    call norm(r0_xi, normxi)
    n = normeta/normxi
! compute sl (eq. 6.5) based on a transition l of 3/4 of max
    l = layerindex + 2
    ltrans = int(3./4.*numlayers)
    if (l .le. ltrans) then
      sl = dsqrt(float(l-1)/float(numlayers-1))
    else
      sl = dsqrt(float(ltrans-1)/float(numlayers-1))
    end if
    if (dsensor**(2./sl) .lt. 0.1) then
      dbar = 0.1
      call pushcontrol1b(0)
    else
      dbar = dsensor**(2./sl)
      call pushcontrol1b(1)
    end if
! compute a (eq 6.12 adjusted for entire angle (angle=2*alpha))
    if (angle .le. pi) then
! convex corner
      a = 1.0
      call pushcontrol1b(0)
    else
      a = 1.0/(1.0-cos(angle/2)*cos(angle/2))
      call pushcontrol1b(1)
    end if
! compute auxiliary variable r (eq. 6.4)
    r = sl*dbar*a
! compute the dissipation coefficients
    epseb = epseb + 2*epsib
    rb = epse0*n*epseb
    nb = epse0*r*epseb
    dbarb = sl*a*rb
    ab = sl*dbar*rb
    call popcontrol1b(branch)
    if (branch .eq. 0) then
      angleb = 0.0_8
    else
      temp = cos(angle/2)
      angleb = -(sin(angle/2)*temp*ab/(1.0-temp**2)**2)
    end if
    call popcontrol1b(branch)
    if (branch .eq. 0) then
      dsensorb = 0.0_8
    else if (dsensor .le. 0.0_8 .and. (2./sl .eq. 0.0_8 .or. 2./sl .ne. &
&       int(2./sl))) then
      dsensorb = 0.0
    else
      dsensorb = 2.*dsensor**(2./sl-1)*dbarb/sl
    end if
    normetab = nb/normxi
    normxib = -(normeta*nb/normxi**2)
    call norm_b0(r0_xi, r0_xib, normxi, normxib)
    call norm_b0(r0_eta, r0_etab, normeta, normetab)
  end subroutine dissipationcoefficients_b
  subroutine dissipationcoefficients(layerindex, r0_xi, r0_eta, dsensor&
&   , angle, numlayers, epse0, epse, epsi)
    implicit none
    integer(kind=inttype), intent(in) :: layerindex, numlayers
    real(kind=realtype), intent(in) :: dsensor, angle, epse0, r0_xi(3), &
&   r0_eta(3)
    real(kind=realtype), intent(out) :: epse, epsi
    real(kind=realtype) :: sl, dbar, a, pi, n, r, normeta, normxi
    integer(kind=inttype) :: l, ltrans
    intrinsic int
    intrinsic float
    intrinsic dsqrt
    intrinsic max
    intrinsic cos
    pi = 3.14159265358979323846264338
! compute n (eq. 6.3)
    call norm(r0_eta, normeta)
    call norm(r0_xi, normxi)
    n = normeta/normxi
! compute sl (eq. 6.5) based on a transition l of 3/4 of max
    l = layerindex + 2
    ltrans = int(3./4.*numlayers)
    if (l .le. ltrans) then
      sl = dsqrt(float(l-1)/float(numlayers-1))
    else
      sl = dsqrt(float(ltrans-1)/float(numlayers-1))
    end if
    if (dsensor**(2./sl) .lt. 0.1) then
      dbar = 0.1
    else
      dbar = dsensor**(2./sl)
    end if
! compute a (eq 6.12 adjusted for entire angle (angle=2*alpha))
    if (angle .le. pi) then
! convex corner
      a = 1.0
    else
      a = 1.0/(1.0-cos(angle/2)*cos(angle/2))
    end if
! compute auxiliary variable r (eq. 6.4)
    r = sl*dbar*a
! compute the dissipation coefficients
    epse = epse0*r*n
    epsi = 2*epse
  end subroutine dissipationcoefficients
!  differentiation of areafactor in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: s
!   with respect to varying inputs: d s r0
!   rw status of diff variables: d:out s:in-zero r0:out
  subroutine areafactor_b(r0, r0b, d, db, nuarea, numareapasses, bc1, &
&   bc2, guideindices, retainspacing, numguides, n, s, sb, maxstretch)
    implicit none
    integer(kind=inttype), intent(in) :: n
    real(kind=realtype), intent(in) :: r0(3*n), d, nuarea
    real(kind=realtype) :: r0b(3*n), db
    integer(kind=inttype), intent(in) :: numareapasses
    character(len=32), intent(in) :: bc1, bc2
    integer(kind=inttype), intent(in) :: numguides
    integer(kind=inttype), intent(in) :: guideindices(numguides)
    logical, intent(in) :: retainspacing
    real(kind=realtype) :: s(n), maxstretch
    real(kind=realtype) :: sb(n)
    real(kind=realtype) :: r0_extrap(3*(2+n))
    real(kind=realtype) :: r0_extrapb(3*(2+n))
    real(kind=realtype) :: neighbordist(n), norm_1(n), norm_2(n)
    real(kind=realtype) :: neighbordistb(n), norm_1b(n), norm_2b(n)
    real(kind=realtype) :: sminus, splus, stretchratio(n)
    real(kind=realtype) :: sminusb, splusb
    integer(kind=inttype) :: index, i
    real(kind=realtype), dimension(3) :: arg1
    real(kind=realtype), dimension(3) :: arg1b
    real(kind=realtype), dimension(n-2) :: tmp
    integer :: branch
    real(kind=realtype) :: tmpb(n-2)
    real(kind=realtype) :: tempb(n-2)
! extrapolate the end points and copy starting curve
    r0_extrap(:3) = 2*r0(:3) - r0(4:6)
    r0_extrap(4:3*(n+1)) = r0
    r0_extrap(3*(n+1)+1:) = 2*r0(3*(n-1)+1:) - r0(3*(n-2)+1:3*(n-1))
! compute the distance of each node to its neighbors
    do index=1,n
      arg1(:) = r0_extrap(3*index+1:3*index+3) - r0_extrap(3*index-2:3*&
&       index)
      call norm(arg1(:), norm_1(index))
      arg1(:) = r0_extrap(3*index+4:3*index+6) - r0_extrap(3*index+1:3*&
&       index+3)
      call norm(arg1(:), norm_2(index))
    end do
    neighbordist = 0.5*(norm_1+norm_2)
! multiply distances by the step size to get the areas
! divide the marching distance and the neighbor distance to get the stretch ratios
! get the maximum stretch ratio
! if we use curve boundary conditions, we need just the marching distance, and not area, for the end nodes
    if (bc1(:5) .eq. 'curve') then
      call pushcontrol1b(0)
    else
      call pushcontrol1b(1)
    end if
    if (bc2(:5) .eq. 'curve') then
      call pushcontrol1b(0)
    else
      call pushcontrol1b(1)
    end if
    if (retainspacing) then
      do i=numguides,1,-1
        index = guideindices(i)
        db = db + sb(index)
        sb(index) = 0.0_8
      end do
    else
    end if
    call popcontrol1b(branch)
    if (branch .eq. 0) then
      db = db + sb(n)
      sb(n) = 0.0_8
    end if
    call popcontrol1b(branch)
    if (branch .eq. 0) then
      db = db + sb(1)
      sb(1) = 0.0_8
    end if
    do index=numareapasses,1,-1
      sminusb = nuarea*sb(n)
      sb(n) = (1-nuarea)*sb(n)
      splusb = nuarea*sb(1)
      sb(1) = (1-nuarea)*sb(1)
      tmpb(1:n-2) = sb(2:n-1)
      sb(2:n-1) = (1-nuarea)*tmpb(1:n-2)
      tempb = nuarea*tmpb(1:n-2)/2
      sb(1:n-2) = sb(1:n-2) + tempb
      sb(3:n) = sb(3:n) + tempb
      sb(n-1) = sb(n-1) + sminusb
      sb(2) = sb(2) + splusb
    end do
    neighbordistb = 0.0_8
    db = db + sum(neighbordist*sb)
    neighbordistb = d*sb
    norm_1b = 0.0_8
    norm_2b = 0.0_8
    norm_1b = 0.5*neighbordistb
    norm_2b = 0.5*neighbordistb
    r0_extrapb = 0.0_8
    do index=n,1,-1
      arg1(:) = r0_extrap(3*index+4:3*index+6) - r0_extrap(3*index+1:3*&
&       index+3)
      call norm_b0(arg1(:), arg1b(:), norm_2(index), norm_2b(index))
      norm_2b(index) = 0.0_8
      r0_extrapb(3*index+4:3*index+6) = r0_extrapb(3*index+4:3*index+6) &
&       + arg1b
      r0_extrapb(3*index+1:3*index+3) = r0_extrapb(3*index+1:3*index+3) &
&       - arg1b
      arg1(:) = r0_extrap(3*index+1:3*index+3) - r0_extrap(3*index-2:3*&
&       index)
      call norm_b0(arg1(:), arg1b(:), norm_1(index), norm_1b(index))
      norm_1b(index) = 0.0_8
      r0_extrapb(3*index+1:3*index+3) = r0_extrapb(3*index+1:3*index+3) &
&       + arg1b
      r0_extrapb(3*index-2:3*index) = r0_extrapb(3*index-2:3*index) - &
&       arg1b
    end do
    r0b(3*(n-1)+1:3*n) = r0b(3*(n-1)+1:3*n) + 2*r0_extrapb(3*(n+1)+1:3*(&
&     2+n))
    r0b(3*(n-2)+1:3*(n-1)) = r0b(3*(n-2)+1:3*(n-1)) - r0_extrapb(3*(n+1)&
&     +1:3*(2+n))
    r0_extrapb(3*(n+1)+1:3*(2+n)) = 0.0_8
    r0b = r0b + r0_extrapb(4:3*(n+1))
    r0_extrapb(4:3*(n+1)) = 0.0_8
    r0b(1:3) = r0b(1:3) + 2*r0_extrapb(1:3)
    r0b(4:6) = r0b(4:6) - r0_extrapb(1:3)
    sb = 0.0_8
  end subroutine areafactor_b
  subroutine areafactor(r0, d, nuarea, numareapasses, bc1, bc2, &
&   guideindices, retainspacing, numguides, n, s, maxstretch)
    implicit none
    integer(kind=inttype), intent(in) :: n
    real(kind=realtype), intent(in) :: r0(3*n), d, nuarea
    integer(kind=inttype), intent(in) :: numareapasses
    character(len=32), intent(in) :: bc1, bc2
    integer(kind=inttype), intent(in) :: numguides
    integer(kind=inttype), intent(in) :: guideindices(numguides)
    logical, intent(in) :: retainspacing
    real(kind=realtype), intent(out) :: s(n), maxstretch
    real(kind=realtype) :: r0_extrap(3*(2+n))
    real(kind=realtype) :: neighbordist(n), norm_1(n), norm_2(n)
    real(kind=realtype) :: sminus, splus, stretchratio(n)
    integer(kind=inttype) :: index, i
    real(kind=realtype), dimension(3) :: arg1
! extrapolate the end points and copy starting curve
    r0_extrap(:3) = 2*r0(:3) - r0(4:6)
    r0_extrap(4:3*(n+1)) = r0
    r0_extrap(3*(n+1)+1:) = 2*r0(3*(n-1)+1:) - r0(3*(n-2)+1:3*(n-1))
! compute the distance of each node to its neighbors
    do index=1,n
      arg1(:) = r0_extrap(3*index+1:3*index+3) - r0_extrap(3*index-2:3*&
&       index)
      call norm(arg1(:), norm_1(index))
      arg1(:) = r0_extrap(3*index+4:3*index+6) - r0_extrap(3*index+1:3*&
&       index+3)
      call norm(arg1(:), norm_2(index))
    end do
    neighbordist = 0.5*(norm_1+norm_2)
! multiply distances by the step size to get the areas
    s = d*neighbordist
! divide the marching distance and the neighbor distance to get the stretch ratios
    stretchratio = d/neighbordist
! get the maximum stretch ratio
    maxstretch = -1.e20
    do index=1,n
      if (stretchratio(index) .gt. maxstretch) maxstretch = stretchratio&
&         (index)
    end do
! do the requested number of averagings
    do index=1,numareapasses
! store previous values
      splus = s(2)
      sminus = s(n-1)
! do the averaging for the central nodes
      s(2:n-1) = (1-nuarea)*s(2:n-1) + nuarea/2*(s(:n-2)+s(3:))
! average for the extremum nodes
      s(1) = (1-nuarea)*s(1) + nuarea*splus
      s(n) = (1-nuarea)*s(n) + nuarea*sminus
    end do
! if we use curve boundary conditions, we need just the marching distance, and not area, for the end nodes
    if (bc1(:5) .eq. 'curve') s(1) = d
    if (bc2(:5) .eq. 'curve') s(n) = d
    if (retainspacing) then
! set guidecurve marching distances
      do i=1,numguides
        index = guideindices(i)
        s(index) = d
      end do
    end if
  end subroutine areafactor
!  differentiation of smoothing_main in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: rout
!   with respect to varying inputs: r rout
!   rw status of diff variables: r:out rout:in-zero
  subroutine smoothing_main_b(r, rb, eta, alphap0, numsmoothingpasses, &
&   numlayers, n, rout, routb)
    implicit none
    integer(kind=inttype), intent(in) :: n
    real(kind=realtype), intent(in) :: eta, alphap0
    integer(kind=inttype), intent(in) :: numsmoothingpasses, numlayers
    real(kind=realtype), intent(in) :: r(3*n)
    real(kind=realtype) :: rb(3*n)
    real(kind=realtype) :: rout(3*n)
    real(kind=realtype) :: routb(3*n)
    real(kind=realtype) :: r_next(3), r_curr(3), r_prev(3), lp, lm, &
&   alphap
    real(kind=realtype) :: r_nextb(3), r_currb(3), r_prevb(3), lpb, lmb
    real(kind=realtype) :: r_smooth(3*n)
    real(kind=realtype) :: r_smoothb(3*n)
    integer(kind=inttype) :: index, index_pass
    intrinsic min
    real(kind=realtype), dimension(3) :: arg1
    real(kind=realtype), dimension(3) :: arg1b
    real(kind=realtype) :: tempb0
    real(kind=realtype) :: tempb(3)
    if (alphap0 .gt. alphap0*(eta-3)/numlayers) then
      alphap = alphap0*(eta-3)/numlayers
    else
      alphap = alphap0
    end if
    rout = r
! this function does the grid smoothing
! loop over the desired number of smoothing passes
    do index_pass=1,numsmoothingpasses
! copy nodes
      r_smooth = rout
! smooth every node
      do index=2,n-1
! get coordinates
        r_curr = rout(3*(index-1)+1:3*(index-1)+3)
        r_next = rout(3*index+1:3*index+3)
        r_prev = rout(3*(index-2)+1:3*(index-2)+3)
! compute distances
        arg1(:) = r_next - r_curr
        call pushreal8array(lp, realtype/8)
        call norm(arg1(:), lp)
        arg1(:) = r_curr - r_prev
        call pushreal8array(lm, realtype/8)
        call norm(arg1(:), lm)
! compute smoothed coordinates
        r_smooth(3*(index-1)+1:3*(index-1)+3) = (1.-alphap)*r_curr + &
&         alphap*(lm*r_next+lp*r_prev)/(lp+lm)
      end do
! copy coordinates to allow next pass
      call pushreal8array(rout, realtype*3*n/8)
      rout = r_smooth
    end do
    do index_pass=numsmoothingpasses,1,-1
      r_smoothb = 0.0_8
      call popreal8array(rout, realtype*3*n/8)
      r_smoothb = routb
      routb = 0.0_8
      do index=n-1,2,-1
        r_curr = rout(3*(index-1)+1:3*(index-1)+3)
        r_prev = rout(3*(index-2)+1:3*(index-2)+3)
        r_next = rout(3*index+1:3*index+3)
        r_currb = 0.0_8
        r_prevb = 0.0_8
        r_nextb = 0.0_8
        tempb = alphap*r_smoothb(3*(index-1)+1:3*(index-1)+3)/(lp+lm)
        tempb0 = sum(-((lm*r_next+lp*r_prev)*tempb/(lp+lm)))
        lmb = tempb0 + sum(r_next*tempb)
        r_nextb = lm*tempb
        lpb = tempb0 + sum(r_prev*tempb)
        arg1(:) = r_curr - r_prev
        call popreal8array(lm, realtype/8)
        call norm_b0(arg1(:), arg1b(:), lm, lmb)
        r_currb = arg1b(:) + (1.-alphap)*r_smoothb(3*(index-1)+1:3*(&
&         index-1)+3)
        r_prevb = lp*tempb - arg1b(:)
        r_smoothb(3*(index-1)+1:3*(index-1)+3) = 0.0_8
        arg1(:) = r_next - r_curr
        call popreal8array(lp, realtype/8)
        call norm_b0(arg1(:), arg1b(:), lp, lpb)
        r_nextb = r_nextb + arg1b
        r_currb = r_currb - arg1b
        routb(3*(index-2)+1:3*(index-2)+3) = routb(3*(index-2)+1:3*(&
&         index-2)+3) + r_prevb
        routb(3*index+1:3*index+3) = routb(3*index+1:3*index+3) + &
&         r_nextb
        routb(3*(index-1)+1:3*(index-1)+3) = routb(3*(index-1)+1:3*(&
&         index-1)+3) + r_currb
      end do
      routb = routb + r_smoothb
    end do
    rb = routb
    routb = 0.0_8
  end subroutine smoothing_main_b
  subroutine smoothing_main(r, eta, alphap0, numsmoothingpasses, &
&   numlayers, n, rout)
    implicit none
    integer(kind=inttype), intent(in) :: n
    real(kind=realtype), intent(in) :: eta, alphap0
    integer(kind=inttype), intent(in) :: numsmoothingpasses, numlayers
    real(kind=realtype), intent(in) :: r(3*n)
    real(kind=realtype), intent(out) :: rout(3*n)
    real(kind=realtype) :: r_next(3), r_curr(3), r_prev(3), lp, lm, &
&   alphap
    real(kind=realtype) :: r_smooth(3*n)
    integer(kind=inttype) :: index, index_pass
    intrinsic min
    real(kind=realtype), dimension(3) :: arg1
    if (alphap0 .gt. alphap0*(eta-3)/numlayers) then
      alphap = alphap0*(eta-3)/numlayers
    else
      alphap = alphap0
    end if
    rout = r
! this function does the grid smoothing
! loop over the desired number of smoothing passes
    do index_pass=1,numsmoothingpasses
! copy nodes
      r_smooth = rout
! smooth every node
      do index=2,n-1
! get coordinates
        r_curr = rout(3*(index-1)+1:3*(index-1)+3)
        r_next = rout(3*index+1:3*index+3)
        r_prev = rout(3*(index-2)+1:3*(index-2)+3)
! compute distances
        arg1(:) = r_next - r_curr
        call norm(arg1(:), lp)
        arg1(:) = r_curr - r_prev
        call norm(arg1(:), lm)
! compute smoothed coordinates
        r_smooth(3*(index-1)+1:3*(index-1)+3) = (1.-alphap)*r_curr + &
&         alphap*(lm*r_next+lp*r_prev)/(lp+lm)
      end do
! copy coordinates to allow next pass
      rout = r_smooth
    end do
  end subroutine smoothing_main
  subroutine qualitycheck(r, layerindex, numlayers, numnodes, fail, &
&   ratios)
    implicit none
    integer(kind=inttype), intent(in) :: numlayers, numnodes
    integer(kind=inttype), intent(in) :: layerindex
    real(kind=realtype), intent(in) :: r(numlayers, 3*numnodes)
    real(kind=realtype), intent(out) :: ratios(numlayers-1, numnodes-1)
    integer(kind=inttype), intent(out) :: fail
    real(kind=realtype) :: xyz(3, numlayers, numnodes), nodalnormals(3, &
&   numlayers, numnodes)
    real(kind=realtype) :: panelnormals(3, numlayers-1, numnodes-1), &
&   norm_vec(3)
    real(kind=realtype) :: vec1(3, numlayers-1, numnodes-1), vec2(3, &
&   numlayers-1, numnodes-1)
    real(kind=realtype) :: vec3(3, numlayers-2, numnodes-2), vec4(3, &
&   numlayers-2, numnodes-2)
    real(kind=realtype) :: nodalderivs(3, 2, numlayers, numnodes), det(&
&   numlayers, numnodes)
    real(kind=realtype) :: normals(3, numlayers-2, numnodes-2), &
&   nodaljacs(3, 3, numlayers, numnodes), norm_val
    integer(kind=inttype) :: i, j
    real(kind=realtype) :: zero
    intrinsic minval
    intrinsic maxval
    real :: result1
    real :: result2
    real :: result10
    zero = 0.
! convert the flattened array r into a 3 x numnodes x numlayers array.
! numlayers -> number of layers in the marching direction
! numnodes -> number of nodes in direction of curve
    do i=1,numnodes
      xyz(1, :, i) = r(:, 3*(i-1)+1)
      xyz(2, :, i) = r(:, 3*(i-1)+2)
      xyz(3, :, i) = r(:, 3*(i-1)+3)
    end do
! setup nodal normals
    nodalnormals(:, :, :) = zero
! get the panel normals from the interior points of the mesh.
! here we take the cross product of the diagonals of each face
    vec1 = xyz(:, 2:, 2:) - xyz(:, :numlayers-1, :numnodes-1)
    vec2 = xyz(:, 2:, :numnodes-1) - xyz(:, :numlayers-1, 2:)
    do i=1,numnodes-1
      do j=1,numlayers-1
        call cross(vec2(:, j, i), vec1(:, j, i), norm_vec)
        call norm(norm_vec, norm_val)
        panelnormals(:, j, i) = norm_vec/norm_val
      end do
    end do
! set the interior normals using an average of the panel normals
    vec3 = panelnormals(:, 2:, 2:) + panelnormals(:, :numlayers-2, :&
&     numnodes-2)
    vec4 = panelnormals(:, 2:, :numnodes-2) + panelnormals(:, :numlayers&
&     -2, 2:)
    normals = vec3 + vec4
    do i=2,numnodes-1
      do j=2,numlayers-1
        call norm(normals(:, j-1, i-1), norm_val)
        nodalnormals(:, j, i) = normals(:, j-1, i-1)/norm_val
      end do
    end do
! set the boundary normals
    nodalnormals(:, 2:, 1) = panelnormals(:, :, 1)
    nodalnormals(:, 1, :numnodes-1) = panelnormals(:, 1, :)
    nodalnormals(:, :numlayers-1, numnodes) = panelnormals(:, :, &
&     numnodes-1)
    nodalnormals(:, numlayers, 2:) = panelnormals(:, numlayers-1, :)
! setup nodal derivatives
    nodalderivs(:, :, :, :) = zero
! compute interior derivatives using 2nd order central differencing
    nodalderivs(:, 1, 2:numlayers-1, 2:numnodes-1) = (xyz(:, 3:, 2:&
&     numnodes-1)-xyz(:, :numlayers-2, 2:numnodes-1))/2.
    nodalderivs(:, 2, 2:numlayers-1, 2:numnodes-1) = (xyz(:, 2:numlayers&
&     -1, 3:)-xyz(:, 2:numlayers-1, :numnodes-2))/2.
! compute i derivatives using 1st order differencing
    nodalderivs(:, 1, 1, :) = xyz(:, 2, :) - xyz(:, 1, :)
    nodalderivs(:, 1, numlayers, :) = xyz(:, numlayers, :) - xyz(:, &
&     numlayers-1, :)
    nodalderivs(:, 1, 2:numlayers-1, 1) = (xyz(:, 3:, 1)-xyz(:, :&
&     numlayers-2, 1))/2.
    nodalderivs(:, 1, 2:numlayers-1, numnodes) = (xyz(:, 3:, numnodes)-&
&     xyz(:, :numlayers-2, numnodes))/2.
! compute j derivatives using 1st order differencing
    nodalderivs(:, 2, :, 1) = xyz(:, :, 2) - xyz(:, :, 1)
    nodalderivs(:, 2, :, numnodes) = xyz(:, :, numnodes) - xyz(:, :, &
&     numnodes-1)
    nodalderivs(:, 2, 1, 2:numnodes-1) = (xyz(:, 1, 3:)-xyz(:, 1, :&
&     numnodes-2))/2.
    nodalderivs(:, 2, numlayers, 2:numnodes-1) = (xyz(:, numlayers, 3:)-&
&     xyz(:, numlayers, :numnodes-2))/2.
! assemble nodal jacobians
    nodaljacs(:, :, :, :) = zero
    nodaljacs(1, :, :, :) = nodalderivs(:, 1, :, :)
    nodaljacs(2, :, :, :) = nodalderivs(:, 2, :, :)
    nodaljacs(3, :, :, :) = nodalnormals(:, :, :)
! compute determinants of jacobians and find ratio of min to max per face
    ratios(:, :) = zero
! compute the determinants of each nodal jacobian
    do i=1,numnodes
      do j=1,numlayers
        call m33det(nodaljacs(:, :, j, i), det(j, i))
      end do
    end do
! find the ratio of the minimum valued determinant to the maximum
! valued determinant.
! this is a measure of quality, with 1 being desirable and anything
! less than 0 meaning the mesh is no longer valid.
    do i=1,numnodes-1
      do j=1,numlayers-1
        result1 = minval(det(j:j+1, i:i+1))
        result2 = maxval(det(j:j+1, i:i+1))
        ratios(j, i) = result1/result2
      end do
    end do
    fail = 0
! throw an error and set the failure flag if the mesh is not valid
    do i=1,numnodes-1
      do j=1,numlayers-1
        if ((ratios(j, i) .ne. ratios(j, i) .or. ratios(j, i) .le. zero)&
&           .and. layerindex .ge. 1) then
          print*, '========= failure detected ============'
          fail = 1
        end if
      end do
    end do
    if (fail .eq. 1) print*, 'the mesh is not valid after step', &
&                    layerindex + 1
! throw a warning if the mesh is low quality
    result10 = minval(ratios)
    if (result10 .le. .2 .and. layerindex .ge. 1) print*, &
&                               'the mesh may be low quality after step'&
&                                                 , layerindex + 1
  end subroutine qualitycheck
!  differentiation of findradius in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: radius
!   with respect to varying inputs: radius r
!   rw status of diff variables: radius:in-zero r:out
  subroutine findradius_b(r, rb, numnodes, radius, radiusb)
    implicit none
    integer(kind=inttype), intent(in) :: numnodes
    real(kind=realtype), intent(in) :: r(3*numnodes)
    real(kind=realtype) :: rb(3*numnodes)
    real(kind=realtype) :: radius
    real(kind=realtype) :: radiusb
    real(kind=realtype) :: x, y, z
    real(kind=realtype) :: xb, yb, zb
    real(kind=realtype) :: minx, maxx, miny, maxy, minz, maxz
    real(kind=realtype) :: minxb, maxxb, minyb, maxyb, minzb, maxzb
    integer(kind=inttype) :: i
    integer :: branch
    minx = 1.e20
    miny = 1.e20
    minz = 1.e20
    maxx = -1.e20
    maxy = -1.e20
    maxz = -1.e20
! split coordinates and find max and min values
    do i=1,numnodes
      x = r(3*(i-1)+1)
      if (x .gt. maxx) then
        maxx = x
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
      if (x .lt. minx) then
        minx = x
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
      y = r(3*(i-1)+2)
      if (y .gt. maxy) then
        maxy = y
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
      if (y .lt. miny) then
        miny = y
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
      z = r(3*(i-1)+3)
      if (z .gt. maxz) then
        maxz = z
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
      if (z .lt. minz) then
        minz = z
        call pushcontrol1b(1)
      else
        call pushcontrol1b(0)
      end if
    end do
! find largest radius (we give only half of the largest side to be considered as radius)
    radius = -1.e20
    if (maxx - minx .gt. radius) then
      radius = maxx - minx
      call pushcontrol1b(0)
    else
      call pushcontrol1b(1)
    end if
    if (maxy - miny .gt. radius) then
      radius = maxy - miny
      call pushcontrol1b(0)
    else
      call pushcontrol1b(1)
    end if
    if (maxz - minz .gt. radius) then
      call pushcontrol1b(0)
    else
      call pushcontrol1b(1)
    end if
    radiusb = radiusb/2.
    call popcontrol1b(branch)
    if (branch .eq. 0) then
      maxzb = radiusb
      minzb = -radiusb
      radiusb = 0.0_8
    else
      minzb = 0.0_8
      maxzb = 0.0_8
    end if
    call popcontrol1b(branch)
    if (branch .eq. 0) then
      maxyb = radiusb
      minyb = -radiusb
      radiusb = 0.0_8
    else
      minyb = 0.0_8
      maxyb = 0.0_8
    end if
    call popcontrol1b(branch)
    if (branch .eq. 0) then
      maxxb = radiusb
      minxb = -radiusb
    else
      minxb = 0.0_8
      maxxb = 0.0_8
    end if
    do i=numnodes,1,-1
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        zb = 0.0_8
      else
        zb = minzb
        minzb = 0.0_8
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        zb = zb + maxzb
        maxzb = 0.0_8
      end if
      rb(3*(i-1)+3) = rb(3*(i-1)+3) + zb
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        yb = minyb
        minyb = 0.0_8
      else
        yb = 0.0_8
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        yb = yb + maxyb
        maxyb = 0.0_8
      end if
      rb(3*(i-1)+2) = rb(3*(i-1)+2) + yb
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        xb = minxb
        minxb = 0.0_8
      else
        xb = 0.0_8
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        xb = xb + maxxb
        maxxb = 0.0_8
      end if
      rb(3*(i-1)+1) = rb(3*(i-1)+1) + xb
    end do
    radiusb = 0.0_8
  end subroutine findradius_b
  subroutine findradius(r, numnodes, radius)
    implicit none
    integer(kind=inttype), intent(in) :: numnodes
    real(kind=realtype), intent(in) :: r(3*numnodes)
    real(kind=realtype), intent(out) :: radius
    real(kind=realtype) :: x, y, z
    real(kind=realtype) :: minx, maxx, miny, maxy, minz, maxz
    integer(kind=inttype) :: i
    minx = 1.e20
    miny = 1.e20
    minz = 1.e20
    maxx = -1.e20
    maxy = -1.e20
    maxz = -1.e20
! split coordinates and find max and min values
    do i=1,numnodes
      x = r(3*(i-1)+1)
      if (x .gt. maxx) maxx = x
      if (x .lt. minx) minx = x
      y = r(3*(i-1)+2)
      if (y .gt. maxy) maxy = y
      if (y .lt. miny) miny = y
      z = r(3*(i-1)+3)
      if (z .gt. maxz) maxz = z
      if (z .lt. minz) minz = z
    end do
! find largest radius (we give only half of the largest side to be considered as radius)
    radius = -1.e20
    if (maxx - minx .gt. radius) radius = maxx - minx
    if (maxy - miny .gt. radius) radius = maxy - miny
    if (maxz - minz .gt. radius) radius = maxz - minz
    radius = radius/2.
  end subroutine findradius
!  differentiation of findratio in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: q
!   with respect to varying inputs: q d0 dmax
!   rw status of diff variables: q:in-zero d0:out dmax:out
  subroutine findratio_b(dmax, dmaxb, d0, d0b, numlayers, ratioguess, q&
&   , qb)
    implicit none
    real(kind=realtype), intent(in) :: dmax, d0, ratioguess
    real(kind=realtype) :: dmaxb, d0b
    integer(kind=inttype), intent(in) :: numlayers
    real(kind=realtype) :: q
    real(kind=realtype) :: qb
    real(kind=realtype) :: rdot, r
    real(kind=realtype) :: rdotb, rb
    integer(kind=inttype) :: niters
! note that this counter is not the inttype that we use for all other integers.
! this is done so that tapenade correctly backwards differentiates this subroutine.
    integer :: i
    integer :: ad_to
! extra parameters
! maximum number of iterations for newton search
    niters = 200
! initialize ratio
    q = ratioguess
! newton search loop
    do i=1,niters
! residual function
      call pushreal8array(r, realtype/8)
      r = d0*(1.-q**(numlayers-1)) - dmax*(1.-q)
! residual derivative
      call pushreal8array(rdot, realtype/8)
      rdot = -((numlayers-1)*d0*q**(numlayers-2)) + dmax
! update ratio with newton search
      call pushreal8array(q, realtype/8)
      q = q - r/rdot
    end do
    call pushinteger4(i - 1)
! check if we got a reasonable value
    if (q .le. 1 .or. q .ge. ratioguess) then
      stop
    else
      d0b = 0.0_8
      dmaxb = 0.0_8
      call popinteger4(ad_to)
      do i=ad_to,1,-1
        call popreal8array(q, realtype/8)
        rb = -(qb/rdot)
        rdotb = r*qb/rdot**2
        call popreal8array(rdot, realtype/8)
        dmaxb = dmaxb + rdotb - (1.-q)*rb
        d0b = d0b + (1.-q**(numlayers-1))*rb - (numlayers-1)*q**(&
&         numlayers-2)*rdotb
        if (.not.(q .le. 0.0_8 .and. (numlayers - 2 .eq. 0.0_8 .or. &
&           numlayers - 2 .ne. int(numlayers - 2)))) qb = qb - d0*(&
&           numlayers-1)*(numlayers-2)*q**(numlayers-3)*rdotb
        call popreal8array(r, realtype/8)
        if (q .le. 0.0_8 .and. (numlayers - 1 .eq. 0.0_8 .or. numlayers &
&           - 1 .ne. int(numlayers - 1))) then
          qb = qb + dmax*rb
        else
          qb = qb + (dmax-d0*(numlayers-1)*q**(numlayers-2))*rb
        end if
      end do
      qb = 0.0_8
    end if
  end subroutine findratio_b
  subroutine findratio(dmax, d0, numlayers, ratioguess, q)
    implicit none
    real(kind=realtype), intent(in) :: dmax, d0, ratioguess
    integer(kind=inttype), intent(in) :: numlayers
    real(kind=realtype), intent(out) :: q
    real(kind=realtype) :: rdot, r
    integer(kind=inttype) :: niters
! note that this counter is not the inttype that we use for all other integers.
! this is done so that tapenade correctly backwards differentiates this subroutine.
    integer :: i
! extra parameters
! maximum number of iterations for newton search
    niters = 200
! initialize ratio
    q = ratioguess
! newton search loop
    do i=1,niters
! residual function
      r = d0*(1.-q**(numlayers-1)) - dmax*(1.-q)
! residual derivative
      rdot = -((numlayers-1)*d0*q**(numlayers-2)) + dmax
! update ratio with newton search
      q = q - r/rdot
    end do
! check if we got a reasonable value
    if (q .le. 1 .or. q .ge. ratioguess) then
      print*, ''
      print*, ''
      stop
    end if
  end subroutine findratio
!  differentiation of redistribute_nodes_by_arc_length in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: rremeshed
!   with respect to varying inputs: r rremeshed startarclength
!   rw status of diff variables: r:out rremeshed:in-out startarclength:out
  subroutine redistribute_nodes_by_arc_length_b(r, rb, startarclength, &
&   startarclengthb, nnodes, rremeshed, rremeshedb)
    implicit none
    integer(kind=inttype), intent(in) :: nnodes
    real(kind=realtype), intent(in) :: r(nnodes*3)
    real(kind=realtype) :: rb(nnodes*3)
    real(kind=realtype), intent(in) :: startarclength(nnodes)
    real(kind=realtype) :: startarclengthb(nnodes)
    real(kind=realtype) :: rremeshed(nnodes*3)
    real(kind=realtype) :: rremeshedb(nnodes*3)
    real(kind=realtype) :: arclength(nnodes)
    real(kind=realtype) :: arclengthb(nnodes)
! compute arclengths of the original curve
    call pushreal8array(arclength, realtype*nnodes/8)
    call compute_arc_length(r, nnodes, arclength)
! interpolate new nodes
! now we sample the new coordinates based on the interpolation method given by the user
! create interpolants for x, y, and z
    arclengthb = 0.0_8
    startarclengthb = 0.0_8
    call interp1d_b(1, nnodes, arclength, arclengthb, r(3:3*nnodes:3), &
&             rb(3:3*nnodes:3), nnodes, startarclength, startarclengthb&
&             , rremeshed(3:3*nnodes:3), rremeshedb(3:3*nnodes:3))
    call interp1d_b(1, nnodes, arclength, arclengthb, r(2:3*nnodes-1:3)&
&             , rb(2:3*nnodes-1:3), nnodes, startarclength, &
&             startarclengthb, rremeshed(2:3*nnodes-1:3), rremeshedb(2:3&
&             *nnodes-1:3))
    call interp1d_b(1, nnodes, arclength, arclengthb, r(1:3*nnodes-2:3)&
&             , rb(1:3*nnodes-2:3), nnodes, startarclength, &
&             startarclengthb, rremeshed(1:3*nnodes-2:3), rremeshedb(1:3&
&             *nnodes-2:3))
    call popreal8array(arclength, realtype*nnodes/8)
    call compute_arc_length_b(r, rb, nnodes, arclength, arclengthb)
  end subroutine redistribute_nodes_by_arc_length_b
!  differentiation of compute_arc_length in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: r arclength
!   with respect to varying inputs: r arclength
!   rw status of diff variables: r:incr arclength:in-out
  subroutine compute_arc_length_b(r, rb, nnodes, arclength, arclengthb)
    implicit none
    integer(kind=inttype), intent(in) :: nnodes
    real(kind=realtype), intent(in) :: r(nnodes*3)
    real(kind=realtype) :: rb(nnodes*3)
    real(kind=realtype) :: arclength(nnodes)
    real(kind=realtype) :: arclengthb(nnodes)
    real(kind=realtype) :: node1(3), node2(3), dist
    real(kind=realtype) :: node1b(3), node2b(3), distb
    integer(kind=inttype) :: nodeid
    real(kind=realtype), dimension(3) :: arg1
    real(kind=realtype), dimension(3) :: arg1b
    real(kind=realtype), dimension(nnodes) :: tmp
    real(kind=realtype) :: tmpb(nnodes)
    real(kind=realtype) :: tempb(nnodes)
! store coordinates of the first node (the other nodes will be covered in the loop)
    node1 = r(1:3)
    arclength(1) = 0.
! loop over each element to increment arclength
    do nodeid=2,nnodes
! get coordinates of the next node
      node2 = r(3*(nodeid-1)+1:3*(nodeid-1)+3)
! compute distance between nodes
      call pushreal8array(arg1, realtype*3/8)
      arg1(:) = node1 - node2
      call norm(arg1(:), dist)
! store nodal arc-length
      arclength(nodeid) = arclength(nodeid-1) + dist
! store coordinates for the next loop
      node1 = node2
    end do
    tmpb = arclengthb
    tempb = tmpb/arclength(nnodes)
    arclengthb = tempb
    arclengthb(nnodes) = arclengthb(nnodes) + sum(-(arclength*tempb/&
&     arclength(nnodes)))
    node1b = 0.0_8
    do nodeid=nnodes,2,-1
      arclengthb(nodeid-1) = arclengthb(nodeid-1) + arclengthb(nodeid)
      distb = arclengthb(nodeid)
      call norm_b0(arg1(:), arg1b(:), dist, distb)
      node2b = 0.0_8
      node2b = node1b - arg1b(:)
      arclengthb(nodeid) = 0.0_8
      node1b = 0.0_8
      call popreal8array(arg1, realtype*3/8)
      node1b = arg1b(:)
      rb(3*(nodeid-1)+1:3*(nodeid-1)+3) = rb(3*(nodeid-1)+1:3*(nodeid-1)&
&       +3) + node2b
    end do
    arclengthb(1) = 0.0_8
    rb(1:3) = rb(1:3) + node1b
  end subroutine compute_arc_length_b
  subroutine redistribute_nodes_by_arc_length(r, startarclength, nnodes&
&   , rremeshed)
    implicit none
    integer(kind=inttype), intent(in) :: nnodes
    real(kind=realtype), intent(in) :: r(nnodes*3)
    real(kind=realtype), intent(in) :: startarclength(nnodes)
    real(kind=realtype), intent(out) :: rremeshed(nnodes*3)
    real(kind=realtype) :: arclength(nnodes)
! compute arclengths of the original curve
    call compute_arc_length(r, nnodes, arclength)
! interpolate new nodes
! now we sample the new coordinates based on the interpolation method given by the user
! create interpolants for x, y, and z
    call interp1d(1, nnodes, arclength, r(1:3*nnodes-2:3), nnodes, &
&           startarclength, rremeshed(1:3*nnodes-2:3))
    call interp1d(1, nnodes, arclength, r(2:3*nnodes-1:3), nnodes, &
&           startarclength, rremeshed(2:3*nnodes-1:3))
    call interp1d(1, nnodes, arclength, r(3:3*nnodes:3), nnodes, &
&           startarclength, rremeshed(3:3*nnodes:3))
  end subroutine redistribute_nodes_by_arc_length
  subroutine compute_arc_length(r, nnodes, arclength)
    implicit none
    integer(kind=inttype), intent(in) :: nnodes
    real(kind=realtype), intent(in) :: r(nnodes*3)
    real(kind=realtype), intent(out) :: arclength(nnodes)
    real(kind=realtype) :: node1(3), node2(3), dist
    integer(kind=inttype) :: nodeid
    real(kind=realtype), dimension(3) :: arg1
! store coordinates of the first node (the other nodes will be covered in the loop)
    node1 = r(1:3)
    arclength(1) = 0.
! loop over each element to increment arclength
    do nodeid=2,nnodes
! get coordinates of the next node
      node2 = r(3*(nodeid-1)+1:3*(nodeid-1)+3)
! compute distance between nodes
      arg1(:) = node1 - node2
      call norm(arg1(:), dist)
! store nodal arc-length
      arclength(nodeid) = arclength(nodeid-1) + dist
! store coordinates for the next loop
      node1 = node2
    end do
! normalize the arc-lengths
    arclength = arclength/arclength(nnodes)
  end subroutine compute_arc_length
!  differentiation of interp1d in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: p_interp p_data t_data t_interp
!   with respect to varying inputs: p_interp p_data t_data t_interp
  subroutine interp1d_b(m, data_num, t_data, t_datab, p_data, p_datab, &
&   interp_num, t_interp, t_interpb, p_interp, p_interpb)
    implicit none
    integer(kind=inttype) :: data_num
    integer(kind=inttype) :: m
    integer(kind=inttype) :: interp_num
    integer(kind=inttype) :: interp
    integer(kind=inttype) :: left
    real(kind=realtype) :: p_data(data_num)
    real(kind=realtype) :: p_datab(data_num)
    real(kind=realtype) :: p_interp(interp_num)
    real(kind=realtype) :: p_interpb(interp_num)
    integer(kind=inttype) :: right
    real(kind=realtype) :: t
    real(kind=realtype) :: tb
    real(kind=realtype) :: t_data(data_num)
    real(kind=realtype) :: t_datab(data_num)
    real(kind=realtype) :: t_interp(interp_num)
    real(kind=realtype) :: t_interpb(interp_num)
    real(kind=realtype) :: tempb0
    real(kind=realtype) :: tempb
    do interp=1,interp_num
      t = t_interp(interp)
!
!  find the interval [ tdata(left), tdata(right) ] that contains, or is
!  nearest to, tval.
!
      call pushinteger4array(right, inttype/4)
      call pushinteger4array(left, inttype/4)
      call r8vec_bracket(data_num, t_data, t, left, right)
    end do
    do interp=interp_num,1,-1
      t = t_interp(interp)
      tempb = p_interpb(interp)/(t_data(right)-t_data(left))
      tempb0 = -(((t_data(right)-t)*p_data(left)+(t-t_data(left))*p_data&
&       (right))*tempb/(t_data(right)-t_data(left)))
      t_datab(right) = t_datab(right) + tempb0 + p_data(left)*tempb
      tb = (p_data(right)-p_data(left))*tempb
      p_datab(left) = p_datab(left) + (t_data(right)-t)*tempb
      t_datab(left) = t_datab(left) - tempb0 - p_data(right)*tempb
      p_datab(right) = p_datab(right) + (t-t_data(left))*tempb
      p_interpb(interp) = 0.0_8
      call popinteger4array(left, inttype/4)
      call popinteger4array(right, inttype/4)
      t_interpb(interp) = t_interpb(interp) + tb
    end do
  end subroutine interp1d_b
  subroutine interp1d(m, data_num, t_data, p_data, interp_num, t_interp&
&   , p_interp)
    implicit none
    integer(kind=inttype) :: data_num
    integer(kind=inttype) :: m
    integer(kind=inttype) :: interp_num
    integer(kind=inttype) :: interp
    integer(kind=inttype) :: left
    real(kind=realtype) :: p_data(data_num)
    real(kind=realtype) :: p_interp(interp_num)
    integer(kind=inttype) :: right
    real(kind=realtype) :: t
    real(kind=realtype) :: t_data(data_num)
    real(kind=realtype) :: t_interp(interp_num)
    do interp=1,interp_num
      t = t_interp(interp)
!
!  find the interval [ tdata(left), tdata(right) ] that contains, or is
!  nearest to, tval.
!
      call r8vec_bracket(data_num, t_data, t, left, right)
      p_interp(interp) = ((t_data(right)-t)*p_data(left)+(t-t_data(left)&
&       )*p_data(right))/(t_data(right)-t_data(left))
    end do
    return
  end subroutine interp1d
  subroutine r8vec_bracket(n, x, xval, left, right)
    implicit none
    integer(kind=inttype) :: n
    integer(kind=inttype) :: i
    integer(kind=inttype) :: left
    integer(kind=inttype) :: right
    real(kind=realtype) :: x(n)
    real(kind=realtype) :: xval
    do i=2,n-1
      if (xval .lt. x(i)) then
        left = i - 1
        right = i
        return
      end if
    end do
    left = n - 1
    right = n
    return
  end subroutine r8vec_bracket
!  differentiation of matinv3 in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: b
!   with respect to varying inputs: a
  subroutine matinv3_b(a, ab, b, bb)
    implicit none
!! performs a direct calculation of the inverse of a 3×3 matrix.
!! matrix
    real(kind=realtype), intent(in) :: a(3, 3)
    real(kind=realtype) :: ab(3, 3)
!! inverse matrix
    real(kind=realtype) :: b(3, 3)
    real(kind=realtype) :: bb(3, 3)
    real(kind=realtype) :: detinv
    real(kind=realtype) :: detinvb
    real(kind=realtype) :: temp3
    real(kind=realtype) :: temp2
    real(kind=realtype) :: temp1
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tempb8
    real(kind=realtype) :: tempb7
    real(kind=realtype) :: tempb6
    real(kind=realtype) :: tempb5
    real(kind=realtype) :: tempb4
    real(kind=realtype) :: tempb3
    real(kind=realtype) :: tempb2
    real(kind=realtype) :: tempb1
    real(kind=realtype) :: tempb0
    real(kind=realtype) :: tempb
    real(kind=realtype) :: temp
    real(kind=realtype) :: temp5
    real(kind=realtype) :: temp4
!f2py intent(in) a
!f2py intent(out) b
! calculate the inverse determinant of the matrix
    detinv = 1/(a(1, 1)*a(2, 2)*a(3, 3)-a(1, 1)*a(2, 3)*a(3, 2)-a(1, 2)*&
&     a(2, 1)*a(3, 3)+a(1, 2)*a(2, 3)*a(3, 1)+a(1, 3)*a(2, 1)*a(3, 2)-a(&
&     1, 3)*a(2, 2)*a(3, 1))
! calculate the inverse of the matrix
    ab = 0.0_8
    tempb = detinv*bb(3, 3)
    detinvb = (a(1, 1)*a(2, 2)-a(1, 2)*a(2, 1))*bb(3, 3)
    ab(1, 1) = ab(1, 1) + a(2, 2)*tempb
    ab(2, 2) = ab(2, 2) + a(1, 1)*tempb
    ab(1, 2) = ab(1, 2) - a(2, 1)*tempb
    ab(2, 1) = ab(2, 1) - a(1, 2)*tempb
    bb(3, 3) = 0.0_8
    tempb0 = -(detinv*bb(2, 3))
    detinvb = detinvb - (a(1, 1)*a(2, 3)-a(1, 3)*a(2, 1))*bb(2, 3)
    ab(1, 1) = ab(1, 1) + a(2, 3)*tempb0
    ab(2, 3) = ab(2, 3) + a(1, 1)*tempb0
    ab(1, 3) = ab(1, 3) - a(2, 1)*tempb0
    ab(2, 1) = ab(2, 1) - a(1, 3)*tempb0
    bb(2, 3) = 0.0_8
    tempb1 = detinv*bb(1, 3)
    detinvb = detinvb + (a(1, 2)*a(2, 3)-a(1, 3)*a(2, 2))*bb(1, 3)
    ab(1, 2) = ab(1, 2) + a(2, 3)*tempb1
    ab(2, 3) = ab(2, 3) + a(1, 2)*tempb1
    ab(1, 3) = ab(1, 3) - a(2, 2)*tempb1
    ab(2, 2) = ab(2, 2) - a(1, 3)*tempb1
    bb(1, 3) = 0.0_8
    tempb2 = -(detinv*bb(3, 2))
    detinvb = detinvb - (a(1, 1)*a(3, 2)-a(1, 2)*a(3, 1))*bb(3, 2)
    ab(1, 1) = ab(1, 1) + a(3, 2)*tempb2
    ab(3, 2) = ab(3, 2) + a(1, 1)*tempb2
    ab(1, 2) = ab(1, 2) - a(3, 1)*tempb2
    ab(3, 1) = ab(3, 1) - a(1, 2)*tempb2
    bb(3, 2) = 0.0_8
    tempb3 = detinv*bb(2, 2)
    detinvb = detinvb + (a(1, 1)*a(3, 3)-a(1, 3)*a(3, 1))*bb(2, 2)
    ab(1, 1) = ab(1, 1) + a(3, 3)*tempb3
    ab(3, 3) = ab(3, 3) + a(1, 1)*tempb3
    ab(1, 3) = ab(1, 3) - a(3, 1)*tempb3
    ab(3, 1) = ab(3, 1) - a(1, 3)*tempb3
    bb(2, 2) = 0.0_8
    tempb4 = -(detinv*bb(1, 2))
    detinvb = detinvb - (a(1, 2)*a(3, 3)-a(1, 3)*a(3, 2))*bb(1, 2)
    ab(1, 2) = ab(1, 2) + a(3, 3)*tempb4
    ab(3, 3) = ab(3, 3) + a(1, 2)*tempb4
    ab(1, 3) = ab(1, 3) - a(3, 2)*tempb4
    ab(3, 2) = ab(3, 2) - a(1, 3)*tempb4
    bb(1, 2) = 0.0_8
    tempb5 = detinv*bb(3, 1)
    detinvb = detinvb + (a(2, 1)*a(3, 2)-a(2, 2)*a(3, 1))*bb(3, 1)
    ab(2, 1) = ab(2, 1) + a(3, 2)*tempb5
    ab(3, 2) = ab(3, 2) + a(2, 1)*tempb5
    ab(2, 2) = ab(2, 2) - a(3, 1)*tempb5
    ab(3, 1) = ab(3, 1) - a(2, 2)*tempb5
    bb(3, 1) = 0.0_8
    tempb6 = -(detinv*bb(2, 1))
    detinvb = detinvb - (a(2, 1)*a(3, 3)-a(2, 3)*a(3, 1))*bb(2, 1)
    ab(2, 1) = ab(2, 1) + a(3, 3)*tempb6
    ab(3, 3) = ab(3, 3) + a(2, 1)*tempb6
    ab(2, 3) = ab(2, 3) - a(3, 1)*tempb6
    ab(3, 1) = ab(3, 1) - a(2, 3)*tempb6
    bb(2, 1) = 0.0_8
    tempb7 = detinv*bb(1, 1)
    detinvb = detinvb + (a(2, 2)*a(3, 3)-a(2, 3)*a(3, 2))*bb(1, 1)
    ab(2, 2) = ab(2, 2) + a(3, 3)*tempb7
    ab(3, 3) = ab(3, 3) + a(2, 2)*tempb7
    ab(2, 3) = ab(2, 3) - a(3, 2)*tempb7
    ab(3, 2) = ab(3, 2) - a(2, 3)*tempb7
    temp5 = a(1, 3)*a(2, 2)
    temp4 = a(1, 3)*a(2, 1)
    temp3 = a(1, 2)*a(2, 3)
    temp2 = a(1, 2)*a(2, 1)
    temp1 = a(1, 1)*a(2, 3)
    temp0 = a(1, 1)*a(2, 2)
    temp = temp0*a(3, 3) - temp1*a(3, 2) - temp2*a(3, 3) + temp3*a(3, 1)&
&     + temp4*a(3, 2) - temp5*a(3, 1)
    tempb8 = -(detinvb/temp**2)
    ab(1, 1) = ab(1, 1) + (a(3, 3)*a(2, 2)-a(3, 2)*a(2, 3))*tempb8
    ab(2, 2) = ab(2, 2) + (a(3, 3)*a(1, 1)-a(3, 1)*a(1, 3))*tempb8
    ab(3, 3) = ab(3, 3) + (temp0-temp2)*tempb8
    ab(2, 3) = ab(2, 3) + (a(3, 1)*a(1, 2)-a(3, 2)*a(1, 1))*tempb8
    ab(3, 2) = ab(3, 2) + (temp4-temp1)*tempb8
    ab(1, 2) = ab(1, 2) + (a(3, 1)*a(2, 3)-a(3, 3)*a(2, 1))*tempb8
    ab(2, 1) = ab(2, 1) + (a(3, 2)*a(1, 3)-a(3, 3)*a(1, 2))*tempb8
    ab(3, 1) = ab(3, 1) + (temp3-temp5)*tempb8
    ab(1, 3) = ab(1, 3) + (a(3, 2)*a(2, 1)-a(3, 1)*a(2, 2))*tempb8
  end subroutine matinv3_b
  subroutine matinv3(a, b)
    implicit none
!! performs a direct calculation of the inverse of a 3×3 matrix.
!! matrix
    real(kind=realtype), intent(in) :: a(3, 3)
!! inverse matrix
    real(kind=realtype), intent(out) :: b(3, 3)
    real(kind=realtype) :: detinv
!f2py intent(in) a
!f2py intent(out) b
! calculate the inverse determinant of the matrix
    detinv = 1/(a(1, 1)*a(2, 2)*a(3, 3)-a(1, 1)*a(2, 3)*a(3, 2)-a(1, 2)*&
&     a(2, 1)*a(3, 3)+a(1, 2)*a(2, 3)*a(3, 1)+a(1, 3)*a(2, 1)*a(3, 2)-a(&
&     1, 3)*a(2, 2)*a(3, 1))
! calculate the inverse of the matrix
    b(1, 1) = detinv*(a(2, 2)*a(3, 3)-a(2, 3)*a(3, 2))
    b(2, 1) = -(detinv*(a(2, 1)*a(3, 3)-a(2, 3)*a(3, 1)))
    b(3, 1) = detinv*(a(2, 1)*a(3, 2)-a(2, 2)*a(3, 1))
    b(1, 2) = -(detinv*(a(1, 2)*a(3, 3)-a(1, 3)*a(3, 2)))
    b(2, 2) = detinv*(a(1, 1)*a(3, 3)-a(1, 3)*a(3, 1))
    b(3, 2) = -(detinv*(a(1, 1)*a(3, 2)-a(1, 2)*a(3, 1)))
    b(1, 3) = detinv*(a(1, 2)*a(2, 3)-a(1, 3)*a(2, 2))
    b(2, 3) = -(detinv*(a(1, 1)*a(2, 3)-a(1, 3)*a(2, 1)))
    b(3, 3) = detinv*(a(1, 1)*a(2, 2)-a(1, 2)*a(2, 1))
  end subroutine matinv3
!  differentiation of giveangle in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: angle r0 r1 r2
!   with respect to varying inputs: r0 r1 r2
  subroutine giveangle_b(r0, r0b, r1, r1b, r2, r2b, n1, angle, angleb)
    implicit none
    real(kind=realtype), dimension(3), intent(in) :: r0, r1, r2, n1
    real(kind=realtype), dimension(3) :: r0b, r1b, r2b
!f2py intent(in) r0, r1, r2, n1
!f2py intent(out) angle
    real(kind=realtype), dimension(3) :: dr1, dr2, dr1crossdr2
    real(kind=realtype), dimension(3) :: dr1b, dr2b
    real(kind=realtype) :: dr1dotdr2, arccos_inside, pi, one, angle, tmp
    real(kind=realtype) :: dr1dotdr2b, arccos_insideb, angleb
    real(kind=realtype) :: normdr1, normdr2, dr1crossdr2dotn1
    real(kind=realtype) :: normdr1b, normdr2b
    intrinsic min
    intrinsic dacos
    integer :: branch
    real(kind=realtype) :: min1
    real(kind=realtype) :: tempb0
    real(kind=realtype) :: min1b
    real(kind=realtype) :: tempb
    one = 1.0
    dr1 = r1 - r0
    dr2 = r2 - r1
    call dot(dr1, dr2, dr1dotdr2)
! dot product
    call cross(dr1, dr2, dr1crossdr2)
! cross product
! compute acute angle and ensure it's <= 1.0
    call norm(dr1, normdr1)
    call norm(dr2, normdr2)
    arccos_inside = dr1dotdr2/normdr1/normdr2
    if (arccos_inside .gt. one) then
      min1 = one
      call pushcontrol1b(0)
    else
      min1 = arccos_inside
      call pushcontrol1b(1)
    end if
! if the cross product points in the same direction of the surface
! normal, we have an acute corner
    call dot(dr1crossdr2, n1, dr1crossdr2dotn1)
    if (dr1crossdr2dotn1 .le. 0.) angleb = -angleb
    if (min1 .eq. 1.0 .or. min1 .eq. (-1.0)) then
      min1b = 0.0
    else
      min1b = -(angleb/sqrt(1.d0-min1**2))
    end if
    call popcontrol1b(branch)
    if (branch .eq. 0) then
      arccos_insideb = 0.0_8
    else
      arccos_insideb = min1b
    end if
    tempb = arccos_insideb/(normdr1*normdr2)
    tempb0 = -(dr1dotdr2*tempb/(normdr1*normdr2))
    dr1dotdr2b = tempb
    normdr1b = normdr2*tempb0
    normdr2b = normdr1*tempb0
    call norm_b0(dr2, dr2b, normdr2, normdr2b)
    call norm_b0(dr1, dr1b, normdr1, normdr1b)
    call dot_b0(dr1, dr1b, dr2, dr2b, dr1dotdr2, dr1dotdr2b)
    r2b = r2b + dr2b
    r1b = r1b + dr1b - dr2b
    r0b = r0b - dr1b
  end subroutine giveangle_b
  subroutine giveangle(r0, r1, r2, n1, angle)
    implicit none
    real(kind=realtype), dimension(3), intent(in) :: r0, r1, r2, n1
!f2py intent(in) r0, r1, r2, n1
!f2py intent(out) angle
    real(kind=realtype), dimension(3) :: dr1, dr2, dr1crossdr2
    real(kind=realtype) :: dr1dotdr2, arccos_inside, pi, one, angle, tmp
    real(kind=realtype) :: normdr1, normdr2, dr1crossdr2dotn1
    intrinsic min
    intrinsic dacos
    real(kind=realtype) :: min1
    pi = 3.14159265358979323846264338
    one = 1.0
    dr1 = r1 - r0
    dr2 = r2 - r1
    call dot(dr1, dr2, dr1dotdr2)
! dot product
    call cross(dr1, dr2, dr1crossdr2)
! cross product
! compute acute angle and ensure it's <= 1.0
    call norm(dr1, normdr1)
    call norm(dr2, normdr2)
    arccos_inside = dr1dotdr2/normdr1/normdr2
    if (arccos_inside .gt. one) then
      min1 = one
    else
      min1 = arccos_inside
    end if
    angle = dacos(min1)
! if the cross product points in the same direction of the surface
! normal, we have an acute corner
    call dot(dr1crossdr2, n1, dr1crossdr2dotn1)
    if (dr1crossdr2dotn1 .gt. 0.) then
      angle = pi + angle
    else
      angle = pi - angle
    end if
  end subroutine giveangle
!  differentiation of dot in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: dot_ a b
!   with respect to varying inputs: a b
!============================================================
  subroutine dot_b0(a, ab, b, bb, dot_, dot_b)
    implicit none
    real(kind=realtype), intent(in) :: a(3), b(3)
    real(kind=realtype) :: ab(3), bb(3)
    real(kind=realtype) :: dot_
    real(kind=realtype) :: dot_b
    ab(1) = ab(1) + b(1)*dot_b
    bb(1) = bb(1) + a(1)*dot_b
    ab(2) = ab(2) + b(2)*dot_b
    bb(2) = bb(2) + a(2)*dot_b
    ab(3) = ab(3) + b(3)*dot_b
    bb(3) = bb(3) + a(3)*dot_b
  end subroutine dot_b0
!============================================================
  subroutine dot(a, b, dot_)
    implicit none
    real(kind=realtype), intent(in) :: a(3), b(3)
    real(kind=realtype), intent(out) :: dot_
    dot_ = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
  end subroutine dot
!  differentiation of norm in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: norm_
!   with respect to varying inputs: a
!============================================================
  subroutine norm_b0(a, ab, norm_, norm_b)
    implicit none
    real(kind=realtype), intent(in) :: a(3)
    real(kind=realtype) :: ab(3)
    real(kind=realtype) :: norm_
    real(kind=realtype) :: norm_b
    intrinsic dsqrt
    real(kind=realtype) :: tempb
    ab = 0.0_8
    if (a(1)**2 + a(2)**2 + a(3)**2 .eq. 0.0_8) then
      tempb = 0.0
    else
      tempb = norm_b/(2.d0*dsqrt(a(1)**2+a(2)**2+a(3)**2))
    end if
    ab(1) = ab(1) + 2*a(1)*tempb
    ab(2) = ab(2) + 2*a(2)*tempb
    ab(3) = ab(3) + 2*a(3)*tempb
  end subroutine norm_b0
!============================================================
  subroutine norm(a, norm_)
    implicit none
    real(kind=realtype), intent(in) :: a(3)
    real(kind=realtype), intent(out) :: norm_
    intrinsic dsqrt
    norm_ = dsqrt(a(1)*a(1) + a(2)*a(2) + a(3)*a(3))
  end subroutine norm
!  differentiation of cross in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: a b c
!   with respect to varying inputs: a b c
  subroutine cross_b(a, ab, b, bb, c, cb)
    implicit none
    real(kind=realtype), intent(in) :: a(3), b(3)
    real(kind=realtype) :: ab(3), bb(3)
    real(kind=realtype) :: c(3)
    real(kind=realtype) :: cb(3)
    ab(1) = ab(1) + b(2)*cb(3)
    bb(2) = bb(2) + a(1)*cb(3)
    ab(2) = ab(2) - b(1)*cb(3)
    bb(1) = bb(1) - a(2)*cb(3)
    cb(3) = 0.0_8
    ab(3) = ab(3) + b(1)*cb(2)
    bb(1) = bb(1) + a(3)*cb(2)
    ab(1) = ab(1) - b(3)*cb(2)
    bb(3) = bb(3) - a(1)*cb(2)
    cb(2) = 0.0_8
    ab(2) = ab(2) + b(3)*cb(1)
    bb(3) = bb(3) + a(2)*cb(1)
    ab(3) = ab(3) - b(2)*cb(1)
    bb(2) = bb(2) - a(3)*cb(1)
    cb(1) = 0.0_8
  end subroutine cross_b
  subroutine cross(a, b, c)
    implicit none
    real(kind=realtype), intent(in) :: a(3), b(3)
    real(kind=realtype), intent(out) :: c(3)
    c(1) = a(2)*b(3) - a(3)*b(2)
    c(2) = a(3)*b(1) - a(1)*b(3)
    c(3) = a(1)*b(2) - a(2)*b(1)
  end subroutine cross
  subroutine m33det(a, det)
    implicit none
    real(kind=realtype), dimension(3, 3), intent(in) :: a
    real(kind=realtype), intent(out) :: det
    det = a(1, 1)*a(2, 2)*a(3, 3) - a(1, 1)*a(2, 3)*a(3, 2) - a(1, 2)*a(&
&     2, 1)*a(3, 3) + a(1, 2)*a(2, 3)*a(3, 1) + a(1, 3)*a(2, 1)*a(3, 2) &
&     - a(1, 3)*a(2, 2)*a(3, 1)
  end subroutine m33det
end module hypsurfmain_b
