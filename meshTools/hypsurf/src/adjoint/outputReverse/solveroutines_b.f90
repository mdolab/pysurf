!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module solveroutines_b
  use precision
  implicit none

contains
!  differentiation of solve in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: y
!   with respect to varying inputs: a b
  subroutine solve_b(a, ab, y, yb, b, bb, n, ipiv)
    use precision
    implicit none
    integer, intent(in) :: n
    real(kind=realtype), intent(inout) :: a(n, n), y(n), b(n)
    real(kind=realtype) :: ab(n, n), yb(n), bb(n)
    integer, intent(inout) :: ipiv(n)
    integer(kind=inttype) :: ii, jj
    ab = 0.0_8
    bb = 0.0_8
    do ii=n,1,-1
      do jj=n,1,-1
        ab(ii, jj) = ab(ii, jj) + b(ii)*yb(ii)
        bb(ii) = bb(ii) + a(ii, jj)*yb(ii)
        yb(ii) = 0.0_8
      end do
    end do
  end subroutine solve_b
  subroutine solve(a, y, b, n, ipiv)
    use precision
    implicit none
    integer, intent(in) :: n
    real(kind=realtype), intent(inout) :: a(n, n), y(n), b(n)
    integer, intent(inout) :: ipiv(n)
    integer(kind=inttype) :: ii, jj
! this code literally does not matter! as long as 'y' depends on 'a'
! and 'b' it is fine.
    do ii=1,n
      do jj=1,n
        y(ii) = a(ii, jj)*b(ii)
      end do
    end do
  end subroutine solve
end module solveroutines_b
