!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
!
!
!     ******************************************************************
!     *                                                                *
!     * File:          hypsurfMain.F90                                 *
!     * Authors:       John Jasa and Ney Secco                         *
!     * Starting date: 08-11-2016                                      *
!     * Last modified: 09-25-2016                                      *
!     *                                                                *
!     ******************************************************************
!
!
!     ******************************************************************
!     *                                                                *
!     * Contains subroutines for hyperbolic surface mesh generation.   *
!     *                                                                *
!     ******************************************************************
!
MODULE HYPSURFMAIN_B
  USE PRECISION
  IMPLICIT NONE

CONTAINS
!  Differentiation of computematrices_main in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: f
!   with respect to varying inputs: f s0 sm1 n0 rm1 r0
!   RW status of diff variables: f:in-zero s0:out sm1:out n0:out
!                rm1:out r0:out
!=================================================================
!=================================================================
  SUBROUTINE COMPUTEMATRICES_MAIN_B(r0, r0b, n0, n0b, s0, s0b, rm1, rm1b&
&   , sm1, sm1b, layerindex, theta, sigmasplay, bc1, bc2, numlayers, &
&   epse0, f, fb, numnodes)
    USE SOLVEROUTINES, ONLY : solve
    IMPLICIT NONE
    INTEGER(kind=inttype), INTENT(IN) :: layerindex, numnodes, numlayers
    REAL(kind=realtype), INTENT(IN) :: r0(3*numnodes), n0(3, numnodes), &
&   s0(numnodes)
    REAL(kind=realtype) :: r0b(3*numnodes), n0b(3, numnodes), s0b(&
&   numnodes)
    REAL(kind=realtype), INTENT(IN) :: rm1(3*numnodes), sm1(numnodes), &
&   theta
    REAL(kind=realtype) :: rm1b(3*numnodes), sm1b(numnodes)
    REAL(kind=realtype), INTENT(IN) :: sigmasplay, epse0
    CHARACTER(len=32), INTENT(IN) :: bc1, bc2
    REAL(kind=realtype) :: f(3*numnodes)
    REAL(kind=realtype) :: fb(3*numnodes)
    REAL(kind=realtype) :: r_curr(3), r_next(3), r_prev(3), d_vec(3), &
&   d_vec_rot(3), eye(3, 3)
    REAL(kind=realtype) :: r_currb(3), r_nextb(3), r_prevb(3), d_vecb(3)&
&   , d_vec_rotb(3)
    REAL(kind=realtype) :: k(3*numnodes, 3*numnodes)
    REAL(kind=realtype) :: kb(3*numnodes, 3*numnodes)
    INTEGER(kind=inttype) :: index, i
    INTEGER(kind=inttype) :: ipiv(3*numnodes)
    INTEGER(kind=inttype) :: n, nrhs, ldk, ldf, info
    REAL(kind=realtype) :: one, zero, rhs(3*numnodes)
    REAL(kind=realtype) :: rhsb(3*numnodes)
    EXTERNAL SOLVE
    EXTERNAL SOLVE_B
    INTEGER :: branch
    one = 1.
    zero = 0.
! Initialize arrays
    k(:, :) = zero
    f(:) = zero
    eye(:, :) = zero
    DO i=1,3
      eye(i, i) = one
    END DO
! Now loop over each node
    index = 1
    IF (bc1 .EQ. 'splay') THEN
! Get coordinates
      r_curr = r0(:3)
      r_next = r0(4:6)
! Get vector that connects r_next to r_curr
      d_vec = r_next - r_curr
! Get marching direction vector (orthogonal to the curve and to the surface normal)
      CALL CROSS(n0(:, 1), d_vec, d_vec_rot)
! Populate matrix
      k(1, :3) = d_vec_rot
      k(2, :3) = n0(:, index)
      k(3, :3) = d_vec
      f(:3) = zero
      f(1) = s0(1)*(1-sigmasplay)
      CALL PUSHCONTROL3B(5)
    ELSE IF (bc1 .EQ. 'constx') THEN
      CALL PUSHCONTROL3B(4)
! Populate matrix
      k(2, 4) = zero
      k(2, 5) = -one
      k(2, 6) = zero
      k(3, 4) = zero
      k(3, 5) = zero
      k(3, 6) = -one
      DO i=1,3
        k(i, i) = one
      END DO
    ELSE IF (bc1 .EQ. 'consty') THEN
      CALL PUSHCONTROL3B(3)
! Populate matrix
      k(1, 4) = -one
      k(1, 5) = zero
      k(1, 6) = zero
      k(3, 4) = zero
      k(3, 5) = zero
      k(3, 6) = -one
      DO i=1,3
        k(i, i) = one
      END DO
    ELSE IF (bc1 .EQ. 'constz') THEN
      CALL PUSHCONTROL3B(2)
! Populate matrix
      k(1, 4) = -one
      k(1, 5) = zero
      k(1, 6) = zero
      k(2, 4) = zero
      k(2, 5) = -one
      k(2, 6) = zero
      DO i=1,3
        k(i, i) = one
      END DO
    ELSE IF (bc1(:5) .EQ. 'curve') THEN
! Populate matrix
      DO i=1,3
        k(i, i) = one
      END DO
      f(:3) = s0(1)*n0(:, 1)
      CALL PUSHCONTROL3B(1)
    ELSE
! Call assembly routine
      CALL MATRIXBUILDER(index, bc1, bc2, r0, rm1, n0, s0, sm1, &
&                  numlayers, epse0, layerindex, theta, numnodes, k, f)
      CALL PUSHCONTROL3B(0)
    END IF
    CALL PUSHINTEGER4ARRAY(index, inttype/4)
    DO index=2,numnodes-1
! Call assembly routine
      CALL MATRIXBUILDER(index, bc1, bc2, r0, rm1, n0, s0, sm1, &
&                  numlayers, epse0, layerindex, theta, numnodes, k, f)
    END DO
    index = numnodes
    IF (bc2 .EQ. 'continuous') THEN
! Populate matrix (use same displacements of first node)
      k(3*(index-1)+1:, 3*(index-1)+1:) = eye
      k(3*(index-1)+1:, :3) = -eye
      CALL PUSHCONTROL3B(0)
    ELSE IF (bc2 .EQ. 'splay') THEN
! Get coordinates
      r_curr = r0(3*(index-1)+1:)
      r_prev = r0(3*(index-2)+1:3*(index-2)+3)
! Get vector that connects r_next to r_curr
      d_vec = r_curr - r_prev
! Get marching direction vector (orthogonal to the curve and to the surface normal)
      CALL CROSS(n0(:, index), d_vec, d_vec_rot)
! Populate matrix
      k(3*index-2, 3*index-2:) = d_vec_rot
      k(3*index-1, 3*index-2:) = n0(:, index)
      k(3*index-0, 3*index-2:) = d_vec
      f(3*(index-1)+1:3*index) = zero
      f(3*(index-1)+1) = s0(index)*(1-sigmasplay)
      CALL PUSHCONTROL3B(1)
    ELSE IF (bc2 .EQ. 'constx') THEN
! Populate matrix
      k(3*index-0, 3*(index-2)+1) = zero
      k(3*index-0, 3*(index-2)+2) = zero
      k(3*index-0, 3*(index-2)+3) = -one
      k(3*index-1, 3*(index-2)+1) = zero
      k(3*index-1, 3*(index-2)+2) = -one
      k(3*index-1, 3*(index-2)+3) = zero
      DO i=3*index-2,3*index
        k(i, i) = one
      END DO
      CALL PUSHCONTROL3B(2)
    ELSE IF (bc2 .EQ. 'consty') THEN
! Populate matrix
      k(3*index-2, 3*(index-2)+1) = -one
      k(3*index-2, 3*(index-2)+2) = zero
      k(3*index-2, 3*(index-2)+3) = zero
      k(3*index-0, 3*(index-2)+1) = zero
      k(3*index-0, 3*(index-2)+2) = zero
      k(3*index-0, 3*(index-2)+3) = -one
      DO i=3*index-2,3*index
        k(i, i) = one
      END DO
      CALL PUSHCONTROL3B(3)
    ELSE IF (bc2 .EQ. 'constz') THEN
! Populate matrix
      k(3*index-2, 3*(index-2)+1) = -one
      k(3*index-2, 3*(index-2)+2) = zero
      k(3*index-2, 3*(index-2)+3) = zero
      k(3*index-1, 3*(index-2)+1) = zero
      k(3*index-1, 3*(index-2)+2) = -one
      k(3*index-1, 3*(index-2)+3) = zero
      DO i=3*index-2,3*index
        k(i, i) = one
      END DO
      CALL PUSHCONTROL3B(4)
    ELSE IF (bc2(:5) .EQ. 'curve') THEN
! Populate matrix
      DO i=3*index-2,3*index
        k(i, i) = one
      END DO
      f(3*index-2:) = s0(index)*n0(:, index)
      CALL PUSHCONTROL3B(5)
    ELSE
! Call assembly routine
      CALL MATRIXBUILDER(index, bc1, bc2, r0, rm1, n0, s0, sm1, &
&                  numlayers, epse0, layerindex, theta, index, k, f)
      CALL PUSHCONTROL3B(6)
    END IF
! Set other parameters
! Problem size
    n = 3*numnodes
! number of right hand sides in f
! leading dimension of K (should be = n unless we work with submatrices)
! leading dimension of f (should be = n unless we work with submatrices)
! call dgesv(n, nrhs, K, ldK, ipiv, f, ldf, info)
    rhs = f
! Note that this f is rNext when outputted from computeMatrices_main
    r0b = 0.0_8
    r0b = fb
    kb = 0.0_8
    rhsb = 0.0_8
    CALL SOLVE_B(k, kb, f, fb, rhs, rhsb, n, ipiv)
    fb = fb + rhsb
    CALL POPCONTROL3B(branch)
    IF (branch .LT. 3) THEN
      IF (branch .EQ. 0) THEN
        kb(3*(index-1)+1:3*numnodes, 1:3) = 0.0_8
        kb(3*(index-1)+1:3*numnodes, 3*(index-1)+1:3*numnodes) = 0.0_8
        s0b = 0.0_8
        sm1b = 0.0_8
        n0b = 0.0_8
        rm1b = 0.0_8
        d_vec_rotb = 0.0_8
        GOTO 100
      ELSE IF (branch .EQ. 1) THEN
        s0b = 0.0_8
        s0b(index) = s0b(index) + (1-sigmasplay)*fb(3*(index-1)+1)
        fb(3*(index-1)+1) = 0.0_8
        fb(3*(index-1)+1:3*index) = 0.0_8
        d_vecb = 0.0_8
        d_vecb = kb(3*index-0, 3*index-2:)
        kb(3*index-0, 3*index-2:3*numnodes) = 0.0_8
        n0b = 0.0_8
        n0b(:, index) = n0b(:, index) + kb(3*index-1, 3*index-2:3*&
&         numnodes)
        kb(3*index-1, 3*index-2:3*numnodes) = 0.0_8
        d_vec_rotb = 0.0_8
        d_vec_rotb = kb(3*index-2, 3*index-2:)
        kb(3*index-2, 3*index-2:3*numnodes) = 0.0_8
        CALL CROSS_B(n0(:, index), n0b(:, index), d_vec, d_vecb, &
&              d_vec_rot, d_vec_rotb)
        r_currb = 0.0_8
        r_prevb = 0.0_8
        r_currb = d_vecb
        r_prevb = -d_vecb
        r0b(3*(index-2)+1:3*(index-2)+3) = r0b(3*(index-2)+1:3*(index-2)&
&         +3) + r_prevb
        r0b(3*(index-1)+1:3*numnodes) = r0b(3*(index-1)+1:3*numnodes) + &
&         r_currb
        sm1b = 0.0_8
        rm1b = 0.0_8
        GOTO 100
      ELSE
        DO i=3*index,3*index-2,-1
          kb(i, i) = 0.0_8
        END DO
        kb(3*index-1, 3*(index-2)+3) = 0.0_8
        kb(3*index-1, 3*(index-2)+2) = 0.0_8
        kb(3*index-1, 3*(index-2)+1) = 0.0_8
        kb(3*index-0, 3*(index-2)+3) = 0.0_8
        kb(3*index-0, 3*(index-2)+2) = 0.0_8
        kb(3*index-0, 3*(index-2)+1) = 0.0_8
        s0b = 0.0_8
        sm1b = 0.0_8
        n0b = 0.0_8
        rm1b = 0.0_8
      END IF
    ELSE IF (branch .LT. 5) THEN
      IF (branch .EQ. 3) THEN
        DO i=3*index,3*index-2,-1
          kb(i, i) = 0.0_8
        END DO
        kb(3*index-0, 3*(index-2)+3) = 0.0_8
        kb(3*index-0, 3*(index-2)+2) = 0.0_8
        kb(3*index-0, 3*(index-2)+1) = 0.0_8
        kb(3*index-2, 3*(index-2)+3) = 0.0_8
        kb(3*index-2, 3*(index-2)+2) = 0.0_8
        kb(3*index-2, 3*(index-2)+1) = 0.0_8
        s0b = 0.0_8
        sm1b = 0.0_8
        n0b = 0.0_8
        rm1b = 0.0_8
      ELSE
        DO i=3*index,3*index-2,-1
          kb(i, i) = 0.0_8
        END DO
        kb(3*index-1, 3*(index-2)+3) = 0.0_8
        kb(3*index-1, 3*(index-2)+2) = 0.0_8
        kb(3*index-1, 3*(index-2)+1) = 0.0_8
        kb(3*index-2, 3*(index-2)+3) = 0.0_8
        kb(3*index-2, 3*(index-2)+2) = 0.0_8
        kb(3*index-2, 3*(index-2)+1) = 0.0_8
        s0b = 0.0_8
        sm1b = 0.0_8
        n0b = 0.0_8
        rm1b = 0.0_8
      END IF
    ELSE IF (branch .EQ. 5) THEN
      s0b = 0.0_8
      n0b = 0.0_8
      s0b(index) = s0b(index) + SUM(n0(:, index)*fb(3*index-2:))
      n0b(:, index) = n0b(:, index) + s0(index)*fb(3*index-2:3*numnodes)
      fb(3*index-2:3*numnodes) = 0.0_8
      DO i=3*index,3*index-2,-1
        kb(i, i) = 0.0_8
      END DO
      sm1b = 0.0_8
      rm1b = 0.0_8
    ELSE
      rm1b = 0.0_8
      n0b = 0.0_8
      s0b = 0.0_8
      sm1b = 0.0_8
      CALL MATRIXBUILDER_B(index, bc1, bc2, r0, r0b, rm1, rm1b, n0, n0b&
&                    , s0, s0b, sm1, sm1b, numlayers, epse0, layerindex&
&                    , theta, index, k, kb, f, fb)
    END IF
    d_vec_rotb = 0.0_8
 100 DO index=numnodes-1,2,-1
      CALL MATRIXBUILDER_B(index, bc1, bc2, r0, r0b, rm1, rm1b, n0, n0b&
&                    , s0, s0b, sm1, sm1b, numlayers, epse0, layerindex&
&                    , theta, numnodes, k, kb, f, fb)
    END DO
    CALL POPINTEGER4ARRAY(index, inttype/4)
    CALL POPCONTROL3B(branch)
    IF (branch .LT. 3) THEN
      IF (branch .EQ. 0) THEN
        index = 1
        CALL MATRIXBUILDER_B(index, bc1, bc2, r0, r0b, rm1, rm1b, n0, &
&                      n0b, s0, s0b, sm1, sm1b, numlayers, epse0, &
&                      layerindex, theta, numnodes, k, kb, f, fb)
      ELSE IF (branch .EQ. 1) THEN
        s0b(1) = s0b(1) + SUM(n0(:, 1)*fb(:3))
        n0b(:, 1) = n0b(:, 1) + s0(1)*fb(1:3)
      END IF
    ELSE IF (branch .NE. 3) THEN
      IF (branch .NE. 4) THEN
        s0b(1) = s0b(1) + (1-sigmasplay)*fb(1)
        r_curr = r0(:3)
        d_vec = r_next - r_curr
        d_vecb = 0.0_8
        d_vecb = kb(3, :3)
        kb(3, 1:3) = 0.0_8
        index = 1
        n0b(:, index) = n0b(:, index) + kb(2, 1:3)
        kb(2, 1:3) = 0.0_8
        d_vec_rotb = d_vec_rotb + kb(1, 1:3)
        CALL CROSS_B(n0(:, 1), n0b(:, 1), d_vec, d_vecb, d_vec_rot, &
&              d_vec_rotb)
        r_currb = 0.0_8
        r_nextb = 0.0_8
        r_nextb = d_vecb
        r_currb = -d_vecb
        r0b(4:6) = r0b(4:6) + r_nextb
        r0b(1:3) = r0b(1:3) + r_currb
      END IF
    END IF
    fb = 0.0_8
  END SUBROUTINE COMPUTEMATRICES_MAIN_B
!=================================================================
!=================================================================
  SUBROUTINE COMPUTEMATRICES_MAIN(r0, n0, s0, rm1, sm1, layerindex, &
&   theta, sigmasplay, bc1, bc2, numlayers, epse0, f, numnodes)
    USE SOLVEROUTINES_B, ONLY : solve
    IMPLICIT NONE
    INTEGER(kind=inttype), INTENT(IN) :: layerindex, numnodes, numlayers
    REAL(kind=realtype), INTENT(IN) :: r0(3*numnodes), n0(3, numnodes), &
&   s0(numnodes)
    REAL(kind=realtype), INTENT(IN) :: rm1(3*numnodes), sm1(numnodes), &
&   theta
    REAL(kind=realtype), INTENT(IN) :: sigmasplay, epse0
    CHARACTER(len=32), INTENT(IN) :: bc1, bc2
    REAL(kind=realtype), INTENT(OUT) :: f(3*numnodes)
    REAL(kind=realtype) :: r_curr(3), r_next(3), r_prev(3), d_vec(3), &
&   d_vec_rot(3), eye(3, 3)
    REAL(kind=realtype) :: k(3*numnodes, 3*numnodes)
    INTEGER(kind=inttype) :: index, i
    INTEGER(kind=inttype) :: ipiv(3*numnodes)
    INTEGER(kind=inttype) :: n, nrhs, ldk, ldf, info
    REAL(kind=realtype) :: one, zero, rhs(3*numnodes)
    EXTERNAL SOLVE
    one = 1.
    zero = 0.
! Initialize arrays
    k(:, :) = zero
    f(:) = zero
    eye(:, :) = zero
    DO i=1,3
      eye(i, i) = one
    END DO
! Now loop over each node
    index = 1
    IF (bc1 .EQ. 'splay') THEN
! Get coordinates
      r_curr = r0(:3)
      r_next = r0(4:6)
! Get vector that connects r_next to r_curr
      d_vec = r_next - r_curr
! Get marching direction vector (orthogonal to the curve and to the surface normal)
      CALL CROSS(n0(:, 1), d_vec, d_vec_rot)
! Populate matrix
      k(1, :3) = d_vec_rot
      k(2, :3) = n0(:, index)
      k(3, :3) = d_vec
      f(:3) = zero
      f(1) = s0(1)*(1-sigmasplay)
    ELSE IF (bc1 .EQ. 'constx') THEN
! Populate matrix
      k(2, 4) = zero
      k(2, 5) = -one
      k(2, 6) = zero
      k(3, 4) = zero
      k(3, 5) = zero
      k(3, 6) = -one
      DO i=1,3
        k(i, i) = one
      END DO
    ELSE IF (bc1 .EQ. 'consty') THEN
! Populate matrix
      k(1, 4) = -one
      k(1, 5) = zero
      k(1, 6) = zero
      k(3, 4) = zero
      k(3, 5) = zero
      k(3, 6) = -one
      DO i=1,3
        k(i, i) = one
      END DO
    ELSE IF (bc1 .EQ. 'constz') THEN
! Populate matrix
      k(1, 4) = -one
      k(1, 5) = zero
      k(1, 6) = zero
      k(2, 4) = zero
      k(2, 5) = -one
      k(2, 6) = zero
      DO i=1,3
        k(i, i) = one
      END DO
    ELSE IF (bc1(:5) .EQ. 'curve') THEN
! Populate matrix
      DO i=1,3
        k(i, i) = one
      END DO
      f(:3) = s0(1)*n0(:, 1)
    ELSE
! Call assembly routine
      CALL MATRIXBUILDER(index, bc1, bc2, r0, rm1, n0, s0, sm1, &
&                  numlayers, epse0, layerindex, theta, numnodes, k, f)
    END IF
    DO index=2,numnodes-1
! Call assembly routine
      CALL MATRIXBUILDER(index, bc1, bc2, r0, rm1, n0, s0, sm1, &
&                  numlayers, epse0, layerindex, theta, numnodes, k, f)
    END DO
    index = numnodes
    IF (bc2 .EQ. 'continuous') THEN
! Populate matrix (use same displacements of first node)
      k(3*(index-1)+1:, 3*(index-1)+1:) = eye
      k(3*(index-1)+1:, :3) = -eye
    ELSE IF (bc2 .EQ. 'splay') THEN
! Get coordinates
      r_curr = r0(3*(index-1)+1:)
      r_prev = r0(3*(index-2)+1:3*(index-2)+3)
! Get vector that connects r_next to r_curr
      d_vec = r_curr - r_prev
! Get marching direction vector (orthogonal to the curve and to the surface normal)
      CALL CROSS(n0(:, index), d_vec, d_vec_rot)
! Populate matrix
      k(3*index-2, 3*index-2:) = d_vec_rot
      k(3*index-1, 3*index-2:) = n0(:, index)
      k(3*index-0, 3*index-2:) = d_vec
      f(3*(index-1)+1:3*index) = zero
      f(3*(index-1)+1) = s0(index)*(1-sigmasplay)
    ELSE IF (bc2 .EQ. 'constx') THEN
! Populate matrix
      k(3*index-0, 3*(index-2)+1) = zero
      k(3*index-0, 3*(index-2)+2) = zero
      k(3*index-0, 3*(index-2)+3) = -one
      k(3*index-1, 3*(index-2)+1) = zero
      k(3*index-1, 3*(index-2)+2) = -one
      k(3*index-1, 3*(index-2)+3) = zero
      DO i=3*index-2,3*index
        k(i, i) = one
      END DO
    ELSE IF (bc2 .EQ. 'consty') THEN
! Populate matrix
      k(3*index-2, 3*(index-2)+1) = -one
      k(3*index-2, 3*(index-2)+2) = zero
      k(3*index-2, 3*(index-2)+3) = zero
      k(3*index-0, 3*(index-2)+1) = zero
      k(3*index-0, 3*(index-2)+2) = zero
      k(3*index-0, 3*(index-2)+3) = -one
      DO i=3*index-2,3*index
        k(i, i) = one
      END DO
    ELSE IF (bc2 .EQ. 'constz') THEN
! Populate matrix
      k(3*index-2, 3*(index-2)+1) = -one
      k(3*index-2, 3*(index-2)+2) = zero
      k(3*index-2, 3*(index-2)+3) = zero
      k(3*index-1, 3*(index-2)+1) = zero
      k(3*index-1, 3*(index-2)+2) = -one
      k(3*index-1, 3*(index-2)+3) = zero
      DO i=3*index-2,3*index
        k(i, i) = one
      END DO
    ELSE IF (bc2(:5) .EQ. 'curve') THEN
! Populate matrix
      DO i=3*index-2,3*index
        k(i, i) = one
      END DO
      f(3*index-2:) = s0(index)*n0(:, index)
    ELSE
! Call assembly routine
      CALL MATRIXBUILDER(index, bc1, bc2, r0, rm1, n0, s0, sm1, &
&                  numlayers, epse0, layerindex, theta, index, k, f)
    END IF
! Set other parameters
! Problem size
    n = 3*numnodes
! number of right hand sides in f
    nrhs = 1
! leading dimension of K (should be = n unless we work with submatrices)
    ldk = n
! leading dimension of f (should be = n unless we work with submatrices)
    ldf = n
! call dgesv(n, nrhs, K, ldK, ipiv, f, ldf, info)
    rhs = f
    CALL SOLVE(k, f, rhs, n, ipiv)
! Note that this f is rNext when outputted from computeMatrices_main
    f = r0 + f
  END SUBROUTINE COMPUTEMATRICES_MAIN
!  Differentiation of matrixbuilder in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: f k s0 sm1 n0 rm1 r0
!   with respect to varying inputs: f k s0 sm1 n0 rm1 r0
  SUBROUTINE MATRIXBUILDER_B(curr_index, bc1, bc2, r0, r0b, rm1, rm1b, &
&   n0, n0b, s0, s0b, sm1, sm1b, numlayers, epse0, layerindex, theta, &
&   numnodes, k, kb, f, fb)
    IMPLICIT NONE
    INTEGER(kind=inttype), INTENT(IN) :: curr_index, numnodes, numlayers&
&   , layerindex
    REAL(kind=realtype), INTENT(IN) :: r0(3*numnodes), rm1(3*numnodes), &
&   n0(3, numnodes)
    REAL(kind=realtype) :: r0b(3*numnodes), rm1b(3*numnodes), n0b(3, &
&   numnodes)
    REAL(kind=realtype), INTENT(IN) :: sm1(numnodes), epse0, s0(numnodes&
&   ), theta
    REAL(kind=realtype) :: sm1b(numnodes), s0b(numnodes)
    CHARACTER(len=32), INTENT(IN) :: bc1, bc2
    REAL(kind=realtype), INTENT(INOUT) :: k(3*numnodes, 3*numnodes), f(3&
&   *numnodes)
    REAL(kind=realtype) :: kb(3*numnodes, 3*numnodes), fb(3*numnodes)
    REAL(kind=realtype) :: r_curr(3), r_next(3), d_vec(3), d_vec_rot(3)
    REAL(kind=realtype) :: r0_xi(3), pi, angle, b0(3, 3), b0inv(3, 3)
    REAL(kind=realtype) :: r0_xib(3), angleb, b0b(3, 3), b0invb(3, 3)
    REAL(kind=realtype) :: r0_xi_n(3), point(3), neigh1_point(3), &
&   neigh2_point(3)
    REAL(kind=realtype) :: r0_xi_nb(3), neigh1_pointb(3), neigh2_pointb(&
&   3)
    REAL(kind=realtype) :: r0_eta_n(3), a0(3, 3), r0_eta(3)
    REAL(kind=realtype) :: r0_eta_nb(3), a0b(3, 3), r0_etab(3)
    REAL(kind=realtype) :: dsensor, dnum, dden, eye(3, 3), b0invg(3), c0&
&   (3, 3)
    REAL(kind=realtype) :: dsensorb, dnumb, ddenb, b0invgb(3), c0b(3, 3)
    REAL(kind=realtype) :: epse, epsi, de(3), numnorm1, numnorm2, &
&   numnorm3, numnorm4
    REAL(kind=realtype) :: epseb, epsib, deb(3), numnorm1b, numnorm2b, &
&   numnorm3b, numnorm4b
    INTEGER(kind=inttype) :: index, i, j, neighbor1_index, &
&   neighbor2_index
    REAL(kind=realtype) :: one, zero
    REAL(kind=realtype), DIMENSION(3) :: arg1
    REAL(kind=realtype), DIMENSION(3) :: arg1b
    INTEGER :: branch
    REAL(kind=realtype) :: tempb4(3)
    REAL(kind=realtype) :: tempb3(3)
    REAL(kind=realtype) :: tempb2(3)
    REAL(kind=realtype) :: tempb1(3)
    REAL(kind=realtype) :: tempb0(3)
    REAL(kind=realtype) :: tempb(3)
    one = 1.
    zero = 0.
    pi = 3.1415926535897932384626
    eye(:, :) = zero
    DO i=1,3
      eye(i, i) = one
    END DO
    IF (curr_index .EQ. 1) THEN
! forward case
      IF (bc1 .NE. 'continuous') THEN
        neighbor1_index = 2
        neighbor2_index = 3
! Using forward differencing for xi = 1
        r0_xi = 0.5*(-(3*r0(:3))+4*r0(4:6)-r0(7:9))
        angle = pi
        CALL PUSHCONTROL2B(0)
      ELSE
        neighbor1_index = numnodes - 1
        neighbor2_index = 2
! Using central differencing for zeta = 2:numNodes-1
        r0_xi = 0.5*(r0(4:6)-r0(3*(neighbor1_index-1)+1:3*(&
&         neighbor1_index-1)+3))
! Compute the local grid angle based on the neighbors
        CALL GIVEANGLE(r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+&
&                3), r0(:3), r0(4:6), n0(:, 1), angle)
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE IF (curr_index .EQ. numnodes) THEN
! backward case
      neighbor1_index = curr_index - 1
      neighbor2_index = curr_index - 2
! Using backward differencing for xi = numNodes
      r0_xi = 0.5*(3*r0(3*(curr_index-1)+1:3*(curr_index-1)+3)-4*r0(3*(&
&       neighbor1_index-1)+1:3*(neighbor1_index-1)+3)+r0(3*(&
&       neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
      angle = pi
      CALL PUSHCONTROL2B(2)
    ELSE
! central case
      neighbor1_index = curr_index - 1
      neighbor2_index = curr_index + 1
      neigh2_point = r0(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3)
      neigh1_point = r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)
! Using central differencing for zeta = 2:numNodes-1
      r0_xi = 0.5*(neigh2_point-neigh1_point)
! Compute the local grid angle based on the neighbors
      CALL GIVEANGLE(neigh1_point, r0(3*(curr_index-1)+1:3*(curr_index-1&
&              )+3), neigh2_point, n0(:, curr_index), angle)
      CALL PUSHCONTROL2B(3)
    END IF
    CALL CROSS(n0(:, curr_index), r0_xi, r0_xi_n)
! Assemble B0 matrix
    b0(1, :) = r0_xi
    b0(2, :) = r0_xi_n
    b0(3, :) = n0(:, curr_index)
! Invert B0
    CALL MATINV3(b0, b0inv)
! Compute eta derivatives
    r0_eta = b0inv(:, 2)*sm1(curr_index)
    CALL CROSS(n0(:, curr_index), r0_eta, r0_eta_n)
! Assemble A0 matrix
    a0(1, :) = r0_eta
    a0(2, :) = r0_eta_n
    a0(3, :) = zero
    arg1(:) = rm1(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) - rm1&
&     (3*(curr_index-1)+1:3*(curr_index-1)+3)
    CALL NORM(arg1(:), numnorm1)
    CALL PUSHREAL8ARRAY(arg1, realtype*3/8)
    arg1(:) = rm1(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) - rm1&
&     (3*(curr_index-1)+1:3*(curr_index-1)+3)
    CALL NORM(arg1(:), numnorm2)
    CALL PUSHREAL8ARRAY(arg1, realtype*3/8)
    arg1(:) = r0(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) - r0(3&
&     *(curr_index-1)+1:3*(curr_index-1)+3)
    CALL NORM(arg1(:), numnorm3)
    CALL PUSHREAL8ARRAY(arg1, realtype*3/8)
    arg1(:) = r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) - r0(3&
&     *(curr_index-1)+1:3*(curr_index-1)+3)
    CALL NORM(arg1(:), numnorm4)
! Compute grid distribution sensor (Eq. 6.8a)
    dnum = numnorm1 + numnorm2
    dden = numnorm3 + numnorm4
    dsensor = dnum/dden
! Sharp convex corner detection
    IF (angle .LT. 70.*pi/180.) THEN
      fb(3*(curr_index-1)+1:3*(curr_index-1)+3) = 0.0_8
      kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)+1:&
&     3*(neighbor1_index-1)+3) = 0.0_8
      kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*(&
&     curr_index-1)+3) = 0.0_8
      kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)+1:&
&     3*(neighbor2_index-1)+3) = 0.0_8
      r0_etab = 0.0_8
      dsensorb = 0.0_8
      a0b = 0.0_8
      b0invb = 0.0_8
      angleb = 0.0_8
      r0_xib = 0.0_8
    ELSE
! Compute smoothing coefficients
      CALL DISSIPATIONCOEFFICIENTS(layerindex, r0_xi, r0_eta, dsensor, &
&                            angle, numlayers, epse0, epse, epsi)
! Compute RHS components
      IF (curr_index .EQ. 1) THEN
        IF (bc1 .NE. 'continuous') THEN
          deb = 0.0_8
          b0invgb = 0.0_8
          b0invgb = fb(3*(curr_index-1)+1:3*(curr_index-1)+3)
          deb = fb(3*(curr_index-1)+1:3*(curr_index-1)+3)
          fb(3*(curr_index-1)+1:3*(curr_index-1)+3) = 0.0_8
          c0b = 0.0_8
          epsib = -SUM(eye*kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(&
&           curr_index-1)+1:3*(curr_index-1)+3))
          c0b = -((theta+1)*1.5*kb(3*(curr_index-1)+1:3*(curr_index-1)+3&
&           , 3*(curr_index-1)+1:3*(curr_index-1)+3))
          kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3&
&         *(curr_index-1)+3) = 0.0_8
          c0b = c0b + (theta+1)*2*kb(3*(curr_index-1)+1:3*(curr_index-1)&
&           +3, 3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)
          epsib = epsib + SUM(eye*2*kb(3*(curr_index-1)+1:3*(curr_index-&
&           1)+3, 3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3))
          kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1&
&         )+1:3*(neighbor1_index-1)+3) = 0.0_8
          c0b = c0b - (theta+1)*0.5*kb(3*(curr_index-1)+1:3*(curr_index-&
&           1)+3, 3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3)
          epsib = epsib - SUM(eye*kb(3*(curr_index-1)+1:3*(curr_index-1)&
&           +3, 3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
          kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1&
&         )+1:3*(neighbor2_index-1)+3) = 0.0_8
          tempb1 = epse*deb
          epseb = SUM((r0(3*(curr_index-1)+1:3*(curr_index-1)+3)-2*r0(3*&
&           (neighbor1_index-1)+1:3*(neighbor1_index-1)+3)+r0(3*(&
&           neighbor2_index-1)+1:3*(neighbor2_index-1)+3))*deb)
          r0b(3*(curr_index-1)+1:3*(curr_index-1)+3) = r0b(3*(curr_index&
&           -1)+1:3*(curr_index-1)+3) + tempb1
          r0b(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) = r0b(3*(&
&           neighbor1_index-1)+1:3*(neighbor1_index-1)+3) - 2*tempb1
          r0b(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) = r0b(3*(&
&           neighbor2_index-1)+1:3*(neighbor2_index-1)+3) + tempb1
        ELSE
          deb = 0.0_8
          b0invgb = 0.0_8
          b0invgb = fb(3*(curr_index-1)+1:3*(curr_index-1)+3)
          deb = fb(3*(curr_index-1)+1:3*(curr_index-1)+3)
          fb(3*(curr_index-1)+1:3*(curr_index-1)+3) = 0.0_8
          c0b = 0.0_8
          c0b = (theta+1)*0.5*kb(3*(curr_index-1)+1:3*(curr_index-1)+3, &
&           3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3)
          epsib = -SUM(eye*kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(&
&           neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
          kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1&
&         )+1:3*(neighbor2_index-1)+3) = 0.0_8
          epsib = epsib + 2*SUM(eye*kb(3*(curr_index-1)+1:3*(curr_index-&
&           1)+3, 3*(curr_index-1)+1:3*(curr_index-1)+3))
          kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3&
&         *(curr_index-1)+3) = 0.0_8
          c0b = c0b - (theta+1)*0.5*kb(3*(curr_index-1)+1:3*(curr_index-&
&           1)+3, 3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)
          epsib = epsib - SUM(eye*kb(3*(curr_index-1)+1:3*(curr_index-1)&
&           +3, 3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3))
          kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1&
&         )+1:3*(neighbor1_index-1)+3) = 0.0_8
          tempb2 = epse*deb
          epseb = SUM((r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+&
&           3)-2*r0(3*(curr_index-1)+1:3*(curr_index-1)+3)+r0(3*(&
&           neighbor2_index-1)+1:3*(neighbor2_index-1)+3))*deb)
          r0b(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) = r0b(3*(&
&           neighbor1_index-1)+1:3*(neighbor1_index-1)+3) + tempb2
          r0b(3*(curr_index-1)+1:3*(curr_index-1)+3) = r0b(3*(curr_index&
&           -1)+1:3*(curr_index-1)+3) - 2*tempb2
          r0b(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) = r0b(3*(&
&           neighbor2_index-1)+1:3*(neighbor2_index-1)+3) + tempb2
        END IF
      ELSE IF (curr_index .EQ. numnodes) THEN
        deb = 0.0_8
        b0invgb = 0.0_8
        b0invgb = fb(3*(curr_index-1)+1:3*(curr_index-1)+3)
        deb = fb(3*(curr_index-1)+1:3*(curr_index-1)+3)
        fb(3*(curr_index-1)+1:3*(curr_index-1)+3) = 0.0_8
        c0b = 0.0_8
        c0b = (theta+1)*1.5*kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*&
&         (curr_index-1)+1:3*(curr_index-1)+3)
        epsib = -SUM(eye*kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(&
&         curr_index-1)+1:3*(curr_index-1)+3))
        kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*(&
&       curr_index-1)+3) = 0.0_8
        epsib = epsib + SUM(eye*2*kb(3*(curr_index-1)+1:3*(curr_index-1)&
&         +3, 3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3))
        c0b = c0b - (theta+1)*2*kb(3*(curr_index-1)+1:3*(curr_index-1)+3&
&         , 3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)
        kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)+&
&       1:3*(neighbor1_index-1)+3) = 0.0_8
        c0b = c0b + (theta+1)*0.5*kb(3*(curr_index-1)+1:3*(curr_index-1)&
&         +3, 3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3)
        epsib = epsib - SUM(eye*kb(3*(curr_index-1)+1:3*(curr_index-1)+3&
&         , 3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
        kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)+&
&       1:3*(neighbor2_index-1)+3) = 0.0_8
        tempb3 = epse*deb
        epseb = SUM((r0(3*(curr_index-1)+1:3*(curr_index-1)+3)-2*r0(3*(&
&         neighbor1_index-1)+1:3*(neighbor1_index-1)+3)+r0(3*(&
&         neighbor2_index-1)+1:3*(neighbor2_index-1)+3))*deb)
        r0b(3*(curr_index-1)+1:3*(curr_index-1)+3) = r0b(3*(curr_index-1&
&         )+1:3*(curr_index-1)+3) + tempb3
        r0b(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) = r0b(3*(&
&         neighbor1_index-1)+1:3*(neighbor1_index-1)+3) - 2*tempb3
        r0b(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) = r0b(3*(&
&         neighbor2_index-1)+1:3*(neighbor2_index-1)+3) + tempb3
      ELSE
        deb = 0.0_8
        b0invgb = 0.0_8
        b0invgb = fb(3*(curr_index-1)+1:3*(curr_index-1)+3)
        deb = fb(3*(curr_index-1)+1:3*(curr_index-1)+3)
        fb(3*(curr_index-1)+1:3*(curr_index-1)+3) = 0.0_8
        c0b = 0.0_8
        c0b = (theta+1)*0.5*kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*&
&         (neighbor2_index-1)+1:3*(neighbor2_index-1)+3)
        epsib = -SUM(eye*kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(&
&         neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
        kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)+&
&       1:3*(neighbor2_index-1)+3) = 0.0_8
        epsib = epsib + 2*SUM(eye*kb(3*(curr_index-1)+1:3*(curr_index-1)&
&         +3, 3*(curr_index-1)+1:3*(curr_index-1)+3))
        kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*(&
&       curr_index-1)+3) = 0.0_8
        c0b = c0b - (theta+1)*0.5*kb(3*(curr_index-1)+1:3*(curr_index-1)&
&         +3, 3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)
        epsib = epsib - SUM(eye*kb(3*(curr_index-1)+1:3*(curr_index-1)+3&
&         , 3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3))
        kb(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)+&
&       1:3*(neighbor1_index-1)+3) = 0.0_8
        tempb4 = epse*deb
        epseb = SUM((r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)&
&         -2*r0(3*(curr_index-1)+1:3*(curr_index-1)+3)+r0(3*(&
&         neighbor2_index-1)+1:3*(neighbor2_index-1)+3))*deb)
        r0b(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) = r0b(3*(&
&         neighbor1_index-1)+1:3*(neighbor1_index-1)+3) + tempb4
        r0b(3*(curr_index-1)+1:3*(curr_index-1)+3) = r0b(3*(curr_index-1&
&         )+1:3*(curr_index-1)+3) - 2*tempb4
        r0b(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) = r0b(3*(&
&         neighbor2_index-1)+1:3*(neighbor2_index-1)+3) + tempb4
      END IF
      b0invb = 0.0_8
      b0invb(:, 2) = b0invb(:, 2) + s0(curr_index)*b0invgb
      s0b(curr_index) = s0b(curr_index) + SUM(b0inv(:, 2)*b0invgb)
      CALL DISSIPATIONCOEFFICIENTS_B(layerindex, r0_xi, r0_xib, r0_eta, &
&                              r0_etab, dsensor, dsensorb, angle, angleb&
&                              , numlayers, epse0, epse, epseb, epsi, &
&                              epsib)
      a0b = 0.0_8
      DO i=3,1,-1
        DO j=3,1,-1
          CALL DOT_B0(b0inv(i, :), b0invb(i, :), a0(:, j), a0b(:, j), c0&
&               (i, j), c0b(i, j))
          c0b(i, j) = 0.0_8
        END DO
      END DO
    END IF
    dnumb = dsensorb/dden
    ddenb = -(dnum*dsensorb/dden**2)
    numnorm3b = ddenb
    numnorm4b = ddenb
    numnorm1b = dnumb
    numnorm2b = dnumb
    CALL NORM_B0(arg1(:), arg1b(:), numnorm4, numnorm4b)
    CALL POPREAL8ARRAY(arg1, realtype*3/8)
    r0b(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) = r0b(3*(&
&     neighbor1_index-1)+1:3*(neighbor1_index-1)+3) + arg1b
    r0b(3*(curr_index-1)+1:3*(curr_index-1)+3) = r0b(3*(curr_index-1)+1:&
&     3*(curr_index-1)+3) - arg1b
    CALL NORM_B0(arg1(:), arg1b(:), numnorm3, numnorm3b)
    CALL POPREAL8ARRAY(arg1, realtype*3/8)
    r0b(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) = r0b(3*(&
&     neighbor2_index-1)+1:3*(neighbor2_index-1)+3) + arg1b
    r0b(3*(curr_index-1)+1:3*(curr_index-1)+3) = r0b(3*(curr_index-1)+1:&
&     3*(curr_index-1)+3) - arg1b
    CALL NORM_B0(arg1(:), arg1b(:), numnorm2, numnorm2b)
    CALL POPREAL8ARRAY(arg1, realtype*3/8)
    rm1b(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) = rm1b(3*(&
&     neighbor1_index-1)+1:3*(neighbor1_index-1)+3) + arg1b
    rm1b(3*(curr_index-1)+1:3*(curr_index-1)+3) = rm1b(3*(curr_index-1)+&
&     1:3*(curr_index-1)+3) - arg1b
    CALL NORM_B0(arg1(:), arg1b(:), numnorm1, numnorm1b)
    rm1b(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) = rm1b(3*(&
&     neighbor2_index-1)+1:3*(neighbor2_index-1)+3) + arg1b
    rm1b(3*(curr_index-1)+1:3*(curr_index-1)+3) = rm1b(3*(curr_index-1)+&
&     1:3*(curr_index-1)+3) - arg1b
    a0b(3, :) = 0.0_8
    r0_eta_nb = 0.0_8
    r0_eta_nb = a0b(2, :)
    a0b(2, :) = 0.0_8
    r0_etab = r0_etab + a0b(1, :)
    CALL CROSS_B(n0(:, curr_index), n0b(:, curr_index), r0_eta, r0_etab&
&          , r0_eta_n, r0_eta_nb)
    b0invb(:, 2) = b0invb(:, 2) + sm1(curr_index)*r0_etab
    sm1b(curr_index) = sm1b(curr_index) + SUM(b0inv(:, 2)*r0_etab)
    CALL MATINV3_B(b0, b0b, b0inv, b0invb)
    n0b(:, curr_index) = n0b(:, curr_index) + b0b(3, :)
    b0b(3, :) = 0.0_8
    r0_xi_nb = 0.0_8
    r0_xi_nb = b0b(2, :)
    b0b(2, :) = 0.0_8
    r0_xib = r0_xib + b0b(1, :)
    CALL CROSS_B(n0(:, curr_index), n0b(:, curr_index), r0_xi, r0_xib, &
&          r0_xi_n, r0_xi_nb)
    CALL POPCONTROL2B(branch)
    IF (branch .LT. 2) THEN
      IF (branch .EQ. 0) THEN
        tempb = 0.5*r0_xib
        r0b(4:6) = r0b(4:6) + 4*tempb
        r0b(1:3) = r0b(1:3) - 3*tempb
        r0b(7:9) = r0b(7:9) - tempb
      ELSE
        CALL GIVEANGLE_B(r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1&
&                  )+3), r0b(3*(neighbor1_index-1)+1:3*(neighbor1_index-&
&                  1)+3), r0(:3), r0b(:3), r0(4:6), r0b(4:6), n0(:, 1), &
&                  angle, angleb)
        r0b(4:6) = r0b(4:6) + 0.5*r0_xib
        r0b(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) = r0b(3*(&
&         neighbor1_index-1)+1:3*(neighbor1_index-1)+3) - 0.5*r0_xib
      END IF
    ELSE IF (branch .EQ. 2) THEN
      tempb0 = 0.5*r0_xib
      r0b(3*(curr_index-1)+1:3*(curr_index-1)+3) = r0b(3*(curr_index-1)+&
&       1:3*(curr_index-1)+3) + 3*tempb0
      r0b(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) = r0b(3*(&
&       neighbor1_index-1)+1:3*(neighbor1_index-1)+3) - 4*tempb0
      r0b(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) = r0b(3*(&
&       neighbor2_index-1)+1:3*(neighbor2_index-1)+3) + tempb0
    ELSE
      neigh1_pointb = 0.0_8
      neigh2_pointb = 0.0_8
      CALL GIVEANGLE_B(neigh1_point, neigh1_pointb, r0(3*(curr_index-1)+&
&                1:3*(curr_index-1)+3), r0b(3*(curr_index-1)+1:3*(&
&                curr_index-1)+3), neigh2_point, neigh2_pointb, n0(:, &
&                curr_index), angle, angleb)
      neigh2_pointb = neigh2_pointb + 0.5*r0_xib
      neigh1_pointb = neigh1_pointb - 0.5*r0_xib
      r0b(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) = r0b(3*(&
&       neighbor1_index-1)+1:3*(neighbor1_index-1)+3) + neigh1_pointb
      r0b(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) = r0b(3*(&
&       neighbor2_index-1)+1:3*(neighbor2_index-1)+3) + neigh2_pointb
    END IF
  END SUBROUTINE MATRIXBUILDER_B
  SUBROUTINE MATRIXBUILDER(curr_index, bc1, bc2, r0, rm1, n0, s0, sm1, &
&   numlayers, epse0, layerindex, theta, numnodes, k, f)
    IMPLICIT NONE
    INTEGER(kind=inttype), INTENT(IN) :: curr_index, numnodes, numlayers&
&   , layerindex
    REAL(kind=realtype), INTENT(IN) :: r0(3*numnodes), rm1(3*numnodes), &
&   n0(3, numnodes)
    REAL(kind=realtype), INTENT(IN) :: sm1(numnodes), epse0, s0(numnodes&
&   ), theta
    CHARACTER(len=32), INTENT(IN) :: bc1, bc2
    REAL(kind=realtype), INTENT(INOUT) :: k(3*numnodes, 3*numnodes), f(3&
&   *numnodes)
    REAL(kind=realtype) :: r_curr(3), r_next(3), d_vec(3), d_vec_rot(3)
    REAL(kind=realtype) :: r0_xi(3), pi, angle, b0(3, 3), b0inv(3, 3)
    REAL(kind=realtype) :: r0_xi_n(3), point(3), neigh1_point(3), &
&   neigh2_point(3)
    REAL(kind=realtype) :: r0_eta_n(3), a0(3, 3), r0_eta(3)
    REAL(kind=realtype) :: dsensor, dnum, dden, eye(3, 3), b0invg(3), c0&
&   (3, 3)
    REAL(kind=realtype) :: epse, epsi, de(3), numnorm1, numnorm2, &
&   numnorm3, numnorm4
    INTEGER(kind=inttype) :: index, i, j, neighbor1_index, &
&   neighbor2_index
    REAL(kind=realtype) :: one, zero
    REAL(kind=realtype), DIMENSION(3) :: arg1
    one = 1.
    zero = 0.
    pi = 3.1415926535897932384626
    eye(:, :) = zero
    DO i=1,3
      eye(i, i) = one
    END DO
    IF (curr_index .EQ. 1) THEN
! forward case
      IF (bc1 .NE. 'continuous') THEN
        neighbor1_index = 2
        neighbor2_index = 3
! Using forward differencing for xi = 1
        r0_xi = 0.5*(-(3*r0(:3))+4*r0(4:6)-r0(7:9))
        angle = pi
      ELSE
        neighbor1_index = numnodes - 1
        neighbor2_index = 2
! Using central differencing for zeta = 2:numNodes-1
        r0_xi = 0.5*(r0(4:6)-r0(3*(neighbor1_index-1)+1:3*(&
&         neighbor1_index-1)+3))
! Compute the local grid angle based on the neighbors
        CALL GIVEANGLE(r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+&
&                3), r0(:3), r0(4:6), n0(:, 1), angle)
      END IF
    ELSE IF (curr_index .EQ. numnodes) THEN
! backward case
      neighbor1_index = curr_index - 1
      neighbor2_index = curr_index - 2
! Using backward differencing for xi = numNodes
      r0_xi = 0.5*(3*r0(3*(curr_index-1)+1:3*(curr_index-1)+3)-4*r0(3*(&
&       neighbor1_index-1)+1:3*(neighbor1_index-1)+3)+r0(3*(&
&       neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
      angle = pi
    ELSE
! central case
      neighbor1_index = curr_index - 1
      neighbor2_index = curr_index + 1
      neigh2_point = r0(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3)
      neigh1_point = r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)
! Using central differencing for zeta = 2:numNodes-1
      r0_xi = 0.5*(neigh2_point-neigh1_point)
! Compute the local grid angle based on the neighbors
      CALL GIVEANGLE(neigh1_point, r0(3*(curr_index-1)+1:3*(curr_index-1&
&              )+3), neigh2_point, n0(:, curr_index), angle)
    END IF
    CALL CROSS(n0(:, curr_index), r0_xi, r0_xi_n)
! Assemble B0 matrix
    b0(1, :) = r0_xi
    b0(2, :) = r0_xi_n
    b0(3, :) = n0(:, curr_index)
! Invert B0
    CALL MATINV3(b0, b0inv)
! Compute eta derivatives
    r0_eta = b0inv(:, 2)*sm1(curr_index)
    CALL CROSS(n0(:, curr_index), r0_eta, r0_eta_n)
! Assemble A0 matrix
    a0(1, :) = r0_eta
    a0(2, :) = r0_eta_n
    a0(3, :) = zero
    arg1(:) = rm1(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) - rm1&
&     (3*(curr_index-1)+1:3*(curr_index-1)+3)
    CALL NORM(arg1(:), numnorm1)
    arg1(:) = rm1(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) - rm1&
&     (3*(curr_index-1)+1:3*(curr_index-1)+3)
    CALL NORM(arg1(:), numnorm2)
    arg1(:) = r0(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) - r0(3&
&     *(curr_index-1)+1:3*(curr_index-1)+3)
    CALL NORM(arg1(:), numnorm3)
    arg1(:) = r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) - r0(3&
&     *(curr_index-1)+1:3*(curr_index-1)+3)
    CALL NORM(arg1(:), numnorm4)
! Compute grid distribution sensor (Eq. 6.8a)
    dnum = numnorm1 + numnorm2
    dden = numnorm3 + numnorm4
    dsensor = dnum/dden
! Sharp convex corner detection
    IF (angle .LT. 70.*pi/180.) THEN
! Corner detected
! Populate matrix with Eq 8.3
      k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)+1:3&
&     *(neighbor2_index-1)+3) = -eye
      k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*(&
&     curr_index-1)+3) = 2*eye
      k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)+1:3&
&     *(neighbor1_index-1)+3) = -eye
      f(3*(curr_index-1)+1:3*(curr_index-1)+3) = zero
    ELSE
! Compute C0 = B0inv*A0
      DO i=1,3
        DO j=1,3
          CALL DOT(b0inv(i, :), a0(:, j), c0(i, j))
        END DO
      END DO
! Compute smoothing coefficients
      CALL DISSIPATIONCOEFFICIENTS(layerindex, r0_xi, r0_eta, dsensor, &
&                            angle, numlayers, epse0, epse, epsi)
! Compute RHS components
      b0invg = b0inv(:, 2)*s0(curr_index)
      IF (curr_index .EQ. 1) THEN
        IF (bc1 .NE. 'continuous') THEN
! forwards
          de = epse*(r0(3*(curr_index-1)+1:3*(curr_index-1)+3)-2*r0(3*(&
&           neighbor1_index-1)+1:3*(neighbor1_index-1)+3)+r0(3*(&
&           neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
! Populate matrix
          k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)&
&         +1:3*(neighbor2_index-1)+3) = -(0.5*(1+theta)*c0) - epsi*eye
          k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)&
&         +1:3*(neighbor1_index-1)+3) = 2*(1+theta)*c0 + 2*epsi*eye
          k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*&
&         (curr_index-1)+3) = -(1.5*(1+theta)*c0) + (1-epsi)*eye
          f(3*(curr_index-1)+1:3*(curr_index-1)+3) = b0invg + de
        ELSE
          de = epse*(r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)&
&           -2*r0(3*(curr_index-1)+1:3*(curr_index-1)+3)+r0(3*(&
&           neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
! Populate matrix
          k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)&
&         +1:3*(neighbor1_index-1)+3) = -(0.5*(1+theta)*c0) - epsi*eye
          k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*&
&         (curr_index-1)+3) = (1+2*epsi)*eye
          k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)&
&         +1:3*(neighbor2_index-1)+3) = 0.5*(1+theta)*c0 - epsi*eye
          f(3*(curr_index-1)+1:3*(curr_index-1)+3) = b0invg + de
        END IF
      ELSE IF (curr_index .EQ. numnodes) THEN
! backwards
        de = epse*(r0(3*(curr_index-1)+1:3*(curr_index-1)+3)-2*r0(3*(&
&         neighbor1_index-1)+1:3*(neighbor1_index-1)+3)+r0(3*(&
&         neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
! Populate matrix
        k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)+1&
&       :3*(neighbor2_index-1)+3) = 0.5*(1+theta)*c0 - epsi*eye
        k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)+1&
&       :3*(neighbor1_index-1)+3) = -(2*(1+theta)*c0) + 2*epsi*eye
        k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*(&
&       curr_index-1)+3) = 1.5*(1+theta)*c0 + (1-epsi)*eye
        f(3*(curr_index-1)+1:3*(curr_index-1)+3) = b0invg + de
      ELSE
! central
        de = epse*(r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)-2&
&         *r0(3*(curr_index-1)+1:3*(curr_index-1)+3)+r0(3*(&
&         neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
        k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)+1&
&       :3*(neighbor1_index-1)+3) = -(0.5*(1+theta)*c0) - epsi*eye
        k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*(&
&       curr_index-1)+3) = (1+2*epsi)*eye
        k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)+1&
&       :3*(neighbor2_index-1)+3) = 0.5*(1+theta)*c0 - epsi*eye
        f(3*(curr_index-1)+1:3*(curr_index-1)+3) = b0invg + de
      END IF
    END IF
  END SUBROUTINE MATRIXBUILDER
!  Differentiation of dissipationcoefficients in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: epse epsi
!   with respect to varying inputs: r0_eta dsensor angle r0_xi
  SUBROUTINE DISSIPATIONCOEFFICIENTS_B(layerindex, r0_xi, r0_xib, r0_eta&
&   , r0_etab, dsensor, dsensorb, angle, angleb, numlayers, epse0, epse&
&   , epseb, epsi, epsib)
    IMPLICIT NONE
    INTEGER(kind=inttype), INTENT(IN) :: layerindex, numlayers
    REAL(kind=realtype), INTENT(IN) :: dsensor, angle, epse0, r0_xi(3), &
&   r0_eta(3)
    REAL(kind=realtype) :: dsensorb, angleb, r0_xib(3), r0_etab(3)
    REAL(kind=realtype) :: epse, epsi
    REAL(kind=realtype) :: epseb, epsib
    REAL(kind=realtype) :: sl, dbar, a, pi, n, r, normeta, normxi
    REAL(kind=realtype) :: dbarb, ab, nb, rb, normetab, normxib
    INTEGER(kind=inttype) :: l, ltrans
    INTRINSIC INT
    INTRINSIC FLOAT
    INTRINSIC DSQRT
    INTRINSIC MAX
    INTRINSIC COS
    INTEGER :: branch
    REAL(kind=realtype) :: temp
    pi = 3.14159265358979323846264338
! Compute N (Eq. 6.3)
    CALL NORM(r0_eta, normeta)
    CALL NORM(r0_xi, normxi)
    n = normeta/normxi
! Compute Sl (Eq. 6.5) based on a transition l of 3/4 of max
    l = layerindex + 2
    ltrans = INT(3./4.*numlayers)
    IF (l .LE. ltrans) THEN
      sl = DSQRT(FLOAT(l-1)/FLOAT(ltrans-1))
    ELSE
      sl = DSQRT(FLOAT(ltrans-1)/FLOAT(numlayers-1))
    END IF
    IF (dsensor**(2./sl) .LT. 0.1) THEN
      dbar = 0.1
      CALL PUSHCONTROL1B(0)
    ELSE
      dbar = dsensor**(2./sl)
      CALL PUSHCONTROL1B(1)
    END IF
! Compute a (Eq 6.12 adjusted for entire angle (angle=2*alpha))
    IF (angle .LE. pi) THEN
! Convex corner
      a = 1.0
      CALL PUSHCONTROL1B(0)
    ELSE
      a = 1.0/(1.0-COS(angle/2)*COS(angle/2))
      CALL PUSHCONTROL1B(1)
    END IF
! Compute auxiliary variable R (Eq. 6.4)
    r = sl*dbar*a
! Compute the dissipation coefficients
    epseb = epseb + 2*epsib
    rb = epse0*n*epseb
    nb = epse0*r*epseb
    dbarb = sl*a*rb
    ab = sl*dbar*rb
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      angleb = 0.0_8
    ELSE
      temp = COS(angle/2)
      angleb = -(SIN(angle/2)*temp*ab/(1.0-temp**2)**2)
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      dsensorb = 0.0_8
    ELSE IF (dsensor .LE. 0.0_8 .AND. (2./sl .EQ. 0.0_8 .OR. 2./sl .NE. &
&       INT(2./sl))) THEN
      dsensorb = 0.0
    ELSE
      dsensorb = 2.*dsensor**(2./sl-1)*dbarb/sl
    END IF
    normetab = nb/normxi
    normxib = -(normeta*nb/normxi**2)
    CALL NORM_B0(r0_xi, r0_xib, normxi, normxib)
    CALL NORM_B0(r0_eta, r0_etab, normeta, normetab)
  END SUBROUTINE DISSIPATIONCOEFFICIENTS_B
  SUBROUTINE DISSIPATIONCOEFFICIENTS(layerindex, r0_xi, r0_eta, dsensor&
&   , angle, numlayers, epse0, epse, epsi)
    IMPLICIT NONE
    INTEGER(kind=inttype), INTENT(IN) :: layerindex, numlayers
    REAL(kind=realtype), INTENT(IN) :: dsensor, angle, epse0, r0_xi(3), &
&   r0_eta(3)
    REAL(kind=realtype), INTENT(OUT) :: epse, epsi
    REAL(kind=realtype) :: sl, dbar, a, pi, n, r, normeta, normxi
    INTEGER(kind=inttype) :: l, ltrans
    INTRINSIC INT
    INTRINSIC FLOAT
    INTRINSIC DSQRT
    INTRINSIC MAX
    INTRINSIC COS
    pi = 3.14159265358979323846264338
! Compute N (Eq. 6.3)
    CALL NORM(r0_eta, normeta)
    CALL NORM(r0_xi, normxi)
    n = normeta/normxi
! Compute Sl (Eq. 6.5) based on a transition l of 3/4 of max
    l = layerindex + 2
    ltrans = INT(3./4.*numlayers)
    IF (l .LE. ltrans) THEN
      sl = DSQRT(FLOAT(l-1)/FLOAT(ltrans-1))
    ELSE
      sl = DSQRT(FLOAT(ltrans-1)/FLOAT(numlayers-1))
    END IF
    IF (dsensor**(2./sl) .LT. 0.1) THEN
      dbar = 0.1
    ELSE
      dbar = dsensor**(2./sl)
    END IF
! Compute a (Eq 6.12 adjusted for entire angle (angle=2*alpha))
    IF (angle .LE. pi) THEN
! Convex corner
      a = 1.0
    ELSE
      a = 1.0/(1.0-COS(angle/2)*COS(angle/2))
    END IF
! Compute auxiliary variable R (Eq. 6.4)
    r = sl*dbar*a
! Compute the dissipation coefficients
    epse = epse0*r*n
    epsi = 2*epse
  END SUBROUTINE DISSIPATIONCOEFFICIENTS
!  Differentiation of areafactor in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: s
!   with respect to varying inputs: d s r0
!   RW status of diff variables: d:out s:in-zero r0:out
  SUBROUTINE AREAFACTOR_B(r0, r0b, d, db, nuarea, numareapasses, bc1, &
&   bc2, n, s, sb, maxstretch)
    IMPLICIT NONE
    INTEGER(kind=inttype), INTENT(IN) :: n
    REAL(kind=realtype), INTENT(IN) :: r0(3*n), d, nuarea
    REAL(kind=realtype) :: r0b(3*n), db
    INTEGER(kind=inttype), INTENT(IN) :: numareapasses
    CHARACTER(len=32), INTENT(IN) :: bc1, bc2
    REAL(kind=realtype) :: s(n), maxstretch
    REAL(kind=realtype) :: sb(n)
    REAL(kind=realtype) :: r0_extrap(3*(2+n))
    REAL(kind=realtype) :: r0_extrapb(3*(2+n))
    REAL(kind=realtype) :: neighbordist(n), norm_1(n), norm_2(n)
    REAL(kind=realtype) :: neighbordistb(n), norm_1b(n), norm_2b(n)
    REAL(kind=realtype) :: sminus, splus, stretchratio(n)
    REAL(kind=realtype) :: sminusb, splusb
    INTEGER(kind=inttype) :: index
    REAL(kind=realtype), DIMENSION(3) :: arg1
    REAL(kind=realtype), DIMENSION(3) :: arg1b
    REAL(kind=realtype), DIMENSION(n-2) :: tmp
    INTEGER :: branch
    REAL(kind=realtype) :: tmpb(n-2)
    REAL(kind=realtype) :: tempb(n-2)
! Extrapolate the end points and copy starting curve
    r0_extrap(:3) = 2*r0(:3) - r0(4:6)
    r0_extrap(4:3*(n+1)) = r0
    r0_extrap(3*(n+1)+1:) = 2*r0(3*(n-1)+1:) - r0(3*(n-2)+1:3*(n-1))
! Compute the distance of each node to its neighbors
    DO index=1,n
      arg1(:) = r0_extrap(3*index+1:3*index+3) - r0_extrap(3*index-2:3*&
&       index)
      CALL NORM(arg1(:), norm_1(index))
      arg1(:) = r0_extrap(3*index+4:3*index+6) - r0_extrap(3*index+1:3*&
&       index+3)
      CALL NORM(arg1(:), norm_2(index))
    END DO
    neighbordist = 0.5*(norm_1+norm_2)
! Multiply distances by the step size to get the areas
! Divide the marching distance and the neighbor distance to get the stretch ratios
! Get the maximum stretch ratio
! If we use curve boundary conditions, we need just the marching distance, and not area, for the end nodes
    IF (bc1(:5) .EQ. 'curve') THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (bc2(:5) .EQ. 'curve') THEN
      db = sb(n)
      sb(n) = 0.0_8
    ELSE
      db = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      db = db + sb(1)
      sb(1) = 0.0_8
    END IF
    DO index=numareapasses,1,-1
      sminusb = nuarea*sb(n)
      sb(n) = (1-nuarea)*sb(n)
      splusb = nuarea*sb(1)
      sb(1) = (1-nuarea)*sb(1)
      tmpb(1:n-2) = sb(2:n-1)
      sb(2:n-1) = (1-nuarea)*tmpb(1:n-2)
      tempb = nuarea*tmpb(1:n-2)/2
      sb(1:n-2) = sb(1:n-2) + tempb
      sb(3:n) = sb(3:n) + tempb
      sb(n-2) = sb(n-2) + sminusb
      sb(2) = sb(2) + splusb
    END DO
    neighbordistb = 0.0_8
    db = db + SUM(neighbordist*sb)
    neighbordistb = d*sb
    norm_1b = 0.0_8
    norm_2b = 0.0_8
    norm_1b = 0.5*neighbordistb
    norm_2b = 0.5*neighbordistb
    r0_extrapb = 0.0_8
    DO index=n,1,-1
      arg1(:) = r0_extrap(3*index+4:3*index+6) - r0_extrap(3*index+1:3*&
&       index+3)
      CALL NORM_B0(arg1(:), arg1b(:), norm_2(index), norm_2b(index))
      norm_2b(index) = 0.0_8
      r0_extrapb(3*index+4:3*index+6) = r0_extrapb(3*index+4:3*index+6) &
&       + arg1b
      r0_extrapb(3*index+1:3*index+3) = r0_extrapb(3*index+1:3*index+3) &
&       - arg1b
      arg1(:) = r0_extrap(3*index+1:3*index+3) - r0_extrap(3*index-2:3*&
&       index)
      CALL NORM_B0(arg1(:), arg1b(:), norm_1(index), norm_1b(index))
      norm_1b(index) = 0.0_8
      r0_extrapb(3*index+1:3*index+3) = r0_extrapb(3*index+1:3*index+3) &
&       + arg1b
      r0_extrapb(3*index-2:3*index) = r0_extrapb(3*index-2:3*index) - &
&       arg1b
    END DO
    r0b = 0.0_8
    r0b(3*(n-1)+1:3*n) = r0b(3*(n-1)+1:3*n) + 2*r0_extrapb(3*(n+1)+1:3*(&
&     2+n))
    r0b(3*(n-2)+1:3*(n-1)) = r0b(3*(n-2)+1:3*(n-1)) - r0_extrapb(3*(n+1)&
&     +1:3*(2+n))
    r0_extrapb(3*(n+1)+1:3*(2+n)) = 0.0_8
    r0b = r0b + r0_extrapb(4:3*(n+1))
    r0_extrapb(4:3*(n+1)) = 0.0_8
    r0b(1:3) = r0b(1:3) + 2*r0_extrapb(1:3)
    r0b(4:6) = r0b(4:6) - r0_extrapb(1:3)
    sb = 0.0_8
  END SUBROUTINE AREAFACTOR_B
  SUBROUTINE AREAFACTOR(r0, d, nuarea, numareapasses, bc1, bc2, n, s, &
&   maxstretch)
    IMPLICIT NONE
    INTEGER(kind=inttype), INTENT(IN) :: n
    REAL(kind=realtype), INTENT(IN) :: r0(3*n), d, nuarea
    INTEGER(kind=inttype), INTENT(IN) :: numareapasses
    CHARACTER(len=32), INTENT(IN) :: bc1, bc2
    REAL(kind=realtype), INTENT(OUT) :: s(n), maxstretch
    REAL(kind=realtype) :: r0_extrap(3*(2+n))
    REAL(kind=realtype) :: neighbordist(n), norm_1(n), norm_2(n)
    REAL(kind=realtype) :: sminus, splus, stretchratio(n)
    INTEGER(kind=inttype) :: index
    REAL(kind=realtype), DIMENSION(3) :: arg1
! Extrapolate the end points and copy starting curve
    r0_extrap(:3) = 2*r0(:3) - r0(4:6)
    r0_extrap(4:3*(n+1)) = r0
    r0_extrap(3*(n+1)+1:) = 2*r0(3*(n-1)+1:) - r0(3*(n-2)+1:3*(n-1))
! Compute the distance of each node to its neighbors
    DO index=1,n
      arg1(:) = r0_extrap(3*index+1:3*index+3) - r0_extrap(3*index-2:3*&
&       index)
      CALL NORM(arg1(:), norm_1(index))
      arg1(:) = r0_extrap(3*index+4:3*index+6) - r0_extrap(3*index+1:3*&
&       index+3)
      CALL NORM(arg1(:), norm_2(index))
    END DO
    neighbordist = 0.5*(norm_1+norm_2)
! Multiply distances by the step size to get the areas
    s = d*neighbordist
! Divide the marching distance and the neighbor distance to get the stretch ratios
    stretchratio = d/neighbordist
! Get the maximum stretch ratio
    maxstretch = -1.e20
    DO index=1,n
      IF (stretchratio(index) .GT. maxstretch) maxstretch = stretchratio&
&         (index)
    END DO
! Do the requested number of averagings
    DO index=1,numareapasses
! Store previous values
      splus = s(2)
      sminus = s(n-2)
! Do the averaging for the central nodes
      s(2:n-1) = (1-nuarea)*s(2:n-1) + nuarea/2*(s(:n-2)+s(3:))
! Average for the extremum nodes
      s(1) = (1-nuarea)*s(1) + nuarea*splus
      s(n) = (1-nuarea)*s(n) + nuarea*sminus
    END DO
! If we use curve boundary conditions, we need just the marching distance, and not area, for the end nodes
    IF (bc1(:5) .EQ. 'curve') s(1) = d
    IF (bc2(:5) .EQ. 'curve') s(n) = d
  END SUBROUTINE AREAFACTOR
!  Differentiation of smoothing_main in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: rout
!   with respect to varying inputs: r rout
!   RW status of diff variables: r:out rout:in-zero
  SUBROUTINE SMOOTHING_MAIN_B(r, rb, eta, alphap0, numsmoothingpasses, &
&   numlayers, n, rout, routb)
    IMPLICIT NONE
    INTEGER(kind=inttype), INTENT(IN) :: n
    REAL(kind=realtype), INTENT(IN) :: eta, alphap0
    INTEGER(kind=inttype), INTENT(IN) :: numsmoothingpasses, numlayers
    REAL(kind=realtype), INTENT(IN) :: r(3*n)
    REAL(kind=realtype) :: rb(3*n)
    REAL(kind=realtype) :: rout(3*n)
    REAL(kind=realtype) :: routb(3*n)
    REAL(kind=realtype) :: r_next(3), r_curr(3), r_prev(3), lp, lm, &
&   alphap
    REAL(kind=realtype) :: r_nextb(3), r_currb(3), r_prevb(3), lpb, lmb
    REAL(kind=realtype) :: r_smooth(3*n)
    REAL(kind=realtype) :: r_smoothb(3*n)
    INTEGER(kind=inttype) :: index, index_pass
    INTRINSIC MIN
    REAL(kind=realtype), DIMENSION(3) :: arg1
    REAL(kind=realtype), DIMENSION(3) :: arg1b
    REAL(kind=realtype) :: tempb0
    REAL(kind=realtype) :: tempb(3)
    IF (alphap0 .GT. alphap0*(eta-3)/numlayers) THEN
      alphap = alphap0*(eta-3)/numlayers
    ELSE
      alphap = alphap0
    END IF
    rout = r
! This function does the grid smoothing
! Loop over the desired number of smoothing passes
    DO index_pass=1,numsmoothingpasses
! Copy nodes
      r_smooth = rout
! Smooth every node
      DO index=2,n-1
! Get coordinates
        r_curr = rout(3*(index-1)+1:3*(index-1)+3)
        r_next = rout(3*index+1:3*index+3)
        r_prev = rout(3*(index-2)+1:3*(index-2)+3)
! Compute distances
        arg1(:) = r_next - r_curr
        CALL PUSHREAL8ARRAY(lp, realtype/8)
        CALL NORM(arg1(:), lp)
        arg1(:) = r_curr - r_prev
        CALL PUSHREAL8ARRAY(lm, realtype/8)
        CALL NORM(arg1(:), lm)
! Compute smoothed coordinates
        r_smooth(3*(index-1)+1:3*(index-1)+3) = (1.-alphap)*r_curr + &
&         alphap*(lm*r_next+lp*r_prev)/(lp+lm)
      END DO
! Copy coordinates to allow next pass
      CALL PUSHREAL8ARRAY(rout, realtype*3*n/8)
      rout = r_smooth
    END DO
    DO index_pass=numsmoothingpasses,1,-1
      r_smoothb = 0.0_8
      CALL POPREAL8ARRAY(rout, realtype*3*n/8)
      r_smoothb = routb
      routb = 0.0_8
      DO index=n-1,2,-1
        r_curr = rout(3*(index-1)+1:3*(index-1)+3)
        r_prev = rout(3*(index-2)+1:3*(index-2)+3)
        r_next = rout(3*index+1:3*index+3)
        r_currb = 0.0_8
        r_prevb = 0.0_8
        r_nextb = 0.0_8
        tempb = alphap*r_smoothb(3*(index-1)+1:3*(index-1)+3)/(lp+lm)
        tempb0 = SUM(-((lm*r_next+lp*r_prev)*tempb/(lp+lm)))
        lmb = tempb0 + SUM(r_next*tempb)
        r_nextb = lm*tempb
        lpb = tempb0 + SUM(r_prev*tempb)
        arg1(:) = r_curr - r_prev
        CALL POPREAL8ARRAY(lm, realtype/8)
        CALL NORM_B0(arg1(:), arg1b(:), lm, lmb)
        r_currb = arg1b(:) + (1.-alphap)*r_smoothb(3*(index-1)+1:3*(&
&         index-1)+3)
        r_prevb = lp*tempb - arg1b(:)
        r_smoothb(3*(index-1)+1:3*(index-1)+3) = 0.0_8
        arg1(:) = r_next - r_curr
        CALL POPREAL8ARRAY(lp, realtype/8)
        CALL NORM_B0(arg1(:), arg1b(:), lp, lpb)
        r_nextb = r_nextb + arg1b
        r_currb = r_currb - arg1b
        routb(3*(index-2)+1:3*(index-2)+3) = routb(3*(index-2)+1:3*(&
&         index-2)+3) + r_prevb
        routb(3*index+1:3*index+3) = routb(3*index+1:3*index+3) + &
&         r_nextb
        routb(3*(index-1)+1:3*(index-1)+3) = routb(3*(index-1)+1:3*(&
&         index-1)+3) + r_currb
      END DO
      routb = routb + r_smoothb
    END DO
    rb = 0.0_8
    rb = routb
    routb = 0.0_8
  END SUBROUTINE SMOOTHING_MAIN_B
  SUBROUTINE SMOOTHING_MAIN(r, eta, alphap0, numsmoothingpasses, &
&   numlayers, n, rout)
    IMPLICIT NONE
    INTEGER(kind=inttype), INTENT(IN) :: n
    REAL(kind=realtype), INTENT(IN) :: eta, alphap0
    INTEGER(kind=inttype), INTENT(IN) :: numsmoothingpasses, numlayers
    REAL(kind=realtype), INTENT(IN) :: r(3*n)
    REAL(kind=realtype), INTENT(OUT) :: rout(3*n)
    REAL(kind=realtype) :: r_next(3), r_curr(3), r_prev(3), lp, lm, &
&   alphap
    REAL(kind=realtype) :: r_smooth(3*n)
    INTEGER(kind=inttype) :: index, index_pass
    INTRINSIC MIN
    REAL(kind=realtype), DIMENSION(3) :: arg1
    IF (alphap0 .GT. alphap0*(eta-3)/numlayers) THEN
      alphap = alphap0*(eta-3)/numlayers
    ELSE
      alphap = alphap0
    END IF
    rout = r
! This function does the grid smoothing
! Loop over the desired number of smoothing passes
    DO index_pass=1,numsmoothingpasses
! Copy nodes
      r_smooth = rout
! Smooth every node
      DO index=2,n-1
! Get coordinates
        r_curr = rout(3*(index-1)+1:3*(index-1)+3)
        r_next = rout(3*index+1:3*index+3)
        r_prev = rout(3*(index-2)+1:3*(index-2)+3)
! Compute distances
        arg1(:) = r_next - r_curr
        CALL NORM(arg1(:), lp)
        arg1(:) = r_curr - r_prev
        CALL NORM(arg1(:), lm)
! Compute smoothed coordinates
        r_smooth(3*(index-1)+1:3*(index-1)+3) = (1.-alphap)*r_curr + &
&         alphap*(lm*r_next+lp*r_prev)/(lp+lm)
      END DO
! Copy coordinates to allow next pass
      rout = r_smooth
    END DO
  END SUBROUTINE SMOOTHING_MAIN
  SUBROUTINE QUALITYCHECK(r, layerindex, numlayers, numnodes, fail, &
&   ratios)
    IMPLICIT NONE
    INTEGER(kind=inttype), INTENT(IN) :: numlayers, numnodes
    INTEGER(kind=inttype), INTENT(IN), OPTIONAL :: layerindex
    REAL(kind=realtype), INTENT(IN) :: r(numlayers, 3*numnodes)
    REAL(kind=realtype), INTENT(OUT) :: ratios(numlayers-1, numnodes-1)
    INTEGER(kind=inttype), INTENT(OUT) :: fail
    REAL(kind=realtype) :: xyz(3, numlayers, numnodes), nodalnormals(3, &
&   numlayers, numnodes)
    REAL(kind=realtype) :: panelnormals(3, numlayers-1, numnodes-1), &
&   norm_vec(3)
    REAL(kind=realtype) :: vec1(3, numlayers-1, numnodes-1), vec2(3, &
&   numlayers-1, numnodes-1)
    REAL(kind=realtype) :: vec3(3, numlayers-2, numnodes-2), vec4(3, &
&   numlayers-2, numnodes-2)
    REAL(kind=realtype) :: nodalderivs(3, 2, numlayers, numnodes), det(&
&   numlayers, numnodes)
    REAL(kind=realtype) :: normals(3, numlayers-2, numnodes-2), &
&   nodaljacs(3, 3, numlayers, numnodes), norm_val
    INTEGER(kind=inttype) :: i, j
    REAL(kind=realtype) :: zero
    INTRINSIC MINVAL
    INTRINSIC MAXVAL
    REAL :: result1
    REAL :: result2
    REAL :: result10
    zero = 0.
! Convert the flattened array R into a 3 x numNodes x numLayers array.
! numLayers -> number of layers in the marching direction
! numNodes -> number of nodes in direction of curve
    DO i=1,numnodes
      xyz(1, :, i) = r(:, 3*(i-1)+1)
      xyz(2, :, i) = r(:, 3*(i-1)+2)
      xyz(3, :, i) = r(:, 3*(i-1)+3)
    END DO
! Setup nodal normals
    nodalnormals(:, :, :) = zero
! Get the panel normals from the interior points of the mesh.
! Here we take the cross product of the diagonals of each face
    vec1 = xyz(:, 2:, 2:) - xyz(:, :numlayers-1, :numnodes-1)
    vec2 = xyz(:, 2:, :numnodes-1) - xyz(:, :numlayers-1, 2:)
    DO i=1,numnodes-1
      DO j=1,numlayers-1
        CALL CROSS(vec2(:, j, i), vec1(:, j, i), norm_vec)
        CALL NORM(norm_vec, norm_val)
        panelnormals(:, j, i) = norm_vec/norm_val
      END DO
    END DO
! Set the interior normals using an average of the panel normals
    vec3 = panelnormals(:, 2:, 2:) + panelnormals(:, :numlayers-2, :&
&     numnodes-2)
    vec4 = panelnormals(:, 2:, :numnodes-2) + panelnormals(:, :numlayers&
&     -2, 2:)
    normals = vec3 + vec4
    DO i=2,numnodes-1
      DO j=2,numlayers-1
        CALL NORM(normals(:, j-1, i-1), norm_val)
        nodalnormals(:, j, i) = normals(:, j-1, i-1)/norm_val
      END DO
    END DO
! Set the boundary normals
    nodalnormals(:, 2:, 1) = panelnormals(:, :, 1)
    nodalnormals(:, 1, :numnodes-1) = panelnormals(:, 1, :)
    nodalnormals(:, :numlayers-1, numnodes) = panelnormals(:, :, &
&     numnodes-1)
    nodalnormals(:, numlayers, 2:) = panelnormals(:, numlayers-1, :)
! Setup nodal derivatives
    nodalderivs(:, :, :, :) = zero
! Compute interior derivatives using 2nd order central differencing
    nodalderivs(:, 1, 2:numlayers-1, 2:numnodes-1) = (xyz(:, 3:, 2:&
&     numnodes-1)-xyz(:, :numlayers-2, 2:numnodes-1))/2.
    nodalderivs(:, 2, 2:numlayers-1, 2:numnodes-1) = (xyz(:, 2:numlayers&
&     -1, 3:)-xyz(:, 2:numlayers-1, :numnodes-2))/2.
! Compute i derivatives using 1st order differencing
    nodalderivs(:, 1, 1, :) = xyz(:, 2, :) - xyz(:, 1, :)
    nodalderivs(:, 1, numlayers, :) = xyz(:, numlayers, :) - xyz(:, &
&     numlayers-1, :)
    nodalderivs(:, 1, 2:numlayers-1, 1) = (xyz(:, 3:, 1)-xyz(:, :&
&     numlayers-2, 1))/2.
    nodalderivs(:, 1, 2:numlayers-1, numnodes) = (xyz(:, 3:, numnodes)-&
&     xyz(:, :numlayers-2, numnodes))/2.
! Compute j derivatives using 1st order differencing
    nodalderivs(:, 2, :, 1) = xyz(:, :, 2) - xyz(:, :, 1)
    nodalderivs(:, 2, :, numnodes) = xyz(:, :, numnodes) - xyz(:, :, &
&     numnodes-1)
    nodalderivs(:, 2, 1, 2:numnodes-1) = (xyz(:, 1, 3:)-xyz(:, 1, :&
&     numnodes-2))/2.
    nodalderivs(:, 2, numlayers, 2:numnodes-1) = (xyz(:, numlayers, 3:)-&
&     xyz(:, numlayers, :numnodes-2))/2.
! Assemble nodal Jacobians
    nodaljacs(:, :, :, :) = zero
    nodaljacs(1, :, :, :) = nodalderivs(:, 1, :, :)
    nodaljacs(2, :, :, :) = nodalderivs(:, 2, :, :)
    nodaljacs(3, :, :, :) = nodalnormals(:, :, :)
! Compute determinants of Jacobians and find ratio of min to max per face
    ratios(:, :) = zero
! Compute the determinants of each nodal Jacobian
    DO i=1,numnodes
      DO j=1,numlayers
        CALL M33DET(nodaljacs(:, :, j, i), det(j, i))
      END DO
    END DO
! Find the ratio of the minimum valued determinant to the maximum
! valued determinant.
! This is a measure of quality, with 1 being desirable and anything
! less than 0 meaning the mesh is no longer valid.
    DO i=1,numnodes-1
      DO j=1,numlayers-1
        result1 = MINVAL(det(j:j+1, i:i+1))
        result2 = MAXVAL(det(j:j+1, i:i+1))
        ratios(j, i) = result1/result2
      END DO
    END DO
    fail = 0
! Throw an error and set the failure flag if the mesh is not valid
    DO i=1,numnodes-1
      DO j=1,numlayers-1
        IF ((ratios(j, i) .NE. ratios(j, i) .OR. ratios(j, i) .LE. zero)&
&           .AND. layerindex .GE. 1) THEN
          PRINT*, '========FAIL============'
          fail = 1
        END IF
      END DO
    END DO
    IF (fail .EQ. 1) PRINT*, 'The mesh is not valid after step', &
&                    layerindex + 1
! Throw a warning if the mesh is low quality
    result10 = MINVAL(ratios)
    IF (result10 .LE. .2 .AND. layerindex .GE. 1) PRINT*, &
&                               'The mesh may be low quality after step'&
&                                                 , layerindex + 1
  END SUBROUTINE QUALITYCHECK
!  Differentiation of findradius in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: radius
!   with respect to varying inputs: radius r
!   RW status of diff variables: radius:in-zero r:out
  SUBROUTINE FINDRADIUS_B(r, rb, numnodes, radius, radiusb)
    IMPLICIT NONE
    INTEGER(kind=inttype), INTENT(IN) :: numnodes
    REAL(kind=realtype), INTENT(IN) :: r(3*numnodes)
    REAL(kind=realtype) :: rb(3*numnodes)
    REAL(kind=realtype) :: radius
    REAL(kind=realtype) :: radiusb
    REAL(kind=realtype) :: x, y, z
    REAL(kind=realtype) :: xb, yb, zb
    REAL(kind=realtype) :: minx, maxx, miny, maxy, minz, maxz
    REAL(kind=realtype) :: minxb, maxxb, minyb, maxyb, minzb, maxzb
    INTEGER(kind=inttype) :: i
    INTEGER :: branch
    minx = 1.e20
    miny = 1.e20
    minz = 1.e20
    maxx = -1.e20
    maxy = -1.e20
    maxz = -1.e20
! Split coordinates and find max and min values
    DO i=1,numnodes
      x = r(3*(i-1)+1)
      IF (x .GT. maxx) THEN
        maxx = x
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (x .LT. minx) THEN
        minx = x
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      y = r(3*(i-1)+2)
      IF (y .GT. maxy) THEN
        maxy = y
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (y .LT. miny) THEN
        miny = y
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      z = r(3*(i-1)+3)
      IF (z .GT. maxz) THEN
        maxz = z
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (z .LT. minz) THEN
        minz = z
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
! Find largest radius (we give only half of the largest side to be considered as radius)
    radius = -1.e20
    IF (maxx - minx .GT. radius) THEN
      radius = maxx - minx
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (maxy - miny .GT. radius) THEN
      radius = maxy - miny
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (maxz - minz .GT. radius) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    radiusb = radiusb/2.
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      maxzb = radiusb
      minzb = -radiusb
      radiusb = 0.0_8
    ELSE
      minzb = 0.0_8
      maxzb = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      maxyb = radiusb
      minyb = -radiusb
      radiusb = 0.0_8
    ELSE
      minyb = 0.0_8
      maxyb = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      maxxb = radiusb
      minxb = -radiusb
    ELSE
      minxb = 0.0_8
      maxxb = 0.0_8
    END IF
    rb = 0.0_8
    DO i=numnodes,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        zb = 0.0_8
      ELSE
        zb = minzb
        minzb = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        zb = zb + maxzb
        maxzb = 0.0_8
      END IF
      rb(3*(i-1)+3) = rb(3*(i-1)+3) + zb
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        yb = minyb
        minyb = 0.0_8
      ELSE
        yb = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        yb = yb + maxyb
        maxyb = 0.0_8
      END IF
      rb(3*(i-1)+2) = rb(3*(i-1)+2) + yb
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        xb = minxb
        minxb = 0.0_8
      ELSE
        xb = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        xb = xb + maxxb
        maxxb = 0.0_8
      END IF
      rb(3*(i-1)+1) = rb(3*(i-1)+1) + xb
    END DO
    radiusb = 0.0_8
  END SUBROUTINE FINDRADIUS_B
  SUBROUTINE FINDRADIUS(r, numnodes, radius)
    IMPLICIT NONE
    INTEGER(kind=inttype), INTENT(IN) :: numnodes
    REAL(kind=realtype), INTENT(IN) :: r(3*numnodes)
    REAL(kind=realtype), INTENT(OUT) :: radius
    REAL(kind=realtype) :: x, y, z
    REAL(kind=realtype) :: minx, maxx, miny, maxy, minz, maxz
    INTEGER(kind=inttype) :: i
    minx = 1.e20
    miny = 1.e20
    minz = 1.e20
    maxx = -1.e20
    maxy = -1.e20
    maxz = -1.e20
! Split coordinates and find max and min values
    DO i=1,numnodes
      x = r(3*(i-1)+1)
      IF (x .GT. maxx) maxx = x
      IF (x .LT. minx) minx = x
      y = r(3*(i-1)+2)
      IF (y .GT. maxy) maxy = y
      IF (y .LT. miny) miny = y
      z = r(3*(i-1)+3)
      IF (z .GT. maxz) maxz = z
      IF (z .LT. minz) minz = z
    END DO
! Find largest radius (we give only half of the largest side to be considered as radius)
    radius = -1.e20
    IF (maxx - minx .GT. radius) radius = maxx - minx
    IF (maxy - miny .GT. radius) radius = maxy - miny
    IF (maxz - minz .GT. radius) radius = maxz - minz
    radius = radius/2.
  END SUBROUTINE FINDRADIUS
!  Differentiation of findratio in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: q
!   with respect to varying inputs: q d0 dmax
!   RW status of diff variables: q:in-zero d0:out dmax:out
  SUBROUTINE FINDRATIO_B(dmax, dmaxb, d0, d0b, numlayers, ratioguess, q&
&   , qb)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: dmax, d0, ratioguess
    REAL(kind=realtype) :: dmaxb, d0b
    INTEGER(kind=inttype), INTENT(IN) :: numlayers
    REAL(kind=realtype) :: q
    REAL(kind=realtype) :: qb
    REAL(kind=realtype) :: rdot, r
    REAL(kind=realtype) :: rdotb, rb
    INTEGER(kind=inttype) :: niters, i
    INTEGER :: ad_to
! Extra parameters
! Maximum number of iterations for Newton search
    niters = 200
! Initialize ratio
    q = ratioguess
! Newton search loop
    DO i=1,niters
! Residual function
      CALL PUSHREAL8ARRAY(r, realtype/8)
      r = d0*(1.-q**(numlayers-1)) - dmax*(1.-q)
! Residual derivative
      CALL PUSHREAL8ARRAY(rdot, realtype/8)
      rdot = -((numlayers-1)*d0*q**(numlayers-2)) + dmax
! Update ratio with Newton search
      CALL PUSHREAL8ARRAY(q, realtype/8)
      q = q - r/rdot
    END DO
    CALL PUSHINTEGER4ARRAY(i - 1, inttype/4)
! Check if we got a reasonable value
    IF (q .LE. 1 .OR. q .GE. ratioguess) THEN
      STOP
    ELSE
      d0b = 0.0_8
      dmaxb = 0.0_8
      CALL POPINTEGER4(ad_to)
      DO i=ad_to,1,-1
        CALL POPREAL8ARRAY(q, realtype/8)
        rb = -(qb/rdot)
        rdotb = r*qb/rdot**2
        CALL POPREAL8ARRAY(rdot, realtype/8)
        dmaxb = dmaxb + rdotb - (1.-q)*rb
        d0b = d0b + (1.-q**(numlayers-1))*rb - (numlayers-1)*q**(&
&         numlayers-2)*rdotb
        IF (.NOT.(q .LE. 0.0_8 .AND. (numlayers - 2 .EQ. 0.0_8 .OR. &
&           numlayers - 2 .NE. INT(numlayers - 2)))) qb = qb - d0*(&
&           numlayers-1)*(numlayers-2)*q**(numlayers-3)*rdotb
        CALL POPREAL8ARRAY(r, realtype/8)
        IF (q .LE. 0.0_8 .AND. (numlayers - 1 .EQ. 0.0_8 .OR. numlayers &
&           - 1 .NE. INT(numlayers - 1))) THEN
          qb = qb + dmax*rb
        ELSE
          qb = qb + (dmax-d0*(numlayers-1)*q**(numlayers-2))*rb
        END IF
      END DO
      qb = 0.0_8
    END IF
  END SUBROUTINE FINDRATIO_B
  SUBROUTINE FINDRATIO(dmax, d0, numlayers, ratioguess, q)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: dmax, d0, ratioguess
    INTEGER(kind=inttype), INTENT(IN) :: numlayers
    REAL(kind=realtype), INTENT(OUT) :: q
    REAL(kind=realtype) :: rdot, r
    INTEGER(kind=inttype) :: niters, i
! Extra parameters
! Maximum number of iterations for Newton search
    niters = 200
! Initialize ratio
    q = ratioguess
! Newton search loop
    DO i=1,niters
! Residual function
      r = d0*(1.-q**(numlayers-1)) - dmax*(1.-q)
! Residual derivative
      rdot = -((numlayers-1)*d0*q**(numlayers-2)) + dmax
! Update ratio with Newton search
      q = q - r/rdot
    END DO
! Check if we got a reasonable value
    IF (q .LE. 1 .OR. q .GE. ratioguess) THEN
      PRINT*, ''
      PRINT*, ''
      STOP
    END IF
  END SUBROUTINE FINDRATIO
!  Differentiation of matinv3 in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: b
!   with respect to varying inputs: a
  SUBROUTINE MATINV3_B(a, ab, b, bb)
    IMPLICIT NONE
!! Performs a direct calculation of the inverse of a 33 matrix.
!! Matrix
    REAL(kind=realtype), INTENT(IN) :: a(3, 3)
    REAL(kind=realtype) :: ab(3, 3)
!! Inverse matrix
    REAL(kind=realtype) :: b(3, 3)
    REAL(kind=realtype) :: bb(3, 3)
    REAL(kind=realtype) :: detinv
    REAL(kind=realtype) :: detinvb
    REAL(kind=realtype) :: temp3
    REAL(kind=realtype) :: temp2
    REAL(kind=realtype) :: temp1
    REAL(kind=realtype) :: temp0
    REAL(kind=realtype) :: tempb8
    REAL(kind=realtype) :: tempb7
    REAL(kind=realtype) :: tempb6
    REAL(kind=realtype) :: tempb5
    REAL(kind=realtype) :: tempb4
    REAL(kind=realtype) :: tempb3
    REAL(kind=realtype) :: tempb2
    REAL(kind=realtype) :: tempb1
    REAL(kind=realtype) :: tempb0
    REAL(kind=realtype) :: tempb
    REAL(kind=realtype) :: temp
    REAL(kind=realtype) :: temp5
    REAL(kind=realtype) :: temp4
!f2py intent(in) A
!f2py intent(out) B
! Calculate the inverse determinant of the matrix
    detinv = 1/(a(1, 1)*a(2, 2)*a(3, 3)-a(1, 1)*a(2, 3)*a(3, 2)-a(1, 2)*&
&     a(2, 1)*a(3, 3)+a(1, 2)*a(2, 3)*a(3, 1)+a(1, 3)*a(2, 1)*a(3, 2)-a(&
&     1, 3)*a(2, 2)*a(3, 1))
! Calculate the inverse of the matrix
    ab = 0.0_8
    tempb = detinv*bb(3, 3)
    detinvb = (a(1, 1)*a(2, 2)-a(1, 2)*a(2, 1))*bb(3, 3)
    ab(1, 1) = ab(1, 1) + a(2, 2)*tempb
    ab(2, 2) = ab(2, 2) + a(1, 1)*tempb
    ab(1, 2) = ab(1, 2) - a(2, 1)*tempb
    ab(2, 1) = ab(2, 1) - a(1, 2)*tempb
    bb(3, 3) = 0.0_8
    tempb0 = -(detinv*bb(2, 3))
    detinvb = detinvb - (a(1, 1)*a(2, 3)-a(1, 3)*a(2, 1))*bb(2, 3)
    ab(1, 1) = ab(1, 1) + a(2, 3)*tempb0
    ab(2, 3) = ab(2, 3) + a(1, 1)*tempb0
    ab(1, 3) = ab(1, 3) - a(2, 1)*tempb0
    ab(2, 1) = ab(2, 1) - a(1, 3)*tempb0
    bb(2, 3) = 0.0_8
    tempb1 = detinv*bb(1, 3)
    detinvb = detinvb + (a(1, 2)*a(2, 3)-a(1, 3)*a(2, 2))*bb(1, 3)
    ab(1, 2) = ab(1, 2) + a(2, 3)*tempb1
    ab(2, 3) = ab(2, 3) + a(1, 2)*tempb1
    ab(1, 3) = ab(1, 3) - a(2, 2)*tempb1
    ab(2, 2) = ab(2, 2) - a(1, 3)*tempb1
    bb(1, 3) = 0.0_8
    tempb2 = -(detinv*bb(3, 2))
    detinvb = detinvb - (a(1, 1)*a(3, 2)-a(1, 2)*a(3, 1))*bb(3, 2)
    ab(1, 1) = ab(1, 1) + a(3, 2)*tempb2
    ab(3, 2) = ab(3, 2) + a(1, 1)*tempb2
    ab(1, 2) = ab(1, 2) - a(3, 1)*tempb2
    ab(3, 1) = ab(3, 1) - a(1, 2)*tempb2
    bb(3, 2) = 0.0_8
    tempb3 = detinv*bb(2, 2)
    detinvb = detinvb + (a(1, 1)*a(3, 3)-a(1, 3)*a(3, 1))*bb(2, 2)
    ab(1, 1) = ab(1, 1) + a(3, 3)*tempb3
    ab(3, 3) = ab(3, 3) + a(1, 1)*tempb3
    ab(1, 3) = ab(1, 3) - a(3, 1)*tempb3
    ab(3, 1) = ab(3, 1) - a(1, 3)*tempb3
    bb(2, 2) = 0.0_8
    tempb4 = -(detinv*bb(1, 2))
    detinvb = detinvb - (a(1, 2)*a(3, 3)-a(1, 3)*a(3, 2))*bb(1, 2)
    ab(1, 2) = ab(1, 2) + a(3, 3)*tempb4
    ab(3, 3) = ab(3, 3) + a(1, 2)*tempb4
    ab(1, 3) = ab(1, 3) - a(3, 2)*tempb4
    ab(3, 2) = ab(3, 2) - a(1, 3)*tempb4
    bb(1, 2) = 0.0_8
    tempb5 = detinv*bb(3, 1)
    detinvb = detinvb + (a(2, 1)*a(3, 2)-a(2, 2)*a(3, 1))*bb(3, 1)
    ab(2, 1) = ab(2, 1) + a(3, 2)*tempb5
    ab(3, 2) = ab(3, 2) + a(2, 1)*tempb5
    ab(2, 2) = ab(2, 2) - a(3, 1)*tempb5
    ab(3, 1) = ab(3, 1) - a(2, 2)*tempb5
    bb(3, 1) = 0.0_8
    tempb6 = -(detinv*bb(2, 1))
    detinvb = detinvb - (a(2, 1)*a(3, 3)-a(2, 3)*a(3, 1))*bb(2, 1)
    ab(2, 1) = ab(2, 1) + a(3, 3)*tempb6
    ab(3, 3) = ab(3, 3) + a(2, 1)*tempb6
    ab(2, 3) = ab(2, 3) - a(3, 1)*tempb6
    ab(3, 1) = ab(3, 1) - a(2, 3)*tempb6
    bb(2, 1) = 0.0_8
    tempb7 = detinv*bb(1, 1)
    detinvb = detinvb + (a(2, 2)*a(3, 3)-a(2, 3)*a(3, 2))*bb(1, 1)
    ab(2, 2) = ab(2, 2) + a(3, 3)*tempb7
    ab(3, 3) = ab(3, 3) + a(2, 2)*tempb7
    ab(2, 3) = ab(2, 3) - a(3, 2)*tempb7
    ab(3, 2) = ab(3, 2) - a(2, 3)*tempb7
    temp5 = a(1, 3)*a(2, 2)
    temp4 = a(1, 3)*a(2, 1)
    temp3 = a(1, 2)*a(2, 3)
    temp2 = a(1, 2)*a(2, 1)
    temp1 = a(1, 1)*a(2, 3)
    temp0 = a(1, 1)*a(2, 2)
    temp = temp0*a(3, 3) - temp1*a(3, 2) - temp2*a(3, 3) + temp3*a(3, 1)&
&     + temp4*a(3, 2) - temp5*a(3, 1)
    tempb8 = -(detinvb/temp**2)
    ab(1, 1) = ab(1, 1) + (a(3, 3)*a(2, 2)-a(3, 2)*a(2, 3))*tempb8
    ab(2, 2) = ab(2, 2) + (a(3, 3)*a(1, 1)-a(3, 1)*a(1, 3))*tempb8
    ab(3, 3) = ab(3, 3) + (temp0-temp2)*tempb8
    ab(2, 3) = ab(2, 3) + (a(3, 1)*a(1, 2)-a(3, 2)*a(1, 1))*tempb8
    ab(3, 2) = ab(3, 2) + (temp4-temp1)*tempb8
    ab(1, 2) = ab(1, 2) + (a(3, 1)*a(2, 3)-a(3, 3)*a(2, 1))*tempb8
    ab(2, 1) = ab(2, 1) + (a(3, 2)*a(1, 3)-a(3, 3)*a(1, 2))*tempb8
    ab(3, 1) = ab(3, 1) + (temp3-temp5)*tempb8
    ab(1, 3) = ab(1, 3) + (a(3, 2)*a(2, 1)-a(3, 1)*a(2, 2))*tempb8
  END SUBROUTINE MATINV3_B
  SUBROUTINE MATINV3(a, b)
    IMPLICIT NONE
!! Performs a direct calculation of the inverse of a 33 matrix.
!! Matrix
    REAL(kind=realtype), INTENT(IN) :: a(3, 3)
!! Inverse matrix
    REAL(kind=realtype), INTENT(OUT) :: b(3, 3)
    REAL(kind=realtype) :: detinv
!f2py intent(in) A
!f2py intent(out) B
! Calculate the inverse determinant of the matrix
    detinv = 1/(a(1, 1)*a(2, 2)*a(3, 3)-a(1, 1)*a(2, 3)*a(3, 2)-a(1, 2)*&
&     a(2, 1)*a(3, 3)+a(1, 2)*a(2, 3)*a(3, 1)+a(1, 3)*a(2, 1)*a(3, 2)-a(&
&     1, 3)*a(2, 2)*a(3, 1))
! Calculate the inverse of the matrix
    b(1, 1) = detinv*(a(2, 2)*a(3, 3)-a(2, 3)*a(3, 2))
    b(2, 1) = -(detinv*(a(2, 1)*a(3, 3)-a(2, 3)*a(3, 1)))
    b(3, 1) = detinv*(a(2, 1)*a(3, 2)-a(2, 2)*a(3, 1))
    b(1, 2) = -(detinv*(a(1, 2)*a(3, 3)-a(1, 3)*a(3, 2)))
    b(2, 2) = detinv*(a(1, 1)*a(3, 3)-a(1, 3)*a(3, 1))
    b(3, 2) = -(detinv*(a(1, 1)*a(3, 2)-a(1, 2)*a(3, 1)))
    b(1, 3) = detinv*(a(1, 2)*a(2, 3)-a(1, 3)*a(2, 2))
    b(2, 3) = -(detinv*(a(1, 1)*a(2, 3)-a(1, 3)*a(2, 1)))
    b(3, 3) = detinv*(a(1, 1)*a(2, 2)-a(1, 2)*a(2, 1))
  END SUBROUTINE MATINV3
!  Differentiation of giveangle in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: angle r0 r1 r2
!   with respect to varying inputs: r0 r1 r2
  SUBROUTINE GIVEANGLE_B(r0, r0b, r1, r1b, r2, r2b, n1, angle, angleb)
    IMPLICIT NONE
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: r0, r1, r2, n1
    REAL(kind=realtype), DIMENSION(3) :: r0b, r1b, r2b
!f2py intent(in) r0, r1, r2, N1
!f2py intent(out) angle
    REAL(kind=realtype), DIMENSION(3) :: dr1, dr2, dr1crossdr2
    REAL(kind=realtype), DIMENSION(3) :: dr1b, dr2b
    REAL(kind=realtype) :: dr1dotdr2, arccos_inside, pi, one, angle, tmp
    REAL(kind=realtype) :: dr1dotdr2b, arccos_insideb, angleb
    REAL(kind=realtype) :: normdr1, normdr2, dr1crossdr2dotn1
    REAL(kind=realtype) :: normdr1b, normdr2b
    INTRINSIC MIN
    INTRINSIC DACOS
    INTEGER :: branch
    REAL(kind=realtype) :: min1
    REAL(kind=realtype) :: tempb0
    REAL(kind=realtype) :: min1b
    REAL(kind=realtype) :: tempb
    one = 1.0
    dr1 = r1 - r0
    dr2 = r2 - r1
    CALL DOT(dr1, dr2, dr1dotdr2)
! dot product
    CALL CROSS(dr1, dr2, dr1crossdr2)
! cross product
! Compute acute angle and ensure it's <= 1.0
    CALL NORM(dr1, normdr1)
    CALL NORM(dr2, normdr2)
    arccos_inside = dr1dotdr2/normdr1/normdr2
    IF (arccos_inside .GT. one) THEN
      min1 = one
      CALL PUSHCONTROL1B(0)
    ELSE
      min1 = arccos_inside
      CALL PUSHCONTROL1B(1)
    END IF
! If the cross product points in the same direction of the surface
! normal, we have an acute corner
    CALL DOT(dr1crossdr2, n1, dr1crossdr2dotn1)
    IF (dr1crossdr2dotn1 .LE. 0.) angleb = -angleb
    IF (min1 .EQ. 1.0 .OR. min1 .EQ. (-1.0)) THEN
      min1b = 0.0
    ELSE
      min1b = -(angleb/SQRT(1.D0-min1**2))
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      arccos_insideb = 0.0_8
    ELSE
      arccos_insideb = min1b
    END IF
    tempb = arccos_insideb/(normdr1*normdr2)
    tempb0 = -(dr1dotdr2*tempb/(normdr1*normdr2))
    dr1dotdr2b = tempb
    normdr1b = normdr2*tempb0
    normdr2b = normdr1*tempb0
    CALL NORM_B0(dr2, dr2b, normdr2, normdr2b)
    CALL NORM_B0(dr1, dr1b, normdr1, normdr1b)
    CALL DOT_B0(dr1, dr1b, dr2, dr2b, dr1dotdr2, dr1dotdr2b)
    r2b = r2b + dr2b
    r1b = r1b + dr1b - dr2b
    r0b = r0b - dr1b
  END SUBROUTINE GIVEANGLE_B
  SUBROUTINE GIVEANGLE(r0, r1, r2, n1, angle)
    IMPLICIT NONE
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: r0, r1, r2, n1
!f2py intent(in) r0, r1, r2, N1
!f2py intent(out) angle
    REAL(kind=realtype), DIMENSION(3) :: dr1, dr2, dr1crossdr2
    REAL(kind=realtype) :: dr1dotdr2, arccos_inside, pi, one, angle, tmp
    REAL(kind=realtype) :: normdr1, normdr2, dr1crossdr2dotn1
    INTRINSIC MIN
    INTRINSIC DACOS
    REAL(kind=realtype) :: min1
    pi = 3.14159265358979323846264338
    one = 1.0
    dr1 = r1 - r0
    dr2 = r2 - r1
    CALL DOT(dr1, dr2, dr1dotdr2)
! dot product
    CALL CROSS(dr1, dr2, dr1crossdr2)
! cross product
! Compute acute angle and ensure it's <= 1.0
    CALL NORM(dr1, normdr1)
    CALL NORM(dr2, normdr2)
    arccos_inside = dr1dotdr2/normdr1/normdr2
    IF (arccos_inside .GT. one) THEN
      min1 = one
    ELSE
      min1 = arccos_inside
    END IF
    angle = DACOS(min1)
! If the cross product points in the same direction of the surface
! normal, we have an acute corner
    CALL DOT(dr1crossdr2, n1, dr1crossdr2dotn1)
    IF (dr1crossdr2dotn1 .GT. 0.) THEN
      angle = pi + angle
    ELSE
      angle = pi - angle
    END IF
  END SUBROUTINE GIVEANGLE
!  Differentiation of dot in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: dot_ a b
!   with respect to varying inputs: a b
!============================================================
  SUBROUTINE DOT_B0(a, ab, b, bb, dot_, dot_b)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: a(3), b(3)
    REAL(kind=realtype) :: ab(3), bb(3)
    REAL(kind=realtype) :: dot_
    REAL(kind=realtype) :: dot_b
    ab(1) = ab(1) + b(1)*dot_b
    bb(1) = bb(1) + a(1)*dot_b
    ab(2) = ab(2) + b(2)*dot_b
    bb(2) = bb(2) + a(2)*dot_b
    ab(3) = ab(3) + b(3)*dot_b
    bb(3) = bb(3) + a(3)*dot_b
  END SUBROUTINE DOT_B0
!============================================================
  SUBROUTINE DOT(a, b, dot_)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: a(3), b(3)
    REAL(kind=realtype), INTENT(OUT) :: dot_
    dot_ = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
  END SUBROUTINE DOT
!  Differentiation of norm in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: norm_
!   with respect to varying inputs: a
!============================================================
  SUBROUTINE NORM_B0(a, ab, norm_, norm_b)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: a(3)
    REAL(kind=realtype) :: ab(3)
    REAL(kind=realtype) :: norm_
    REAL(kind=realtype) :: norm_b
    INTRINSIC DSQRT
    REAL(kind=realtype) :: tempb
    ab = 0.0_8
    IF (a(1)**2 + a(2)**2 + a(3)**2 .EQ. 0.0_8) THEN
      tempb = 0.0
    ELSE
      tempb = norm_b/(2.D0*DSQRT(a(1)**2+a(2)**2+a(3)**2))
    END IF
    ab(1) = ab(1) + 2*a(1)*tempb
    ab(2) = ab(2) + 2*a(2)*tempb
    ab(3) = ab(3) + 2*a(3)*tempb
  END SUBROUTINE NORM_B0
!============================================================
  SUBROUTINE NORM(a, norm_)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: a(3)
    REAL(kind=realtype), INTENT(OUT) :: norm_
    INTRINSIC DSQRT
    norm_ = DSQRT(a(1)*a(1) + a(2)*a(2) + a(3)*a(3))
  END SUBROUTINE NORM
!  Differentiation of cross in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: a b c
!   with respect to varying inputs: a b c
  SUBROUTINE CROSS_B(a, ab, b, bb, c, cb)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: a(3), b(3)
    REAL(kind=realtype) :: ab(3), bb(3)
    REAL(kind=realtype) :: c(3)
    REAL(kind=realtype) :: cb(3)
    ab(1) = ab(1) + b(2)*cb(3)
    bb(2) = bb(2) + a(1)*cb(3)
    ab(2) = ab(2) - b(1)*cb(3)
    bb(1) = bb(1) - a(2)*cb(3)
    cb(3) = 0.0_8
    ab(3) = ab(3) + b(1)*cb(2)
    bb(1) = bb(1) + a(3)*cb(2)
    ab(1) = ab(1) - b(3)*cb(2)
    bb(3) = bb(3) - a(1)*cb(2)
    cb(2) = 0.0_8
    ab(2) = ab(2) + b(3)*cb(1)
    bb(3) = bb(3) + a(2)*cb(1)
    ab(3) = ab(3) - b(2)*cb(1)
    bb(2) = bb(2) - a(3)*cb(1)
    cb(1) = 0.0_8
  END SUBROUTINE CROSS_B
  SUBROUTINE CROSS(a, b, c)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: a(3), b(3)
    REAL(kind=realtype), INTENT(OUT) :: c(3)
    c(1) = a(2)*b(3) - a(3)*b(2)
    c(2) = a(3)*b(1) - a(1)*b(3)
    c(3) = a(1)*b(2) - a(2)*b(1)
  END SUBROUTINE CROSS
  SUBROUTINE M33DET(a, det)
    IMPLICIT NONE
    REAL(kind=realtype), DIMENSION(3, 3), INTENT(IN) :: a
    REAL(kind=realtype), INTENT(OUT) :: det
    det = a(1, 1)*a(2, 2)*a(3, 3) - a(1, 1)*a(2, 3)*a(3, 2) - a(1, 2)*a(&
&     2, 1)*a(3, 3) + a(1, 2)*a(2, 3)*a(3, 1) + a(1, 3)*a(2, 1)*a(3, 2) &
&     - a(1, 3)*a(2, 2)*a(3, 1)
  END SUBROUTINE M33DET
END MODULE HYPSURFMAIN_B
