!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!
!     ******************************************************************
!     *                                                                *
!     * file:          hypsurfmain.f90                                 *
!     * authors:       john jasa and ney secco                         *
!     * starting date: 08-11-2016                                      *
!     * last modified: 09-25-2016                                      *
!     *                                                                *
!     ******************************************************************
!
!
!     ******************************************************************
!     *                                                                *
!     * contains subroutines for hyperbolic surface mesh generation.   *
!     *                                                                *
!     ******************************************************************
!
module hypsurfmain_d
  use precision
  implicit none

contains
!  differentiation of computematrices_main in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: f
!   with respect to varying inputs: s0 sm1 n0 rm1 r0
!   rw status of diff variables: f:out s0:in sm1:in n0:in rm1:in
!                r0:in
!=================================================================
!=================================================================
  subroutine computematrices_main_d(r0, r0d, n0, n0d, s0, s0d, rm1, rm1d&
&   , sm1, sm1d, layerindex, theta, sigmasplay, bc1, bc2, numlayers, &
&   epse0, guideindices, retainspacing, f, fd, numnodes, numguides)
    use solveroutines, only : solve_d
    implicit none
    integer(kind=inttype), intent(in) :: layerindex, numnodes, numlayers
    real(kind=realtype), intent(in) :: r0(3*numnodes), n0(3, numnodes), &
&   s0(numnodes)
    real(kind=realtype), intent(in) :: r0d(3*numnodes), n0d(3, numnodes)&
&   , s0d(numnodes)
    real(kind=realtype), intent(in) :: rm1(3*numnodes), sm1(numnodes), &
&   theta
    real(kind=realtype), intent(in) :: rm1d(3*numnodes), sm1d(numnodes)
    real(kind=realtype), intent(in) :: sigmasplay, epse0
    character(len=32), intent(in) :: bc1, bc2
    real(kind=realtype), intent(out) :: f(3*numnodes)
    real(kind=realtype), intent(out) :: fd(3*numnodes)
    integer(kind=inttype), intent(in) :: numguides
    integer(kind=inttype), intent(in) :: guideindices(numguides)
    logical, intent(in) :: retainspacing
    real(kind=realtype) :: r_curr(3), r_next(3), r_prev(3), d_vec(3), &
&   d_vec_rot(3), eye(3, 3)
    real(kind=realtype) :: r_currd(3), r_nextd(3), r_prevd(3), d_vecd(3)&
&   , d_vec_rotd(3)
    real(kind=realtype) :: k(3*numnodes, 3*numnodes)
    real(kind=realtype) :: kd(3*numnodes, 3*numnodes)
    integer(kind=inttype) :: index, i
    integer(kind=inttype) :: ipiv(3*numnodes)
    integer(kind=inttype) :: n, nrhs, ldk, ldf, info
    real(kind=realtype) :: one, zero, rhs(3*numnodes)
    real(kind=realtype) :: rhsd(3*numnodes)
    logical :: guide
    one = 1.
    zero = 0.
! initialize arrays
    k(:, :) = zero
    f(:) = zero
    eye(:, :) = zero
    do i=1,3
      eye(i, i) = one
    end do
! now loop over each node
    index = 1
    if (bc1 .eq. 'splay') then
! get coordinates
      r_currd = r0d(:3)
      r_curr = r0(:3)
      r_nextd = r0d(4:6)
      r_next = r0(4:6)
! get vector that connects r_next to r_curr
      d_vecd = r_nextd - r_currd
      d_vec = r_next - r_curr
! get marching direction vector (orthogonal to the curve and to the surface normal)
      d_vec_rotd = 0.0_8
      call cross_d(n0(:, 1), n0d(:, 1), d_vec, d_vecd, d_vec_rot, &
&            d_vec_rotd)
! populate matrix
      kd = 0.0_8
      kd(1, :3) = d_vec_rotd
      k(1, :3) = d_vec_rot
      kd(2, :3) = n0d(:, index)
      k(2, :3) = n0(:, index)
      kd(3, :3) = d_vecd
      k(3, :3) = d_vec
      f(:3) = zero
      fd = 0.0_8
      fd(1) = (1-sigmasplay)*s0d(1)
      f(1) = s0(1)*(1-sigmasplay)
    else if (bc1 .eq. 'constx') then
! populate matrix
      k(2, 4) = zero
      k(2, 5) = -one
      k(2, 6) = zero
      k(3, 4) = zero
      k(3, 5) = zero
      k(3, 6) = -one
      do i=1,3
        k(i, i) = one
      end do
      fd = 0.0_8
      kd = 0.0_8
      d_vec_rotd = 0.0_8
    else if (bc1 .eq. 'consty') then
! populate matrix
      k(1, 4) = -one
      k(1, 5) = zero
      k(1, 6) = zero
      k(3, 4) = zero
      k(3, 5) = zero
      k(3, 6) = -one
      do i=1,3
        k(i, i) = one
      end do
      fd = 0.0_8
      kd = 0.0_8
      d_vec_rotd = 0.0_8
    else if (bc1 .eq. 'constz') then
! populate matrix
      k(1, 4) = -one
      k(1, 5) = zero
      k(1, 6) = zero
      k(2, 4) = zero
      k(2, 5) = -one
      k(2, 6) = zero
      do i=1,3
        k(i, i) = one
      end do
      fd = 0.0_8
      kd = 0.0_8
      d_vec_rotd = 0.0_8
    else if (bc1(:5) .eq. 'curve') then
! populate matrix
      do i=1,3
        k(i, i) = one
      end do
      fd = 0.0_8
      fd(:3) = s0d(1)*n0(:, 1) + s0(1)*n0d(:, 1)
      f(:3) = s0(1)*n0(:, 1)
      kd = 0.0_8
      d_vec_rotd = 0.0_8
    else
! call assembly routine
      fd = 0.0_8
      kd = 0.0_8
      call matrixbuilder_d(index, bc1, bc2, r0, r0d, rm1, rm1d, n0, n0d&
&                    , s0, s0d, sm1, sm1d, numlayers, epse0, layerindex&
&                    , theta, numnodes, k, kd, f, fd)
      d_vec_rotd = 0.0_8
    end if
    do index=2,numnodes-1
      if (retainspacing) then
        guide = .false.
        do i=1,numguides
          if (index .eq. guideindices(i)) guide = .true.
        end do
      else
        guide = .false.
      end if
      if (guide) then
        kd(3*(index-1)+1, 3*(index-1)+1) = 0.0_8
        k(3*(index-1)+1, 3*(index-1)+1) = one
        kd(3*(index-1)+2, 3*(index-1)+2) = 0.0_8
        k(3*(index-1)+2, 3*(index-1)+2) = one
        kd(3*(index-1)+3, 3*(index-1)+3) = 0.0_8
        k(3*(index-1)+3, 3*(index-1)+3) = one
        fd(3*(index-1)+1:3*(index-1)+3) = s0d(index)*n0(:, index) + s0(&
&         index)*n0d(:, index)
        f(3*(index-1)+1:3*(index-1)+3) = s0(index)*n0(:, index)
      else
! call assembly routine
        call matrixbuilder_d(index, bc1, bc2, r0, r0d, rm1, rm1d, n0, &
&                      n0d, s0, s0d, sm1, sm1d, numlayers, epse0, &
&                      layerindex, theta, numnodes, k, kd, f, fd)
      end if
    end do
    index = numnodes
    if (bc2 .eq. 'continuous') then
! populate matrix (use same displacements of first node)
      kd(3*(index-1)+1:, 3*(index-1)+1:) = 0.0_8
      k(3*(index-1)+1:, 3*(index-1)+1:) = eye
      kd(3*(index-1)+1:, :3) = 0.0_8
      k(3*(index-1)+1:, :3) = -eye
    else if (bc2 .eq. 'splay') then
! get coordinates
      r_currd = r0d(3*(index-1)+1:)
      r_curr = r0(3*(index-1)+1:)
      r_prevd = r0d(3*(index-2)+1:3*(index-2)+3)
      r_prev = r0(3*(index-2)+1:3*(index-2)+3)
! get vector that connects r_next to r_curr
      d_vecd = r_currd - r_prevd
      d_vec = r_curr - r_prev
! get marching direction vector (orthogonal to the curve and to the surface normal)
      call cross_d(n0(:, index), n0d(:, index), d_vec, d_vecd, d_vec_rot&
&            , d_vec_rotd)
! populate matrix
      kd(3*index-2, 3*index-2:) = d_vec_rotd
      k(3*index-2, 3*index-2:) = d_vec_rot
      kd(3*index-1, 3*index-2:) = n0d(:, index)
      k(3*index-1, 3*index-2:) = n0(:, index)
      kd(3*index-0, 3*index-2:) = d_vecd
      k(3*index-0, 3*index-2:) = d_vec
      fd(3*(index-1)+1:3*index) = 0.0_8
      f(3*(index-1)+1:3*index) = zero
      fd(3*(index-1)+1) = (1-sigmasplay)*s0d(index)
      f(3*(index-1)+1) = s0(index)*(1-sigmasplay)
    else if (bc2 .eq. 'constx') then
! populate matrix
      kd(3*index-0, 3*(index-2)+1) = 0.0_8
      k(3*index-0, 3*(index-2)+1) = zero
      kd(3*index-0, 3*(index-2)+2) = 0.0_8
      k(3*index-0, 3*(index-2)+2) = zero
      kd(3*index-0, 3*(index-2)+3) = 0.0_8
      k(3*index-0, 3*(index-2)+3) = -one
      kd(3*index-1, 3*(index-2)+1) = 0.0_8
      k(3*index-1, 3*(index-2)+1) = zero
      kd(3*index-1, 3*(index-2)+2) = 0.0_8
      k(3*index-1, 3*(index-2)+2) = -one
      kd(3*index-1, 3*(index-2)+3) = 0.0_8
      k(3*index-1, 3*(index-2)+3) = zero
      do i=3*index-2,3*index
        kd(i, i) = 0.0_8
        k(i, i) = one
      end do
    else if (bc2 .eq. 'consty') then
! populate matrix
      kd(3*index-2, 3*(index-2)+1) = 0.0_8
      k(3*index-2, 3*(index-2)+1) = -one
      kd(3*index-2, 3*(index-2)+2) = 0.0_8
      k(3*index-2, 3*(index-2)+2) = zero
      kd(3*index-2, 3*(index-2)+3) = 0.0_8
      k(3*index-2, 3*(index-2)+3) = zero
      kd(3*index-0, 3*(index-2)+1) = 0.0_8
      k(3*index-0, 3*(index-2)+1) = zero
      kd(3*index-0, 3*(index-2)+2) = 0.0_8
      k(3*index-0, 3*(index-2)+2) = zero
      kd(3*index-0, 3*(index-2)+3) = 0.0_8
      k(3*index-0, 3*(index-2)+3) = -one
      do i=3*index-2,3*index
        kd(i, i) = 0.0_8
        k(i, i) = one
      end do
    else if (bc2 .eq. 'constz') then
! populate matrix
      kd(3*index-2, 3*(index-2)+1) = 0.0_8
      k(3*index-2, 3*(index-2)+1) = -one
      kd(3*index-2, 3*(index-2)+2) = 0.0_8
      k(3*index-2, 3*(index-2)+2) = zero
      kd(3*index-2, 3*(index-2)+3) = 0.0_8
      k(3*index-2, 3*(index-2)+3) = zero
      kd(3*index-1, 3*(index-2)+1) = 0.0_8
      k(3*index-1, 3*(index-2)+1) = zero
      kd(3*index-1, 3*(index-2)+2) = 0.0_8
      k(3*index-1, 3*(index-2)+2) = -one
      kd(3*index-1, 3*(index-2)+3) = 0.0_8
      k(3*index-1, 3*(index-2)+3) = zero
      do i=3*index-2,3*index
        kd(i, i) = 0.0_8
        k(i, i) = one
      end do
    else if (bc2(:5) .eq. 'curve') then
! populate matrix
      do i=3*index-2,3*index
        kd(i, i) = 0.0_8
        k(i, i) = one
      end do
      fd(3*index-2:) = s0d(index)*n0(:, index) + s0(index)*n0d(:, index)
      f(3*index-2:) = s0(index)*n0(:, index)
    else
! call assembly routine
      call matrixbuilder_d(index, bc1, bc2, r0, r0d, rm1, rm1d, n0, n0d&
&                    , s0, s0d, sm1, sm1d, numlayers, epse0, layerindex&
&                    , theta, index, k, kd, f, fd)
    end if
! set other parameters
! problem size
    n = 3*numnodes
! number of right hand sides in f
    nrhs = 1
! leading dimension of k (should be = n unless we work with submatrices)
    ldk = n
! leading dimension of f (should be = n unless we work with submatrices)
    ldf = n
! call dgesv(n, nrhs, k, ldk, ipiv, f, ldf, info)
    rhsd = fd
    rhs = f
    call solve_d(k, kd, f, fd, rhs, rhsd, n, ipiv)
! note that this f is rnext when outputted from computematrices_main
    fd = r0d + fd
    f = r0 + f
  end subroutine computematrices_main_d
!=================================================================
!=================================================================
  subroutine computematrices_main(r0, n0, s0, rm1, sm1, layerindex, &
&   theta, sigmasplay, bc1, bc2, numlayers, epse0, guideindices, &
&   retainspacing, f, numnodes, numguides)
    use solveroutines, only : solve
    implicit none
    integer(kind=inttype), intent(in) :: layerindex, numnodes, numlayers
    real(kind=realtype), intent(in) :: r0(3*numnodes), n0(3, numnodes), &
&   s0(numnodes)
    real(kind=realtype), intent(in) :: rm1(3*numnodes), sm1(numnodes), &
&   theta
    real(kind=realtype), intent(in) :: sigmasplay, epse0
    character(len=32), intent(in) :: bc1, bc2
    real(kind=realtype), intent(out) :: f(3*numnodes)
    integer(kind=inttype), intent(in) :: numguides
    integer(kind=inttype), intent(in) :: guideindices(numguides)
    logical, intent(in) :: retainspacing
    real(kind=realtype) :: r_curr(3), r_next(3), r_prev(3), d_vec(3), &
&   d_vec_rot(3), eye(3, 3)
    real(kind=realtype) :: k(3*numnodes, 3*numnodes)
    integer(kind=inttype) :: index, i
    integer(kind=inttype) :: ipiv(3*numnodes)
    integer(kind=inttype) :: n, nrhs, ldk, ldf, info
    real(kind=realtype) :: one, zero, rhs(3*numnodes)
    logical :: guide
    one = 1.
    zero = 0.
! initialize arrays
    k(:, :) = zero
    f(:) = zero
    eye(:, :) = zero
    do i=1,3
      eye(i, i) = one
    end do
! now loop over each node
    index = 1
    if (bc1 .eq. 'splay') then
! get coordinates
      r_curr = r0(:3)
      r_next = r0(4:6)
! get vector that connects r_next to r_curr
      d_vec = r_next - r_curr
! get marching direction vector (orthogonal to the curve and to the surface normal)
      call cross(n0(:, 1), d_vec, d_vec_rot)
! populate matrix
      k(1, :3) = d_vec_rot
      k(2, :3) = n0(:, index)
      k(3, :3) = d_vec
      f(:3) = zero
      f(1) = s0(1)*(1-sigmasplay)
    else if (bc1 .eq. 'constx') then
! populate matrix
      k(2, 4) = zero
      k(2, 5) = -one
      k(2, 6) = zero
      k(3, 4) = zero
      k(3, 5) = zero
      k(3, 6) = -one
      do i=1,3
        k(i, i) = one
      end do
    else if (bc1 .eq. 'consty') then
! populate matrix
      k(1, 4) = -one
      k(1, 5) = zero
      k(1, 6) = zero
      k(3, 4) = zero
      k(3, 5) = zero
      k(3, 6) = -one
      do i=1,3
        k(i, i) = one
      end do
    else if (bc1 .eq. 'constz') then
! populate matrix
      k(1, 4) = -one
      k(1, 5) = zero
      k(1, 6) = zero
      k(2, 4) = zero
      k(2, 5) = -one
      k(2, 6) = zero
      do i=1,3
        k(i, i) = one
      end do
    else if (bc1(:5) .eq. 'curve') then
! populate matrix
      do i=1,3
        k(i, i) = one
      end do
      f(:3) = s0(1)*n0(:, 1)
    else
! call assembly routine
      call matrixbuilder(index, bc1, bc2, r0, rm1, n0, s0, sm1, &
&                  numlayers, epse0, layerindex, theta, numnodes, k, f)
    end if
    do index=2,numnodes-1
      if (retainspacing) then
        guide = .false.
        do i=1,numguides
          if (index .eq. guideindices(i)) guide = .true.
        end do
      else
        guide = .false.
      end if
      if (guide) then
        k(3*(index-1)+1, 3*(index-1)+1) = one
        k(3*(index-1)+2, 3*(index-1)+2) = one
        k(3*(index-1)+3, 3*(index-1)+3) = one
        f(3*(index-1)+1:3*(index-1)+3) = s0(index)*n0(:, index)
      else
! call assembly routine
        call matrixbuilder(index, bc1, bc2, r0, rm1, n0, s0, sm1, &
&                    numlayers, epse0, layerindex, theta, numnodes, k, f&
&                   )
      end if
    end do
    index = numnodes
    if (bc2 .eq. 'continuous') then
! populate matrix (use same displacements of first node)
      k(3*(index-1)+1:, 3*(index-1)+1:) = eye
      k(3*(index-1)+1:, :3) = -eye
    else if (bc2 .eq. 'splay') then
! get coordinates
      r_curr = r0(3*(index-1)+1:)
      r_prev = r0(3*(index-2)+1:3*(index-2)+3)
! get vector that connects r_next to r_curr
      d_vec = r_curr - r_prev
! get marching direction vector (orthogonal to the curve and to the surface normal)
      call cross(n0(:, index), d_vec, d_vec_rot)
! populate matrix
      k(3*index-2, 3*index-2:) = d_vec_rot
      k(3*index-1, 3*index-2:) = n0(:, index)
      k(3*index-0, 3*index-2:) = d_vec
      f(3*(index-1)+1:3*index) = zero
      f(3*(index-1)+1) = s0(index)*(1-sigmasplay)
    else if (bc2 .eq. 'constx') then
! populate matrix
      k(3*index-0, 3*(index-2)+1) = zero
      k(3*index-0, 3*(index-2)+2) = zero
      k(3*index-0, 3*(index-2)+3) = -one
      k(3*index-1, 3*(index-2)+1) = zero
      k(3*index-1, 3*(index-2)+2) = -one
      k(3*index-1, 3*(index-2)+3) = zero
      do i=3*index-2,3*index
        k(i, i) = one
      end do
    else if (bc2 .eq. 'consty') then
! populate matrix
      k(3*index-2, 3*(index-2)+1) = -one
      k(3*index-2, 3*(index-2)+2) = zero
      k(3*index-2, 3*(index-2)+3) = zero
      k(3*index-0, 3*(index-2)+1) = zero
      k(3*index-0, 3*(index-2)+2) = zero
      k(3*index-0, 3*(index-2)+3) = -one
      do i=3*index-2,3*index
        k(i, i) = one
      end do
    else if (bc2 .eq. 'constz') then
! populate matrix
      k(3*index-2, 3*(index-2)+1) = -one
      k(3*index-2, 3*(index-2)+2) = zero
      k(3*index-2, 3*(index-2)+3) = zero
      k(3*index-1, 3*(index-2)+1) = zero
      k(3*index-1, 3*(index-2)+2) = -one
      k(3*index-1, 3*(index-2)+3) = zero
      do i=3*index-2,3*index
        k(i, i) = one
      end do
    else if (bc2(:5) .eq. 'curve') then
! populate matrix
      do i=3*index-2,3*index
        k(i, i) = one
      end do
      f(3*index-2:) = s0(index)*n0(:, index)
    else
! call assembly routine
      call matrixbuilder(index, bc1, bc2, r0, rm1, n0, s0, sm1, &
&                  numlayers, epse0, layerindex, theta, index, k, f)
    end if
! set other parameters
! problem size
    n = 3*numnodes
! number of right hand sides in f
    nrhs = 1
! leading dimension of k (should be = n unless we work with submatrices)
    ldk = n
! leading dimension of f (should be = n unless we work with submatrices)
    ldf = n
! call dgesv(n, nrhs, k, ldk, ipiv, f, ldf, info)
    rhs = f
    call solve(k, f, rhs, n, ipiv)
! note that this f is rnext when outputted from computematrices_main
    f = r0 + f
  end subroutine computematrices_main
!  differentiation of matrixbuilder in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: f k
!   with respect to varying inputs: f k s0 sm1 n0 rm1 r0
  subroutine matrixbuilder_d(curr_index, bc1, bc2, r0, r0d, rm1, rm1d, &
&   n0, n0d, s0, s0d, sm1, sm1d, numlayers, epse0, layerindex, theta, &
&   numnodes, k, kd, f, fd)
    implicit none
    integer(kind=inttype), intent(in) :: curr_index, numnodes, numlayers&
&   , layerindex
    real(kind=realtype), intent(in) :: r0(3*numnodes), rm1(3*numnodes), &
&   n0(3, numnodes)
    real(kind=realtype), intent(in) :: r0d(3*numnodes), rm1d(3*numnodes)&
&   , n0d(3, numnodes)
    real(kind=realtype), intent(in) :: sm1(numnodes), epse0, s0(numnodes&
&   ), theta
    real(kind=realtype), intent(in) :: sm1d(numnodes), s0d(numnodes)
    character(len=32), intent(in) :: bc1, bc2
    real(kind=realtype), intent(inout) :: k(3*numnodes, 3*numnodes), f(3&
&   *numnodes)
    real(kind=realtype), intent(inout) :: kd(3*numnodes, 3*numnodes), fd&
&   (3*numnodes)
    real(kind=realtype) :: r_curr(3), r_next(3), d_vec(3), d_vec_rot(3)
    real(kind=realtype) :: r0_xi(3), pi, angle, b0(3, 3), b0inv(3, 3)
    real(kind=realtype) :: r0_xid(3), angled, b0d(3, 3), b0invd(3, 3)
    real(kind=realtype) :: r0_xi_n(3), point(3), neigh1_point(3), &
&   neigh2_point(3)
    real(kind=realtype) :: r0_xi_nd(3), neigh1_pointd(3), neigh2_pointd(&
&   3)
    real(kind=realtype) :: r0_eta_n(3), a0(3, 3), r0_eta(3)
    real(kind=realtype) :: r0_eta_nd(3), a0d(3, 3), r0_etad(3)
    real(kind=realtype) :: dsensor, dnum, dden, eye(3, 3), b0invg(3), c0&
&   (3, 3)
    real(kind=realtype) :: dsensord, dnumd, ddend, b0invgd(3), c0d(3, 3)
    real(kind=realtype) :: epse, epsi, de(3), numnorm1, numnorm2, &
&   numnorm3, numnorm4
    real(kind=realtype) :: epsed, epsid, ded(3), numnorm1d, numnorm2d, &
&   numnorm3d, numnorm4d
    integer(kind=inttype) :: index, i, j, neighbor1_index, &
&   neighbor2_index
    real(kind=realtype) :: one, zero
    one = 1.
    zero = 0.
    pi = 3.1415926535897932384626
    eye(:, :) = zero
    do i=1,3
      eye(i, i) = one
    end do
    if (curr_index .eq. 1) then
! forward case
      if (bc1 .ne. 'continuous') then
        neighbor1_index = 2
        neighbor2_index = 3
! using forward differencing for xi = 1
        r0_xid = 0.5*(4*r0d(4:6)-3*r0d(:3)-r0d(7:9))
        r0_xi = 0.5*(-(3*r0(:3))+4*r0(4:6)-r0(7:9))
        angle = pi
        angled = 0.0_8
      else
        neighbor1_index = numnodes - 1
        neighbor2_index = 2
! using central differencing for zeta = 2:numnodes-1
        r0_xid = 0.5*(r0d(4:6)-r0d(3*(neighbor1_index-1)+1:3*(&
&         neighbor1_index-1)+3))
        r0_xi = 0.5*(r0(4:6)-r0(3*(neighbor1_index-1)+1:3*(&
&         neighbor1_index-1)+3))
! compute the local grid angle based on the neighbors
        call giveangle_d(r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1&
&                  )+3), r0d(3*(neighbor1_index-1)+1:3*(neighbor1_index-&
&                  1)+3), r0(:3), r0d(:3), r0(4:6), r0d(4:6), n0(:, 1), &
&                  angle, angled)
      end if
    else if (curr_index .eq. numnodes) then
! backward case
      neighbor1_index = curr_index - 1
      neighbor2_index = curr_index - 2
! using backward differencing for xi = numnodes
      r0_xid = 0.5*(3*r0d(3*(curr_index-1)+1:3*(curr_index-1)+3)-4*r0d(3&
&       *(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)+r0d(3*(&
&       neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
      r0_xi = 0.5*(3*r0(3*(curr_index-1)+1:3*(curr_index-1)+3)-4*r0(3*(&
&       neighbor1_index-1)+1:3*(neighbor1_index-1)+3)+r0(3*(&
&       neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
      angle = pi
      angled = 0.0_8
    else
! central case
      neighbor1_index = curr_index - 1
      neighbor2_index = curr_index + 1
      neigh2_pointd = r0d(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+&
&       3)
      neigh2_point = r0(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3)
      neigh1_pointd = r0d(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+&
&       3)
      neigh1_point = r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)
! using central differencing for zeta = 2:numnodes-1
      r0_xid = 0.5*(neigh2_pointd-neigh1_pointd)
      r0_xi = 0.5*(neigh2_point-neigh1_point)
! compute the local grid angle based on the neighbors
      call giveangle_d(neigh1_point, neigh1_pointd, r0(3*(curr_index-1)+&
&                1:3*(curr_index-1)+3), r0d(3*(curr_index-1)+1:3*(&
&                curr_index-1)+3), neigh2_point, neigh2_pointd, n0(:, &
&                curr_index), angle, angled)
    end if
    r0_xi_nd = 0.0_8
    call cross_d(n0(:, curr_index), n0d(:, curr_index), r0_xi, r0_xid, &
&          r0_xi_n, r0_xi_nd)
! assemble b0 matrix
    b0d = 0.0_8
    b0d(1, :) = r0_xid
    b0(1, :) = r0_xi
    b0d(2, :) = r0_xi_nd
    b0(2, :) = r0_xi_n
    b0d(3, :) = n0d(:, curr_index)
    b0(3, :) = n0(:, curr_index)
! invert b0
    call matinv3_d(b0, b0d, b0inv, b0invd)
! compute eta derivatives
    r0_etad = b0invd(:, 2)*sm1(curr_index) + b0inv(:, 2)*sm1d(curr_index&
&     )
    r0_eta = b0inv(:, 2)*sm1(curr_index)
    r0_eta_nd = 0.0_8
    call cross_d(n0(:, curr_index), n0d(:, curr_index), r0_eta, r0_etad&
&          , r0_eta_n, r0_eta_nd)
! assemble a0 matrix
    a0d = 0.0_8
    a0d(1, :) = r0_etad
    a0(1, :) = r0_eta
    a0d(2, :) = r0_eta_nd
    a0(2, :) = r0_eta_n
    a0d(3, :) = 0.0_8
    a0(3, :) = zero
    call norm_d0(rm1(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) - &
&          rm1(3*(curr_index-1)+1:3*(curr_index-1)+3), rm1d(3*(&
&          neighbor2_index-1)+1:3*(neighbor2_index-1)+3) - rm1d(3*(&
&          curr_index-1)+1:3*(curr_index-1)+3), numnorm1, numnorm1d)
    call norm_d0(rm1(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) - &
&          rm1(3*(curr_index-1)+1:3*(curr_index-1)+3), rm1d(3*(&
&          neighbor1_index-1)+1:3*(neighbor1_index-1)+3) - rm1d(3*(&
&          curr_index-1)+1:3*(curr_index-1)+3), numnorm2, numnorm2d)
    call norm_d0(r0(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) - &
&          r0(3*(curr_index-1)+1:3*(curr_index-1)+3), r0d(3*(&
&          neighbor2_index-1)+1:3*(neighbor2_index-1)+3) - r0d(3*(&
&          curr_index-1)+1:3*(curr_index-1)+3), numnorm3, numnorm3d)
    call norm_d0(r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) - &
&          r0(3*(curr_index-1)+1:3*(curr_index-1)+3), r0d(3*(&
&          neighbor1_index-1)+1:3*(neighbor1_index-1)+3) - r0d(3*(&
&          curr_index-1)+1:3*(curr_index-1)+3), numnorm4, numnorm4d)
! compute grid distribution sensor (eq. 6.8a)
    dnumd = numnorm1d + numnorm2d
    dnum = numnorm1 + numnorm2
    ddend = numnorm3d + numnorm4d
    dden = numnorm3 + numnorm4
    dsensord = (dnumd*dden-dnum*ddend)/dden**2
    dsensor = dnum/dden
! sharp convex corner detection
    if (angle .lt. 70.*pi/180.) then
! corner detected
! populate matrix with eq 8.3
      kd(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)+1:&
&     3*(neighbor2_index-1)+3) = 0.0_8
      k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)+1:3&
&     *(neighbor2_index-1)+3) = -eye
      kd(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*(&
&     curr_index-1)+3) = 0.0_8
      k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*(&
&     curr_index-1)+3) = 2*eye
      kd(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)+1:&
&     3*(neighbor1_index-1)+3) = 0.0_8
      k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)+1:3&
&     *(neighbor1_index-1)+3) = -eye
      fd(3*(curr_index-1)+1:3*(curr_index-1)+3) = 0.0_8
      f(3*(curr_index-1)+1:3*(curr_index-1)+3) = zero
    else
      c0d = 0.0_8
! compute c0 = b0inv*a0
      do i=1,3
        do j=1,3
          call dot_d0(b0inv(i, :), b0invd(i, :), a0(:, j), a0d(:, j), c0&
&               (i, j), c0d(i, j))
        end do
      end do
! compute smoothing coefficients
      call dissipationcoefficients_d(layerindex, r0_xi, r0_xid, r0_eta, &
&                              r0_etad, dsensor, dsensord, angle, angled&
&                              , numlayers, epse0, epse, epsed, epsi, &
&                              epsid)
! compute rhs components
      b0invgd = b0invd(:, 2)*s0(curr_index) + b0inv(:, 2)*s0d(curr_index&
&       )
      b0invg = b0inv(:, 2)*s0(curr_index)
      if (curr_index .eq. 1) then
        if (bc1 .ne. 'continuous') then
! forwards
          ded = epsed*(r0(3*(curr_index-1)+1:3*(curr_index-1)+3)-2*r0(3*&
&           (neighbor1_index-1)+1:3*(neighbor1_index-1)+3)+r0(3*(&
&           neighbor2_index-1)+1:3*(neighbor2_index-1)+3)) + epse*(r0d(3&
&           *(curr_index-1)+1:3*(curr_index-1)+3)-2*r0d(3*(&
&           neighbor1_index-1)+1:3*(neighbor1_index-1)+3)+r0d(3*(&
&           neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
          de = epse*(r0(3*(curr_index-1)+1:3*(curr_index-1)+3)-2*r0(3*(&
&           neighbor1_index-1)+1:3*(neighbor1_index-1)+3)+r0(3*(&
&           neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
! populate matrix
          kd(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1&
&         )+1:3*(neighbor2_index-1)+3) = -(0.5*(1+theta)*c0d) - eye*&
&           epsid
          k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)&
&         +1:3*(neighbor2_index-1)+3) = -(0.5*(1+theta)*c0) - epsi*eye
          kd(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1&
&         )+1:3*(neighbor1_index-1)+3) = 2*(1+theta)*c0d + 2*eye*epsid
          k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)&
&         +1:3*(neighbor1_index-1)+3) = 2*(1+theta)*c0 + 2*epsi*eye
          kd(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3&
&         *(curr_index-1)+3) = -(1.5*(1+theta)*c0d) - eye*epsid
          k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*&
&         (curr_index-1)+3) = -(1.5*(1+theta)*c0) + (1-epsi)*eye
          fd(3*(curr_index-1)+1:3*(curr_index-1)+3) = b0invgd + ded
          f(3*(curr_index-1)+1:3*(curr_index-1)+3) = b0invg + de
        else
          ded = epsed*(r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+&
&           3)-2*r0(3*(curr_index-1)+1:3*(curr_index-1)+3)+r0(3*(&
&           neighbor2_index-1)+1:3*(neighbor2_index-1)+3)) + epse*(r0d(3&
&           *(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)-2*r0d(3*(&
&           curr_index-1)+1:3*(curr_index-1)+3)+r0d(3*(neighbor2_index-1&
&           )+1:3*(neighbor2_index-1)+3))
          de = epse*(r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)&
&           -2*r0(3*(curr_index-1)+1:3*(curr_index-1)+3)+r0(3*(&
&           neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
! populate matrix
          kd(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1&
&         )+1:3*(neighbor1_index-1)+3) = -(0.5*(1+theta)*c0d) - eye*&
&           epsid
          k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)&
&         +1:3*(neighbor1_index-1)+3) = -(0.5*(1+theta)*c0) - epsi*eye
          kd(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3&
&         *(curr_index-1)+3) = eye*2*epsid
          k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*&
&         (curr_index-1)+3) = (1+2*epsi)*eye
          kd(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1&
&         )+1:3*(neighbor2_index-1)+3) = 0.5*(1+theta)*c0d - eye*epsid
          k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)&
&         +1:3*(neighbor2_index-1)+3) = 0.5*(1+theta)*c0 - epsi*eye
          fd(3*(curr_index-1)+1:3*(curr_index-1)+3) = b0invgd + ded
          f(3*(curr_index-1)+1:3*(curr_index-1)+3) = b0invg + de
        end if
      else if (curr_index .eq. numnodes) then
! backwards
        ded = epsed*(r0(3*(curr_index-1)+1:3*(curr_index-1)+3)-2*r0(3*(&
&         neighbor1_index-1)+1:3*(neighbor1_index-1)+3)+r0(3*(&
&         neighbor2_index-1)+1:3*(neighbor2_index-1)+3)) + epse*(r0d(3*(&
&         curr_index-1)+1:3*(curr_index-1)+3)-2*r0d(3*(neighbor1_index-1&
&         )+1:3*(neighbor1_index-1)+3)+r0d(3*(neighbor2_index-1)+1:3*(&
&         neighbor2_index-1)+3))
        de = epse*(r0(3*(curr_index-1)+1:3*(curr_index-1)+3)-2*r0(3*(&
&         neighbor1_index-1)+1:3*(neighbor1_index-1)+3)+r0(3*(&
&         neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
! populate matrix
        kd(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)+&
&       1:3*(neighbor2_index-1)+3) = 0.5*(1+theta)*c0d - eye*epsid
        k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)+1&
&       :3*(neighbor2_index-1)+3) = 0.5*(1+theta)*c0 - epsi*eye
        kd(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)+&
&       1:3*(neighbor1_index-1)+3) = 2*eye*epsid - 2*(1+theta)*c0d
        k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)+1&
&       :3*(neighbor1_index-1)+3) = -(2*(1+theta)*c0) + 2*epsi*eye
        kd(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*(&
&       curr_index-1)+3) = 1.5*(1+theta)*c0d - eye*epsid
        k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*(&
&       curr_index-1)+3) = 1.5*(1+theta)*c0 + (1-epsi)*eye
        fd(3*(curr_index-1)+1:3*(curr_index-1)+3) = b0invgd + ded
        f(3*(curr_index-1)+1:3*(curr_index-1)+3) = b0invg + de
      else
! central
        ded = epsed*(r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)&
&         -2*r0(3*(curr_index-1)+1:3*(curr_index-1)+3)+r0(3*(&
&         neighbor2_index-1)+1:3*(neighbor2_index-1)+3)) + epse*(r0d(3*(&
&         neighbor1_index-1)+1:3*(neighbor1_index-1)+3)-2*r0d(3*(&
&         curr_index-1)+1:3*(curr_index-1)+3)+r0d(3*(neighbor2_index-1)+&
&         1:3*(neighbor2_index-1)+3))
        de = epse*(r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)-2&
&         *r0(3*(curr_index-1)+1:3*(curr_index-1)+3)+r0(3*(&
&         neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
        kd(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)+&
&       1:3*(neighbor1_index-1)+3) = -(0.5*(1+theta)*c0d) - eye*epsid
        k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)+1&
&       :3*(neighbor1_index-1)+3) = -(0.5*(1+theta)*c0) - epsi*eye
        kd(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*(&
&       curr_index-1)+3) = eye*2*epsid
        k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*(&
&       curr_index-1)+3) = (1+2*epsi)*eye
        kd(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)+&
&       1:3*(neighbor2_index-1)+3) = 0.5*(1+theta)*c0d - eye*epsid
        k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)+1&
&       :3*(neighbor2_index-1)+3) = 0.5*(1+theta)*c0 - epsi*eye
        fd(3*(curr_index-1)+1:3*(curr_index-1)+3) = b0invgd + ded
        f(3*(curr_index-1)+1:3*(curr_index-1)+3) = b0invg + de
      end if
    end if
  end subroutine matrixbuilder_d
  subroutine matrixbuilder(curr_index, bc1, bc2, r0, rm1, n0, s0, sm1, &
&   numlayers, epse0, layerindex, theta, numnodes, k, f)
    implicit none
    integer(kind=inttype), intent(in) :: curr_index, numnodes, numlayers&
&   , layerindex
    real(kind=realtype), intent(in) :: r0(3*numnodes), rm1(3*numnodes), &
&   n0(3, numnodes)
    real(kind=realtype), intent(in) :: sm1(numnodes), epse0, s0(numnodes&
&   ), theta
    character(len=32), intent(in) :: bc1, bc2
    real(kind=realtype), intent(inout) :: k(3*numnodes, 3*numnodes), f(3&
&   *numnodes)
    real(kind=realtype) :: r_curr(3), r_next(3), d_vec(3), d_vec_rot(3)
    real(kind=realtype) :: r0_xi(3), pi, angle, b0(3, 3), b0inv(3, 3)
    real(kind=realtype) :: r0_xi_n(3), point(3), neigh1_point(3), &
&   neigh2_point(3)
    real(kind=realtype) :: r0_eta_n(3), a0(3, 3), r0_eta(3)
    real(kind=realtype) :: dsensor, dnum, dden, eye(3, 3), b0invg(3), c0&
&   (3, 3)
    real(kind=realtype) :: epse, epsi, de(3), numnorm1, numnorm2, &
&   numnorm3, numnorm4
    integer(kind=inttype) :: index, i, j, neighbor1_index, &
&   neighbor2_index
    real(kind=realtype) :: one, zero
    one = 1.
    zero = 0.
    pi = 3.1415926535897932384626
    eye(:, :) = zero
    do i=1,3
      eye(i, i) = one
    end do
    if (curr_index .eq. 1) then
! forward case
      if (bc1 .ne. 'continuous') then
        neighbor1_index = 2
        neighbor2_index = 3
! using forward differencing for xi = 1
        r0_xi = 0.5*(-(3*r0(:3))+4*r0(4:6)-r0(7:9))
        angle = pi
      else
        neighbor1_index = numnodes - 1
        neighbor2_index = 2
! using central differencing for zeta = 2:numnodes-1
        r0_xi = 0.5*(r0(4:6)-r0(3*(neighbor1_index-1)+1:3*(&
&         neighbor1_index-1)+3))
! compute the local grid angle based on the neighbors
        call giveangle(r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+&
&                3), r0(:3), r0(4:6), n0(:, 1), angle)
      end if
    else if (curr_index .eq. numnodes) then
! backward case
      neighbor1_index = curr_index - 1
      neighbor2_index = curr_index - 2
! using backward differencing for xi = numnodes
      r0_xi = 0.5*(3*r0(3*(curr_index-1)+1:3*(curr_index-1)+3)-4*r0(3*(&
&       neighbor1_index-1)+1:3*(neighbor1_index-1)+3)+r0(3*(&
&       neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
      angle = pi
    else
! central case
      neighbor1_index = curr_index - 1
      neighbor2_index = curr_index + 1
      neigh2_point = r0(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3)
      neigh1_point = r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)
! using central differencing for zeta = 2:numnodes-1
      r0_xi = 0.5*(neigh2_point-neigh1_point)
! compute the local grid angle based on the neighbors
      call giveangle(neigh1_point, r0(3*(curr_index-1)+1:3*(curr_index-1&
&              )+3), neigh2_point, n0(:, curr_index), angle)
    end if
    call cross(n0(:, curr_index), r0_xi, r0_xi_n)
! assemble b0 matrix
    b0(1, :) = r0_xi
    b0(2, :) = r0_xi_n
    b0(3, :) = n0(:, curr_index)
! invert b0
    call matinv3(b0, b0inv)
! compute eta derivatives
    r0_eta = b0inv(:, 2)*sm1(curr_index)
    call cross(n0(:, curr_index), r0_eta, r0_eta_n)
! assemble a0 matrix
    a0(1, :) = r0_eta
    a0(2, :) = r0_eta_n
    a0(3, :) = zero
    call norm(rm1(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) - rm1&
&       (3*(curr_index-1)+1:3*(curr_index-1)+3), numnorm1)
    call norm(rm1(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) - rm1&
&       (3*(curr_index-1)+1:3*(curr_index-1)+3), numnorm2)
    call norm(r0(3*(neighbor2_index-1)+1:3*(neighbor2_index-1)+3) - r0(3&
&       *(curr_index-1)+1:3*(curr_index-1)+3), numnorm3)
    call norm(r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3) - r0(3&
&       *(curr_index-1)+1:3*(curr_index-1)+3), numnorm4)
! compute grid distribution sensor (eq. 6.8a)
    dnum = numnorm1 + numnorm2
    dden = numnorm3 + numnorm4
    dsensor = dnum/dden
! sharp convex corner detection
    if (angle .lt. 70.*pi/180.) then
! corner detected
! populate matrix with eq 8.3
      k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)+1:3&
&     *(neighbor2_index-1)+3) = -eye
      k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*(&
&     curr_index-1)+3) = 2*eye
      k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)+1:3&
&     *(neighbor1_index-1)+3) = -eye
      f(3*(curr_index-1)+1:3*(curr_index-1)+3) = zero
    else
! compute c0 = b0inv*a0
      do i=1,3
        do j=1,3
          call dot(b0inv(i, :), a0(:, j), c0(i, j))
        end do
      end do
! compute smoothing coefficients
      call dissipationcoefficients(layerindex, r0_xi, r0_eta, dsensor, &
&                            angle, numlayers, epse0, epse, epsi)
! compute rhs components
      b0invg = b0inv(:, 2)*s0(curr_index)
      if (curr_index .eq. 1) then
        if (bc1 .ne. 'continuous') then
! forwards
          de = epse*(r0(3*(curr_index-1)+1:3*(curr_index-1)+3)-2*r0(3*(&
&           neighbor1_index-1)+1:3*(neighbor1_index-1)+3)+r0(3*(&
&           neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
! populate matrix
          k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)&
&         +1:3*(neighbor2_index-1)+3) = -(0.5*(1+theta)*c0) - epsi*eye
          k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)&
&         +1:3*(neighbor1_index-1)+3) = 2*(1+theta)*c0 + 2*epsi*eye
          k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*&
&         (curr_index-1)+3) = -(1.5*(1+theta)*c0) + (1-epsi)*eye
          f(3*(curr_index-1)+1:3*(curr_index-1)+3) = b0invg + de
        else
          de = epse*(r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)&
&           -2*r0(3*(curr_index-1)+1:3*(curr_index-1)+3)+r0(3*(&
&           neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
! populate matrix
          k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)&
&         +1:3*(neighbor1_index-1)+3) = -(0.5*(1+theta)*c0) - epsi*eye
          k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*&
&         (curr_index-1)+3) = (1+2*epsi)*eye
          k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)&
&         +1:3*(neighbor2_index-1)+3) = 0.5*(1+theta)*c0 - epsi*eye
          f(3*(curr_index-1)+1:3*(curr_index-1)+3) = b0invg + de
        end if
      else if (curr_index .eq. numnodes) then
! backwards
        de = epse*(r0(3*(curr_index-1)+1:3*(curr_index-1)+3)-2*r0(3*(&
&         neighbor1_index-1)+1:3*(neighbor1_index-1)+3)+r0(3*(&
&         neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
! populate matrix
        k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)+1&
&       :3*(neighbor2_index-1)+3) = 0.5*(1+theta)*c0 - epsi*eye
        k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)+1&
&       :3*(neighbor1_index-1)+3) = -(2*(1+theta)*c0) + 2*epsi*eye
        k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*(&
&       curr_index-1)+3) = 1.5*(1+theta)*c0 + (1-epsi)*eye
        f(3*(curr_index-1)+1:3*(curr_index-1)+3) = b0invg + de
      else
! central
        de = epse*(r0(3*(neighbor1_index-1)+1:3*(neighbor1_index-1)+3)-2&
&         *r0(3*(curr_index-1)+1:3*(curr_index-1)+3)+r0(3*(&
&         neighbor2_index-1)+1:3*(neighbor2_index-1)+3))
        k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor1_index-1)+1&
&       :3*(neighbor1_index-1)+3) = -(0.5*(1+theta)*c0) - epsi*eye
        k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(curr_index-1)+1:3*(&
&       curr_index-1)+3) = (1+2*epsi)*eye
        k(3*(curr_index-1)+1:3*(curr_index-1)+3, 3*(neighbor2_index-1)+1&
&       :3*(neighbor2_index-1)+3) = 0.5*(1+theta)*c0 - epsi*eye
        f(3*(curr_index-1)+1:3*(curr_index-1)+3) = b0invg + de
      end if
    end if
  end subroutine matrixbuilder
!  differentiation of dissipationcoefficients in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: epse epsi
!   with respect to varying inputs: r0_eta dsensor angle r0_xi
  subroutine dissipationcoefficients_d(layerindex, r0_xi, r0_xid, r0_eta&
&   , r0_etad, dsensor, dsensord, angle, angled, numlayers, epse0, epse&
&   , epsed, epsi, epsid)
    implicit none
    integer(kind=inttype), intent(in) :: layerindex, numlayers
    real(kind=realtype), intent(in) :: dsensor, angle, epse0, r0_xi(3), &
&   r0_eta(3)
    real(kind=realtype), intent(in) :: dsensord, angled, r0_xid(3), &
&   r0_etad(3)
    real(kind=realtype), intent(out) :: epse, epsi
    real(kind=realtype), intent(out) :: epsed, epsid
    real(kind=realtype) :: sl, dbar, a, pi, n, r, normeta, normxi
    real(kind=realtype) :: dbard, ad, nd, rd, normetad, normxid
    integer(kind=inttype) :: l, ltrans
    intrinsic int
    intrinsic float
    intrinsic dsqrt
    intrinsic max
    intrinsic cos
    real*8 :: arg1
    real(kind=realtype) :: pwy1
    real(kind=realtype) :: pwr1
    pi = 3.14159265358979323846264338
! compute n (eq. 6.3)
    call norm_d0(r0_eta, r0_etad, normeta, normetad)
    call norm_d0(r0_xi, r0_xid, normxi, normxid)
    nd = (normetad*normxi-normeta*normxid)/normxi**2
    n = normeta/normxi
! compute sl (eq. 6.5) based on a transition l of 3/4 of max
    l = layerindex + 2
    ltrans = int(3./4.*numlayers)
    if (l .le. ltrans) then
      arg1 = float(l-1)/float(numlayers-1)
      sl = dsqrt(arg1)
    else
      arg1 = float(ltrans-1)/float(numlayers-1)
      sl = dsqrt(arg1)
    end if
    pwy1 = 2./sl
    pwr1 = dsensor**pwy1
    if (pwr1 .lt. 0.1) then
      dbar = 0.1
      dbard = 0.0_8
    else
      pwy1 = 2./sl
      if (dsensor .gt. 0.0_8 .or. (dsensor .lt. 0.0_8 .and. pwy1 .eq. &
&         int(pwy1))) then
        dbard = pwy1*dsensor**(pwy1-1)*dsensord
      else if (dsensor .eq. 0.0_8 .and. pwy1 .eq. 1.0) then
        dbard = dsensord
      else
        dbard = 0.0_8
      end if
      dbar = dsensor**pwy1
    end if
! compute a (eq 6.12 adjusted for entire angle (angle=2*alpha))
    if (angle .le. pi) then
! convex corner
      a = 1.0
      ad = 0.0_8
    else
      ad = -((angled*sin(angle/2)*cos(angle/2)/2+cos(angle/2)*angled*sin&
&       (angle/2)/2)/(1.0-cos(angle/2)*cos(angle/2))**2)
      a = 1.0/(1.0-cos(angle/2)*cos(angle/2))
    end if
! compute auxiliary variable r (eq. 6.4)
    rd = sl*(dbard*a+dbar*ad)
    r = sl*dbar*a
! compute the dissipation coefficients
    epsed = epse0*(rd*n+r*nd)
    epse = epse0*r*n
    epsid = 2*epsed
    epsi = 2*epse
  end subroutine dissipationcoefficients_d
  subroutine dissipationcoefficients(layerindex, r0_xi, r0_eta, dsensor&
&   , angle, numlayers, epse0, epse, epsi)
    implicit none
    integer(kind=inttype), intent(in) :: layerindex, numlayers
    real(kind=realtype), intent(in) :: dsensor, angle, epse0, r0_xi(3), &
&   r0_eta(3)
    real(kind=realtype), intent(out) :: epse, epsi
    real(kind=realtype) :: sl, dbar, a, pi, n, r, normeta, normxi
    integer(kind=inttype) :: l, ltrans
    intrinsic int
    intrinsic float
    intrinsic dsqrt
    intrinsic max
    intrinsic cos
    real*8 :: arg1
    real(kind=realtype) :: pwy1
    real(kind=realtype) :: pwr1
    pi = 3.14159265358979323846264338
! compute n (eq. 6.3)
    call norm(r0_eta, normeta)
    call norm(r0_xi, normxi)
    n = normeta/normxi
! compute sl (eq. 6.5) based on a transition l of 3/4 of max
    l = layerindex + 2
    ltrans = int(3./4.*numlayers)
    if (l .le. ltrans) then
      arg1 = float(l-1)/float(numlayers-1)
      sl = dsqrt(arg1)
    else
      arg1 = float(ltrans-1)/float(numlayers-1)
      sl = dsqrt(arg1)
    end if
    pwy1 = 2./sl
    pwr1 = dsensor**pwy1
    if (pwr1 .lt. 0.1) then
      dbar = 0.1
    else
      pwy1 = 2./sl
      dbar = dsensor**pwy1
    end if
! compute a (eq 6.12 adjusted for entire angle (angle=2*alpha))
    if (angle .le. pi) then
! convex corner
      a = 1.0
    else
      a = 1.0/(1.0-cos(angle/2)*cos(angle/2))
    end if
! compute auxiliary variable r (eq. 6.4)
    r = sl*dbar*a
! compute the dissipation coefficients
    epse = epse0*r*n
    epsi = 2*epse
  end subroutine dissipationcoefficients
!  differentiation of areafactor in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: s
!   with respect to varying inputs: d r0
!   rw status of diff variables: d:in s:out r0:in
  subroutine areafactor_d(r0, r0d, d, dd, nuarea, numareapasses, bc1, &
&   bc2, guideindices, retainspacing, numguides, n, s, sd, maxstretch)
    implicit none
    integer(kind=inttype), intent(in) :: n
    real(kind=realtype), intent(in) :: r0(3*n), d, nuarea
    real(kind=realtype), intent(in) :: r0d(3*n), dd
    integer(kind=inttype), intent(in) :: numareapasses
    character(len=32), intent(in) :: bc1, bc2
    integer(kind=inttype), intent(in) :: numguides
    integer(kind=inttype), intent(in) :: guideindices(numguides)
    logical, intent(in) :: retainspacing
    real(kind=realtype), intent(out) :: s(n), maxstretch
    real(kind=realtype), intent(out) :: sd(n)
    real(kind=realtype) :: r0_extrap(3*(2+n))
    real(kind=realtype) :: r0_extrapd(3*(2+n))
    real(kind=realtype) :: neighbordist(n), norm_1(n), norm_2(n)
    real(kind=realtype) :: neighbordistd(n), norm_1d(n), norm_2d(n)
    real(kind=realtype) :: sminus, splus, stretchratio(n)
    real(kind=realtype) :: sminusd, splusd
    integer(kind=inttype) :: index, i
! extrapolate the end points and copy starting curve
    r0_extrapd = 0.0_8
    r0_extrapd(:3) = 2*r0d(:3) - r0d(4:6)
    r0_extrap(:3) = 2*r0(:3) - r0(4:6)
    r0_extrapd(4:3*(n+1)) = r0d
    r0_extrap(4:3*(n+1)) = r0
    r0_extrapd(3*(n+1)+1:) = 2*r0d(3*(n-1)+1:) - r0d(3*(n-2)+1:3*(n-1))
    r0_extrap(3*(n+1)+1:) = 2*r0(3*(n-1)+1:) - r0(3*(n-2)+1:3*(n-1))
    norm_1d = 0.0_8
    norm_2d = 0.0_8
! compute the distance of each node to its neighbors
    do index=1,n
      call norm_d0(r0_extrap(3*index+1:3*index+3) - r0_extrap(3*index-2:&
&            3*index), r0_extrapd(3*index+1:3*index+3) - r0_extrapd(3*&
&            index-2:3*index), norm_1(index), norm_1d(index))
      call norm_d0(r0_extrap(3*index+4:3*index+6) - r0_extrap(3*index+1:&
&            3*index+3), r0_extrapd(3*index+4:3*index+6) - r0_extrapd(3*&
&            index+1:3*index+3), norm_2(index), norm_2d(index))
    end do
    neighbordistd = 0.5*(norm_1d+norm_2d)
    neighbordist = 0.5*(norm_1+norm_2)
! multiply distances by the step size to get the areas
    sd = dd*neighbordist + d*neighbordistd
    s = d*neighbordist
! divide the marching distance and the neighbor distance to get the stretch ratios
    stretchratio = d/neighbordist
! get the maximum stretch ratio
    maxstretch = -1.e20
    do index=1,n
      if (stretchratio(index) .gt. maxstretch) maxstretch = stretchratio&
&         (index)
    end do
! do the requested number of averagings
    do index=1,numareapasses
! store previous values
      splusd = sd(2)
      splus = s(2)
      sminusd = sd(n-1)
      sminus = s(n-1)
! do the averaging for the central nodes
      sd(2:n-1) = (1-nuarea)*sd(2:n-1) + nuarea*(sd(:n-2)+sd(3:))/2
      s(2:n-1) = (1-nuarea)*s(2:n-1) + nuarea/2*(s(:n-2)+s(3:))
! average for the extremum nodes
      sd(1) = (1-nuarea)*sd(1) + nuarea*splusd
      s(1) = (1-nuarea)*s(1) + nuarea*splus
      sd(n) = (1-nuarea)*sd(n) + nuarea*sminusd
      s(n) = (1-nuarea)*s(n) + nuarea*sminus
    end do
! if we use curve boundary conditions, we need just the marching distance, and not area, for the end nodes
    if (bc1(:5) .eq. 'curve') then
      sd(1) = dd
      s(1) = d
    end if
    if (bc2(:5) .eq. 'curve') then
      sd(n) = dd
      s(n) = d
    end if
    if (retainspacing) then
! set guidecurve marching distances
      do i=1,numguides
        index = guideindices(i)
        sd(index) = dd
        s(index) = d
      end do
    end if
  end subroutine areafactor_d
  subroutine areafactor(r0, d, nuarea, numareapasses, bc1, bc2, &
&   guideindices, retainspacing, numguides, n, s, maxstretch)
    implicit none
    integer(kind=inttype), intent(in) :: n
    real(kind=realtype), intent(in) :: r0(3*n), d, nuarea
    integer(kind=inttype), intent(in) :: numareapasses
    character(len=32), intent(in) :: bc1, bc2
    integer(kind=inttype), intent(in) :: numguides
    integer(kind=inttype), intent(in) :: guideindices(numguides)
    logical, intent(in) :: retainspacing
    real(kind=realtype), intent(out) :: s(n), maxstretch
    real(kind=realtype) :: r0_extrap(3*(2+n))
    real(kind=realtype) :: neighbordist(n), norm_1(n), norm_2(n)
    real(kind=realtype) :: sminus, splus, stretchratio(n)
    integer(kind=inttype) :: index, i
! extrapolate the end points and copy starting curve
    r0_extrap(:3) = 2*r0(:3) - r0(4:6)
    r0_extrap(4:3*(n+1)) = r0
    r0_extrap(3*(n+1)+1:) = 2*r0(3*(n-1)+1:) - r0(3*(n-2)+1:3*(n-1))
! compute the distance of each node to its neighbors
    do index=1,n
      call norm(r0_extrap(3*index+1:3*index+3) - r0_extrap(3*index-2:3*&
&         index), norm_1(index))
      call norm(r0_extrap(3*index+4:3*index+6) - r0_extrap(3*index+1:3*&
&         index+3), norm_2(index))
    end do
    neighbordist = 0.5*(norm_1+norm_2)
! multiply distances by the step size to get the areas
    s = d*neighbordist
! divide the marching distance and the neighbor distance to get the stretch ratios
    stretchratio = d/neighbordist
! get the maximum stretch ratio
    maxstretch = -1.e20
    do index=1,n
      if (stretchratio(index) .gt. maxstretch) maxstretch = stretchratio&
&         (index)
    end do
! do the requested number of averagings
    do index=1,numareapasses
! store previous values
      splus = s(2)
      sminus = s(n-1)
! do the averaging for the central nodes
      s(2:n-1) = (1-nuarea)*s(2:n-1) + nuarea/2*(s(:n-2)+s(3:))
! average for the extremum nodes
      s(1) = (1-nuarea)*s(1) + nuarea*splus
      s(n) = (1-nuarea)*s(n) + nuarea*sminus
    end do
! if we use curve boundary conditions, we need just the marching distance, and not area, for the end nodes
    if (bc1(:5) .eq. 'curve') s(1) = d
    if (bc2(:5) .eq. 'curve') s(n) = d
    if (retainspacing) then
! set guidecurve marching distances
      do i=1,numguides
        index = guideindices(i)
        s(index) = d
      end do
    end if
  end subroutine areafactor
!  differentiation of smoothing_main in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: rout
!   with respect to varying inputs: r
!   rw status of diff variables: r:in rout:out
  subroutine smoothing_main_d(r, rd, eta, alphap0, numsmoothingpasses, &
&   numlayers, n, rout, routd)
    implicit none
    integer(kind=inttype), intent(in) :: n
    real(kind=realtype), intent(in) :: eta, alphap0
    integer(kind=inttype), intent(in) :: numsmoothingpasses, numlayers
    real(kind=realtype), intent(in) :: r(3*n)
    real(kind=realtype), intent(in) :: rd(3*n)
    real(kind=realtype), intent(out) :: rout(3*n)
    real(kind=realtype), intent(out) :: routd(3*n)
    real(kind=realtype) :: r_next(3), r_curr(3), r_prev(3), lp, lm, &
&   alphap
    real(kind=realtype) :: r_nextd(3), r_currd(3), r_prevd(3), lpd, lmd
    real(kind=realtype) :: r_smooth(3*n)
    real(kind=realtype) :: r_smoothd(3*n)
    integer(kind=inttype) :: index, index_pass
    intrinsic min
    if (alphap0 .gt. alphap0*(eta-3)/numlayers) then
      alphap = alphap0*(eta-3)/numlayers
    else
      alphap = alphap0
    end if
    routd = rd
    rout = r
! this function does the grid smoothing
! loop over the desired number of smoothing passes
    do index_pass=1,numsmoothingpasses
! copy nodes
      r_smoothd = routd
      r_smooth = rout
! smooth every node
      do index=2,n-1
! get coordinates
        r_currd = routd(3*(index-1)+1:3*(index-1)+3)
        r_curr = rout(3*(index-1)+1:3*(index-1)+3)
        r_nextd = routd(3*index+1:3*index+3)
        r_next = rout(3*index+1:3*index+3)
        r_prevd = routd(3*(index-2)+1:3*(index-2)+3)
        r_prev = rout(3*(index-2)+1:3*(index-2)+3)
! compute distances
        call norm_d0(r_next - r_curr, r_nextd - r_currd, lp, lpd)
        call norm_d0(r_curr - r_prev, r_currd - r_prevd, lm, lmd)
! compute smoothed coordinates
        r_smoothd(3*(index-1)+1:3*(index-1)+3) = (1.-alphap)*r_currd + (&
&         alphap*(lmd*r_next+lm*r_nextd+lpd*r_prev+lp*r_prevd)*(lp+lm)-&
&         alphap*(lm*r_next+lp*r_prev)*(lpd+lmd))/(lp+lm)**2
        r_smooth(3*(index-1)+1:3*(index-1)+3) = (1.-alphap)*r_curr + &
&         alphap*(lm*r_next+lp*r_prev)/(lp+lm)
      end do
! copy coordinates to allow next pass
      routd = r_smoothd
      rout = r_smooth
    end do
  end subroutine smoothing_main_d
  subroutine smoothing_main(r, eta, alphap0, numsmoothingpasses, &
&   numlayers, n, rout)
    implicit none
    integer(kind=inttype), intent(in) :: n
    real(kind=realtype), intent(in) :: eta, alphap0
    integer(kind=inttype), intent(in) :: numsmoothingpasses, numlayers
    real(kind=realtype), intent(in) :: r(3*n)
    real(kind=realtype), intent(out) :: rout(3*n)
    real(kind=realtype) :: r_next(3), r_curr(3), r_prev(3), lp, lm, &
&   alphap
    real(kind=realtype) :: r_smooth(3*n)
    integer(kind=inttype) :: index, index_pass
    intrinsic min
    if (alphap0 .gt. alphap0*(eta-3)/numlayers) then
      alphap = alphap0*(eta-3)/numlayers
    else
      alphap = alphap0
    end if
    rout = r
! this function does the grid smoothing
! loop over the desired number of smoothing passes
    do index_pass=1,numsmoothingpasses
! copy nodes
      r_smooth = rout
! smooth every node
      do index=2,n-1
! get coordinates
        r_curr = rout(3*(index-1)+1:3*(index-1)+3)
        r_next = rout(3*index+1:3*index+3)
        r_prev = rout(3*(index-2)+1:3*(index-2)+3)
! compute distances
        call norm(r_next - r_curr, lp)
        call norm(r_curr - r_prev, lm)
! compute smoothed coordinates
        r_smooth(3*(index-1)+1:3*(index-1)+3) = (1.-alphap)*r_curr + &
&         alphap*(lm*r_next+lp*r_prev)/(lp+lm)
      end do
! copy coordinates to allow next pass
      rout = r_smooth
    end do
  end subroutine smoothing_main
  subroutine qualitycheck(r, layerindex, numlayers, numnodes, fail, &
&   ratios)
    implicit none
    integer(kind=inttype), intent(in) :: numlayers, numnodes
    integer(kind=inttype), intent(in) :: layerindex
    real(kind=realtype), intent(in) :: r(numlayers, 3*numnodes)
    real(kind=realtype), intent(out) :: ratios(numlayers-1, numnodes-1)
    integer(kind=inttype), intent(out) :: fail
    real(kind=realtype) :: xyz(3, numlayers, numnodes), nodalnormals(3, &
&   numlayers, numnodes)
    real(kind=realtype) :: panelnormals(3, numlayers-1, numnodes-1), &
&   norm_vec(3)
    real(kind=realtype) :: vec1(3, numlayers-1, numnodes-1), vec2(3, &
&   numlayers-1, numnodes-1)
    real(kind=realtype) :: vec3(3, numlayers-2, numnodes-2), vec4(3, &
&   numlayers-2, numnodes-2)
    real(kind=realtype) :: nodalderivs(3, 2, numlayers, numnodes), det(&
&   numlayers, numnodes)
    real(kind=realtype) :: normals(3, numlayers-2, numnodes-2), &
&   nodaljacs(3, 3, numlayers, numnodes), norm_val
    integer(kind=inttype) :: i, j
    real(kind=realtype) :: zero
    intrinsic minval
    intrinsic maxval
    real :: result1
    real :: result2
    real :: result10
    zero = 0.
! convert the flattened array r into a 3 x numnodes x numlayers array.
! numlayers -> number of layers in the marching direction
! numnodes -> number of nodes in direction of curve
    do i=1,numnodes
      xyz(1, :, i) = r(:, 3*(i-1)+1)
      xyz(2, :, i) = r(:, 3*(i-1)+2)
      xyz(3, :, i) = r(:, 3*(i-1)+3)
    end do
! setup nodal normals
    nodalnormals(:, :, :) = zero
! get the panel normals from the interior points of the mesh.
! here we take the cross product of the diagonals of each face
    vec1 = xyz(:, 2:, 2:) - xyz(:, :numlayers-1, :numnodes-1)
    vec2 = xyz(:, 2:, :numnodes-1) - xyz(:, :numlayers-1, 2:)
    do i=1,numnodes-1
      do j=1,numlayers-1
        call cross(vec2(:, j, i), vec1(:, j, i), norm_vec)
        call norm(norm_vec, norm_val)
        panelnormals(:, j, i) = norm_vec/norm_val
      end do
    end do
! set the interior normals using an average of the panel normals
    vec3 = panelnormals(:, 2:, 2:) + panelnormals(:, :numlayers-2, :&
&     numnodes-2)
    vec4 = panelnormals(:, 2:, :numnodes-2) + panelnormals(:, :numlayers&
&     -2, 2:)
    normals = vec3 + vec4
    do i=2,numnodes-1
      do j=2,numlayers-1
        call norm(normals(:, j-1, i-1), norm_val)
        nodalnormals(:, j, i) = normals(:, j-1, i-1)/norm_val
      end do
    end do
! set the boundary normals
    nodalnormals(:, 2:, 1) = panelnormals(:, :, 1)
    nodalnormals(:, 1, :numnodes-1) = panelnormals(:, 1, :)
    nodalnormals(:, :numlayers-1, numnodes) = panelnormals(:, :, &
&     numnodes-1)
    nodalnormals(:, numlayers, 2:) = panelnormals(:, numlayers-1, :)
! setup nodal derivatives
    nodalderivs(:, :, :, :) = zero
! compute interior derivatives using 2nd order central differencing
    nodalderivs(:, 1, 2:numlayers-1, 2:numnodes-1) = (xyz(:, 3:, 2:&
&     numnodes-1)-xyz(:, :numlayers-2, 2:numnodes-1))/2.
    nodalderivs(:, 2, 2:numlayers-1, 2:numnodes-1) = (xyz(:, 2:numlayers&
&     -1, 3:)-xyz(:, 2:numlayers-1, :numnodes-2))/2.
! compute i derivatives using 1st order differencing
    nodalderivs(:, 1, 1, :) = xyz(:, 2, :) - xyz(:, 1, :)
    nodalderivs(:, 1, numlayers, :) = xyz(:, numlayers, :) - xyz(:, &
&     numlayers-1, :)
    nodalderivs(:, 1, 2:numlayers-1, 1) = (xyz(:, 3:, 1)-xyz(:, :&
&     numlayers-2, 1))/2.
    nodalderivs(:, 1, 2:numlayers-1, numnodes) = (xyz(:, 3:, numnodes)-&
&     xyz(:, :numlayers-2, numnodes))/2.
! compute j derivatives using 1st order differencing
    nodalderivs(:, 2, :, 1) = xyz(:, :, 2) - xyz(:, :, 1)
    nodalderivs(:, 2, :, numnodes) = xyz(:, :, numnodes) - xyz(:, :, &
&     numnodes-1)
    nodalderivs(:, 2, 1, 2:numnodes-1) = (xyz(:, 1, 3:)-xyz(:, 1, :&
&     numnodes-2))/2.
    nodalderivs(:, 2, numlayers, 2:numnodes-1) = (xyz(:, numlayers, 3:)-&
&     xyz(:, numlayers, :numnodes-2))/2.
! assemble nodal jacobians
    nodaljacs(:, :, :, :) = zero
    nodaljacs(1, :, :, :) = nodalderivs(:, 1, :, :)
    nodaljacs(2, :, :, :) = nodalderivs(:, 2, :, :)
    nodaljacs(3, :, :, :) = nodalnormals(:, :, :)
! compute determinants of jacobians and find ratio of min to max per face
    ratios(:, :) = zero
! compute the determinants of each nodal jacobian
    do i=1,numnodes
      do j=1,numlayers
        call m33det(nodaljacs(:, :, j, i), det(j, i))
      end do
    end do
! find the ratio of the minimum valued determinant to the maximum
! valued determinant.
! this is a measure of quality, with 1 being desirable and anything
! less than 0 meaning the mesh is no longer valid.
    do i=1,numnodes-1
      do j=1,numlayers-1
        result1 = minval(det(j:j+1, i:i+1))
        result2 = maxval(det(j:j+1, i:i+1))
        ratios(j, i) = result1/result2
      end do
    end do
    fail = 0
! throw an error and set the failure flag if the mesh is not valid
    do i=1,numnodes-1
      do j=1,numlayers-1
        if ((ratios(j, i) .ne. ratios(j, i) .or. ratios(j, i) .le. zero)&
&           .and. layerindex .ge. 1) then
          print*, '========= failure detected ============'
          fail = 1
        end if
      end do
    end do
    if (fail .eq. 1) print*, 'the mesh is not valid after step', &
&                    layerindex + 1
! throw a warning if the mesh is low quality
    result10 = minval(ratios)
    if (result10 .le. .2 .and. layerindex .ge. 1) print*, &
&                               'the mesh may be low quality after step'&
&                                                 , layerindex + 1
  end subroutine qualitycheck
!  differentiation of findradius in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: radius
!   with respect to varying inputs: r
!   rw status of diff variables: radius:out r:in
  subroutine findradius_d(r, rd, numnodes, radius, radiusd)
    implicit none
    integer(kind=inttype), intent(in) :: numnodes
    real(kind=realtype), intent(in) :: r(3*numnodes)
    real(kind=realtype), intent(in) :: rd(3*numnodes)
    real(kind=realtype), intent(out) :: radius
    real(kind=realtype), intent(out) :: radiusd
    real(kind=realtype) :: x, y, z
    real(kind=realtype) :: xd, yd, zd
    real(kind=realtype) :: minx, maxx, miny, maxy, minz, maxz
    real(kind=realtype) :: minxd, maxxd, minyd, maxyd, minzd, maxzd
    integer(kind=inttype) :: i
    minx = 1.e20
    miny = 1.e20
    minz = 1.e20
    maxx = -1.e20
    maxy = -1.e20
    maxz = -1.e20
    minxd = 0.0_8
    minyd = 0.0_8
    minzd = 0.0_8
    maxxd = 0.0_8
    maxyd = 0.0_8
    maxzd = 0.0_8
! split coordinates and find max and min values
    do i=1,numnodes
      xd = rd(3*(i-1)+1)
      x = r(3*(i-1)+1)
      if (x .gt. maxx) then
        maxxd = xd
        maxx = x
      end if
      if (x .lt. minx) then
        minxd = xd
        minx = x
      end if
      yd = rd(3*(i-1)+2)
      y = r(3*(i-1)+2)
      if (y .gt. maxy) then
        maxyd = yd
        maxy = y
      end if
      if (y .lt. miny) then
        minyd = yd
        miny = y
      end if
      zd = rd(3*(i-1)+3)
      z = r(3*(i-1)+3)
      if (z .gt. maxz) then
        maxzd = zd
        maxz = z
      end if
      if (z .lt. minz) then
        minzd = zd
        minz = z
      end if
    end do
! find largest radius (we give only half of the largest side to be considered as radius)
    radius = -1.e20
    if (maxx - minx .gt. radius) then
      radiusd = maxxd - minxd
      radius = maxx - minx
    else
      radiusd = 0.0_8
    end if
    if (maxy - miny .gt. radius) then
      radiusd = maxyd - minyd
      radius = maxy - miny
    end if
    if (maxz - minz .gt. radius) then
      radiusd = maxzd - minzd
      radius = maxz - minz
    end if
    radiusd = radiusd/2.
    radius = radius/2.
  end subroutine findradius_d
  subroutine findradius(r, numnodes, radius)
    implicit none
    integer(kind=inttype), intent(in) :: numnodes
    real(kind=realtype), intent(in) :: r(3*numnodes)
    real(kind=realtype), intent(out) :: radius
    real(kind=realtype) :: x, y, z
    real(kind=realtype) :: minx, maxx, miny, maxy, minz, maxz
    integer(kind=inttype) :: i
    minx = 1.e20
    miny = 1.e20
    minz = 1.e20
    maxx = -1.e20
    maxy = -1.e20
    maxz = -1.e20
! split coordinates and find max and min values
    do i=1,numnodes
      x = r(3*(i-1)+1)
      if (x .gt. maxx) maxx = x
      if (x .lt. minx) minx = x
      y = r(3*(i-1)+2)
      if (y .gt. maxy) maxy = y
      if (y .lt. miny) miny = y
      z = r(3*(i-1)+3)
      if (z .gt. maxz) maxz = z
      if (z .lt. minz) minz = z
    end do
! find largest radius (we give only half of the largest side to be considered as radius)
    radius = -1.e20
    if (maxx - minx .gt. radius) radius = maxx - minx
    if (maxy - miny .gt. radius) radius = maxy - miny
    if (maxz - minz .gt. radius) radius = maxz - minz
    radius = radius/2.
  end subroutine findradius
!  differentiation of findratio in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: q
!   with respect to varying inputs: d0 dmax
!   rw status of diff variables: q:out d0:in dmax:in
  subroutine findratio_d(dmax, dmaxd, d0, d0d, numlayers, ratioguess, q&
&   , qd)
    implicit none
    real(kind=realtype), intent(in) :: dmax, d0, ratioguess
    real(kind=realtype), intent(in) :: dmaxd, d0d
    integer(kind=inttype), intent(in) :: numlayers
    real(kind=realtype), intent(out) :: q
    real(kind=realtype), intent(out) :: qd
    real(kind=realtype) :: rdot, r
    real(kind=realtype) :: rdotd, rd
    integer(kind=inttype) :: niters
! note that this counter is not the inttype that we use for all other integers.
! this is done so that tapenade correctly backwards differentiates this subroutine.
    integer :: i
    integer :: pwy1
    real(kind=realtype) :: pwr1
    real(kind=realtype) :: pwr1d
! extra parameters
! maximum number of iterations for newton search
    niters = 200
! initialize ratio
    q = ratioguess
    qd = 0.0_8
! newton search loop
    do i=1,niters
! residual function
      pwy1 = numlayers - 1
      if (q .gt. 0.0_8 .or. (q .lt. 0.0_8 .and. pwy1 .eq. int(pwy1))) &
&     then
        pwr1d = pwy1*q**(pwy1-1)*qd
      else if (q .eq. 0.0_8 .and. pwy1 .eq. 1.0) then
        pwr1d = qd
      else
        pwr1d = 0.0_8
      end if
      pwr1 = q**pwy1
      rd = d0d*(1.-pwr1) - d0*pwr1d - dmaxd*(1.-q) + dmax*qd
      r = d0*(1.-pwr1) - dmax*(1.-q)
! residual derivative
      pwy1 = numlayers - 2
      if (q .gt. 0.0_8 .or. (q .lt. 0.0_8 .and. pwy1 .eq. int(pwy1))) &
&     then
        pwr1d = pwy1*q**(pwy1-1)*qd
      else if (q .eq. 0.0_8 .and. pwy1 .eq. 1.0) then
        pwr1d = qd
      else
        pwr1d = 0.0_8
      end if
      pwr1 = q**pwy1
      rdotd = dmaxd - (numlayers-1)*(d0d*pwr1+d0*pwr1d)
      rdot = -((numlayers-1)*d0*pwr1) + dmax
! update ratio with newton search
      qd = qd - (rd*rdot-r*rdotd)/rdot**2
      q = q - r/rdot
    end do
! check if we got a reasonable value
    if (q .le. 1 .or. q .ge. ratioguess) then
      print*, ''
      print*, ''
      stop
    end if
  end subroutine findratio_d
  subroutine findratio(dmax, d0, numlayers, ratioguess, q)
    implicit none
    real(kind=realtype), intent(in) :: dmax, d0, ratioguess
    integer(kind=inttype), intent(in) :: numlayers
    real(kind=realtype), intent(out) :: q
    real(kind=realtype) :: rdot, r
    integer(kind=inttype) :: niters
! note that this counter is not the inttype that we use for all other integers.
! this is done so that tapenade correctly backwards differentiates this subroutine.
    integer :: i
    integer :: pwy1
    real(kind=realtype) :: pwr1
! extra parameters
! maximum number of iterations for newton search
    niters = 200
! initialize ratio
    q = ratioguess
! newton search loop
    do i=1,niters
! residual function
      pwy1 = numlayers - 1
      pwr1 = q**pwy1
      r = d0*(1.-pwr1) - dmax*(1.-q)
! residual derivative
      pwy1 = numlayers - 2
      pwr1 = q**pwy1
      rdot = -((numlayers-1)*d0*pwr1) + dmax
! update ratio with newton search
      q = q - r/rdot
    end do
! check if we got a reasonable value
    if (q .le. 1 .or. q .ge. ratioguess) then
      print*, ''
      print*, ''
      stop
    end if
  end subroutine findratio
!  differentiation of redistribute_nodes_by_arc_length in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: rremeshed
!   with respect to varying inputs: r startarclength
!   rw status of diff variables: r:in rremeshed:out startarclength:in
  subroutine redistribute_nodes_by_arc_length_d(r, rd, startarclength, &
&   startarclengthd, nnodes, rremeshed, rremeshedd)
    implicit none
    integer(kind=inttype), intent(in) :: nnodes
    real(kind=realtype), intent(in) :: r(nnodes*3)
    real(kind=realtype), intent(in) :: rd(nnodes*3)
    real(kind=realtype), intent(in) :: startarclength(nnodes)
    real(kind=realtype), intent(in) :: startarclengthd(nnodes)
    real(kind=realtype), intent(out) :: rremeshed(nnodes*3)
    real(kind=realtype), intent(out) :: rremeshedd(nnodes*3)
    real(kind=realtype) :: arclength(nnodes)
    real(kind=realtype) :: arclengthd(nnodes)
! compute arclengths of the original curve
    call compute_arc_length_d(r, rd, nnodes, arclength, arclengthd)
! interpolate new nodes
! now we sample the new coordinates based on the interpolation method given by the user
! create interpolants for x, y, and z
    rremeshedd = 0.0_8
    call interp1d_d(1, nnodes, arclength, arclengthd, r(1:3*nnodes-2:3)&
&             , rd(1:3*nnodes-2:3), nnodes, startarclength, &
&             startarclengthd, rremeshed(1:3*nnodes-2:3), rremeshedd(1:3&
&             *nnodes-2:3))
    call interp1d_d(1, nnodes, arclength, arclengthd, r(2:3*nnodes-1:3)&
&             , rd(2:3*nnodes-1:3), nnodes, startarclength, &
&             startarclengthd, rremeshed(2:3*nnodes-1:3), rremeshedd(2:3&
&             *nnodes-1:3))
    call interp1d_d(1, nnodes, arclength, arclengthd, r(3:3*nnodes:3), &
&             rd(3:3*nnodes:3), nnodes, startarclength, startarclengthd&
&             , rremeshed(3:3*nnodes:3), rremeshedd(3:3*nnodes:3))
  end subroutine redistribute_nodes_by_arc_length_d
!  differentiation of compute_arc_length in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: arclength
!   with respect to varying inputs: r
!   rw status of diff variables: r:in arclength:out
  subroutine compute_arc_length_d(r, rd, nnodes, arclength, arclengthd)
    implicit none
    integer(kind=inttype), intent(in) :: nnodes
    real(kind=realtype), intent(in) :: r(nnodes*3)
    real(kind=realtype), intent(in) :: rd(nnodes*3)
    real(kind=realtype), intent(out) :: arclength(nnodes)
    real(kind=realtype), intent(out) :: arclengthd(nnodes)
    real(kind=realtype) :: node1(3), node2(3), dist
    real(kind=realtype) :: node1d(3), node2d(3), distd
    integer(kind=inttype) :: nodeid
! store coordinates of the first node (the other nodes will be covered in the loop)
    node1d = rd(1:3)
    node1 = r(1:3)
    arclength(1) = 0.
    arclengthd = 0.0_8
! loop over each element to increment arclength
    do nodeid=2,nnodes
! get coordinates of the next node
      node2d = rd(3*(nodeid-1)+1:3*(nodeid-1)+3)
      node2 = r(3*(nodeid-1)+1:3*(nodeid-1)+3)
! compute distance between nodes
      call norm_d0(node1 - node2, node1d - node2d, dist, distd)
! store nodal arc-length
      arclengthd(nodeid) = arclengthd(nodeid-1) + distd
      arclength(nodeid) = arclength(nodeid-1) + dist
! store coordinates for the next loop
      node1d = node2d
      node1 = node2
    end do
! normalize the arc-lengths
    arclengthd = (arclengthd*arclength(nnodes)-arclength*arclengthd(&
&     nnodes))/arclength(nnodes)**2
    arclength = arclength/arclength(nnodes)
  end subroutine compute_arc_length_d
  subroutine redistribute_nodes_by_arc_length(r, startarclength, nnodes&
&   , rremeshed)
    implicit none
    integer(kind=inttype), intent(in) :: nnodes
    real(kind=realtype), intent(in) :: r(nnodes*3)
    real(kind=realtype), intent(in) :: startarclength(nnodes)
    real(kind=realtype), intent(out) :: rremeshed(nnodes*3)
    real(kind=realtype) :: arclength(nnodes)
! compute arclengths of the original curve
    call compute_arc_length(r, nnodes, arclength)
! interpolate new nodes
! now we sample the new coordinates based on the interpolation method given by the user
! create interpolants for x, y, and z
    call interp1d(1, nnodes, arclength, r(1:3*nnodes-2:3), nnodes, &
&           startarclength, rremeshed(1:3*nnodes-2:3))
    call interp1d(1, nnodes, arclength, r(2:3*nnodes-1:3), nnodes, &
&           startarclength, rremeshed(2:3*nnodes-1:3))
    call interp1d(1, nnodes, arclength, r(3:3*nnodes:3), nnodes, &
&           startarclength, rremeshed(3:3*nnodes:3))
  end subroutine redistribute_nodes_by_arc_length
  subroutine compute_arc_length(r, nnodes, arclength)
    implicit none
    integer(kind=inttype), intent(in) :: nnodes
    real(kind=realtype), intent(in) :: r(nnodes*3)
    real(kind=realtype), intent(out) :: arclength(nnodes)
    real(kind=realtype) :: node1(3), node2(3), dist
    integer(kind=inttype) :: nodeid
! store coordinates of the first node (the other nodes will be covered in the loop)
    node1 = r(1:3)
    arclength(1) = 0.
! loop over each element to increment arclength
    do nodeid=2,nnodes
! get coordinates of the next node
      node2 = r(3*(nodeid-1)+1:3*(nodeid-1)+3)
! compute distance between nodes
      call norm(node1 - node2, dist)
! store nodal arc-length
      arclength(nodeid) = arclength(nodeid-1) + dist
! store coordinates for the next loop
      node1 = node2
    end do
! normalize the arc-lengths
    arclength = arclength/arclength(nnodes)
  end subroutine compute_arc_length
!  differentiation of interp1d in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: p_interp
!   with respect to varying inputs: p_interp p_data t_data t_interp
  subroutine interp1d_d(m, data_num, t_data, t_datad, p_data, p_datad, &
&   interp_num, t_interp, t_interpd, p_interp, p_interpd)
    implicit none
    integer(kind=inttype) :: data_num
    integer(kind=inttype) :: m
    integer(kind=inttype) :: interp_num
    integer(kind=inttype) :: interp
    integer(kind=inttype) :: left
    real(kind=realtype) :: p_data(data_num)
    real(kind=realtype) :: p_datad(data_num)
    real(kind=realtype) :: p_interp(interp_num)
    real(kind=realtype) :: p_interpd(interp_num)
    integer(kind=inttype) :: right
    real(kind=realtype) :: t
    real(kind=realtype) :: td
    real(kind=realtype) :: t_data(data_num)
    real(kind=realtype) :: t_datad(data_num)
    real(kind=realtype) :: t_interp(interp_num)
    real(kind=realtype) :: t_interpd(interp_num)
    do interp=1,interp_num
      td = t_interpd(interp)
      t = t_interp(interp)
!
!  find the interval [ tdata(left), tdata(right) ] that contains, or is
!  nearest to, tval.
!
      call r8vec_bracket(data_num, t_data, t, left, right)
      p_interpd(interp) = (((t_datad(right)-td)*p_data(left)+(t_data(&
&       right)-t)*p_datad(left)+(td-t_datad(left))*p_data(right)+(t-&
&       t_data(left))*p_datad(right))*(t_data(right)-t_data(left))-((&
&       t_data(right)-t)*p_data(left)+(t-t_data(left))*p_data(right))*(&
&       t_datad(right)-t_datad(left)))/(t_data(right)-t_data(left))**2
      p_interp(interp) = ((t_data(right)-t)*p_data(left)+(t-t_data(left)&
&       )*p_data(right))/(t_data(right)-t_data(left))
    end do
    return
  end subroutine interp1d_d
  subroutine interp1d(m, data_num, t_data, p_data, interp_num, t_interp&
&   , p_interp)
    implicit none
    integer(kind=inttype) :: data_num
    integer(kind=inttype) :: m
    integer(kind=inttype) :: interp_num
    integer(kind=inttype) :: interp
    integer(kind=inttype) :: left
    real(kind=realtype) :: p_data(data_num)
    real(kind=realtype) :: p_interp(interp_num)
    integer(kind=inttype) :: right
    real(kind=realtype) :: t
    real(kind=realtype) :: t_data(data_num)
    real(kind=realtype) :: t_interp(interp_num)
    do interp=1,interp_num
      t = t_interp(interp)
!
!  find the interval [ tdata(left), tdata(right) ] that contains, or is
!  nearest to, tval.
!
      call r8vec_bracket(data_num, t_data, t, left, right)
      p_interp(interp) = ((t_data(right)-t)*p_data(left)+(t-t_data(left)&
&       )*p_data(right))/(t_data(right)-t_data(left))
    end do
    return
  end subroutine interp1d
  subroutine r8vec_bracket(n, x, xval, left, right)
    implicit none
    integer(kind=inttype) :: n
    integer(kind=inttype) :: i
    integer(kind=inttype) :: left
    integer(kind=inttype) :: right
    real(kind=realtype) :: x(n)
    real(kind=realtype) :: xval
    do i=2,n-1
      if (xval .lt. x(i)) then
        left = i - 1
        right = i
        return
      end if
    end do
    left = n - 1
    right = n
    return
  end subroutine r8vec_bracket
!  differentiation of matinv3 in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: b
!   with respect to varying inputs: a
  subroutine matinv3_d(a, ad, b, bd)
    implicit none
!! performs a direct calculation of the inverse of a 3×3 matrix.
!! matrix
    real(kind=realtype), intent(in) :: a(3, 3)
    real(kind=realtype), intent(in) :: ad(3, 3)
!! inverse matrix
    real(kind=realtype), intent(out) :: b(3, 3)
    real(kind=realtype), intent(out) :: bd(3, 3)
    real(kind=realtype) :: detinv
    real(kind=realtype) :: detinvd
!f2py intent(in) a
!f2py intent(out) b
! calculate the inverse determinant of the matrix
    detinvd = (-((ad(1, 1)*a(2, 2)+a(1, 1)*ad(2, 2))*a(3, 3)+a(1, 1)*a(2&
&     , 2)*ad(3, 3)-(ad(1, 1)*a(2, 3)+a(1, 1)*ad(2, 3))*a(3, 2)-a(1, 1)*&
&     a(2, 3)*ad(3, 2)-(ad(1, 2)*a(2, 1)+a(1, 2)*ad(2, 1))*a(3, 3)-a(1, &
&     2)*a(2, 1)*ad(3, 3)+(ad(1, 2)*a(2, 3)+a(1, 2)*ad(2, 3))*a(3, 1)+a(&
&     1, 2)*a(2, 3)*ad(3, 1)+(ad(1, 3)*a(2, 1)+a(1, 3)*ad(2, 1))*a(3, 2)&
&     +a(1, 3)*a(2, 1)*ad(3, 2)-(ad(1, 3)*a(2, 2)+a(1, 3)*ad(2, 2))*a(3&
&     , 1)-a(1, 3)*a(2, 2)*ad(3, 1)))/(a(1, 1)*a(2, 2)*a(3, 3)-a(1, 1)*a&
&     (2, 3)*a(3, 2)-a(1, 2)*a(2, 1)*a(3, 3)+a(1, 2)*a(2, 3)*a(3, 1)+a(1&
&     , 3)*a(2, 1)*a(3, 2)-a(1, 3)*a(2, 2)*a(3, 1))**2
    detinv = 1/(a(1, 1)*a(2, 2)*a(3, 3)-a(1, 1)*a(2, 3)*a(3, 2)-a(1, 2)*&
&     a(2, 1)*a(3, 3)+a(1, 2)*a(2, 3)*a(3, 1)+a(1, 3)*a(2, 1)*a(3, 2)-a(&
&     1, 3)*a(2, 2)*a(3, 1))
! calculate the inverse of the matrix
    bd = 0.0_8
    bd(1, 1) = detinvd*(a(2, 2)*a(3, 3)-a(2, 3)*a(3, 2)) + detinv*(ad(2&
&     , 2)*a(3, 3)+a(2, 2)*ad(3, 3)-ad(2, 3)*a(3, 2)-a(2, 3)*ad(3, 2))
    b(1, 1) = detinv*(a(2, 2)*a(3, 3)-a(2, 3)*a(3, 2))
    bd(2, 1) = -(detinvd*(a(2, 1)*a(3, 3)-a(2, 3)*a(3, 1))+detinv*(ad(2&
&     , 1)*a(3, 3)+a(2, 1)*ad(3, 3)-ad(2, 3)*a(3, 1)-a(2, 3)*ad(3, 1)))
    b(2, 1) = -(detinv*(a(2, 1)*a(3, 3)-a(2, 3)*a(3, 1)))
    bd(3, 1) = detinvd*(a(2, 1)*a(3, 2)-a(2, 2)*a(3, 1)) + detinv*(ad(2&
&     , 1)*a(3, 2)+a(2, 1)*ad(3, 2)-ad(2, 2)*a(3, 1)-a(2, 2)*ad(3, 1))
    b(3, 1) = detinv*(a(2, 1)*a(3, 2)-a(2, 2)*a(3, 1))
    bd(1, 2) = -(detinvd*(a(1, 2)*a(3, 3)-a(1, 3)*a(3, 2))+detinv*(ad(1&
&     , 2)*a(3, 3)+a(1, 2)*ad(3, 3)-ad(1, 3)*a(3, 2)-a(1, 3)*ad(3, 2)))
    b(1, 2) = -(detinv*(a(1, 2)*a(3, 3)-a(1, 3)*a(3, 2)))
    bd(2, 2) = detinvd*(a(1, 1)*a(3, 3)-a(1, 3)*a(3, 1)) + detinv*(ad(1&
&     , 1)*a(3, 3)+a(1, 1)*ad(3, 3)-ad(1, 3)*a(3, 1)-a(1, 3)*ad(3, 1))
    b(2, 2) = detinv*(a(1, 1)*a(3, 3)-a(1, 3)*a(3, 1))
    bd(3, 2) = -(detinvd*(a(1, 1)*a(3, 2)-a(1, 2)*a(3, 1))+detinv*(ad(1&
&     , 1)*a(3, 2)+a(1, 1)*ad(3, 2)-ad(1, 2)*a(3, 1)-a(1, 2)*ad(3, 1)))
    b(3, 2) = -(detinv*(a(1, 1)*a(3, 2)-a(1, 2)*a(3, 1)))
    bd(1, 3) = detinvd*(a(1, 2)*a(2, 3)-a(1, 3)*a(2, 2)) + detinv*(ad(1&
&     , 2)*a(2, 3)+a(1, 2)*ad(2, 3)-ad(1, 3)*a(2, 2)-a(1, 3)*ad(2, 2))
    b(1, 3) = detinv*(a(1, 2)*a(2, 3)-a(1, 3)*a(2, 2))
    bd(2, 3) = -(detinvd*(a(1, 1)*a(2, 3)-a(1, 3)*a(2, 1))+detinv*(ad(1&
&     , 1)*a(2, 3)+a(1, 1)*ad(2, 3)-ad(1, 3)*a(2, 1)-a(1, 3)*ad(2, 1)))
    b(2, 3) = -(detinv*(a(1, 1)*a(2, 3)-a(1, 3)*a(2, 1)))
    bd(3, 3) = detinvd*(a(1, 1)*a(2, 2)-a(1, 2)*a(2, 1)) + detinv*(ad(1&
&     , 1)*a(2, 2)+a(1, 1)*ad(2, 2)-ad(1, 2)*a(2, 1)-a(1, 2)*ad(2, 1))
    b(3, 3) = detinv*(a(1, 1)*a(2, 2)-a(1, 2)*a(2, 1))
  end subroutine matinv3_d
  subroutine matinv3(a, b)
    implicit none
!! performs a direct calculation of the inverse of a 3×3 matrix.
!! matrix
    real(kind=realtype), intent(in) :: a(3, 3)
!! inverse matrix
    real(kind=realtype), intent(out) :: b(3, 3)
    real(kind=realtype) :: detinv
!f2py intent(in) a
!f2py intent(out) b
! calculate the inverse determinant of the matrix
    detinv = 1/(a(1, 1)*a(2, 2)*a(3, 3)-a(1, 1)*a(2, 3)*a(3, 2)-a(1, 2)*&
&     a(2, 1)*a(3, 3)+a(1, 2)*a(2, 3)*a(3, 1)+a(1, 3)*a(2, 1)*a(3, 2)-a(&
&     1, 3)*a(2, 2)*a(3, 1))
! calculate the inverse of the matrix
    b(1, 1) = detinv*(a(2, 2)*a(3, 3)-a(2, 3)*a(3, 2))
    b(2, 1) = -(detinv*(a(2, 1)*a(3, 3)-a(2, 3)*a(3, 1)))
    b(3, 1) = detinv*(a(2, 1)*a(3, 2)-a(2, 2)*a(3, 1))
    b(1, 2) = -(detinv*(a(1, 2)*a(3, 3)-a(1, 3)*a(3, 2)))
    b(2, 2) = detinv*(a(1, 1)*a(3, 3)-a(1, 3)*a(3, 1))
    b(3, 2) = -(detinv*(a(1, 1)*a(3, 2)-a(1, 2)*a(3, 1)))
    b(1, 3) = detinv*(a(1, 2)*a(2, 3)-a(1, 3)*a(2, 2))
    b(2, 3) = -(detinv*(a(1, 1)*a(2, 3)-a(1, 3)*a(2, 1)))
    b(3, 3) = detinv*(a(1, 1)*a(2, 2)-a(1, 2)*a(2, 1))
  end subroutine matinv3
!  differentiation of giveangle in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: angle
!   with respect to varying inputs: r0 r1 r2
  subroutine giveangle_d(r0, r0d, r1, r1d, r2, r2d, n1, angle, angled)
    implicit none
    real(kind=realtype), dimension(3), intent(in) :: r0, r1, r2, n1
    real(kind=realtype), dimension(3), intent(in) :: r0d, r1d, r2d
!f2py intent(in) r0, r1, r2, n1
!f2py intent(out) angle
    real(kind=realtype), dimension(3) :: dr1, dr2, dr1crossdr2
    real(kind=realtype), dimension(3) :: dr1d, dr2d
    real(kind=realtype) :: dr1dotdr2, arccos_inside, pi, one, angle, tmp
    real(kind=realtype) :: dr1dotdr2d, arccos_insided, angled
    real(kind=realtype) :: normdr1, normdr2, dr1crossdr2dotn1
    real(kind=realtype) :: normdr1d, normdr2d
    intrinsic min
    intrinsic dacos
    real(kind=realtype) :: min1
    real(kind=realtype) :: min1d
    pi = 3.14159265358979323846264338
    one = 1.0
    dr1d = r1d - r0d
    dr1 = r1 - r0
    dr2d = r2d - r1d
    dr2 = r2 - r1
    call dot_d0(dr1, dr1d, dr2, dr2d, dr1dotdr2, dr1dotdr2d)
! dot product
    call cross(dr1, dr2, dr1crossdr2)
! cross product
! compute acute angle and ensure it's <= 1.0
    call norm_d0(dr1, dr1d, normdr1, normdr1d)
    call norm_d0(dr2, dr2d, normdr2, normdr2d)
    arccos_insided = ((dr1dotdr2d*normdr1-dr1dotdr2*normdr1d)*normdr2/&
&     normdr1**2-dr1dotdr2*normdr2d/normdr1)/normdr2**2
    arccos_inside = dr1dotdr2/normdr1/normdr2
    if (arccos_inside .gt. one) then
      min1 = one
      min1d = 0.0_8
    else
      min1d = arccos_insided
      min1 = arccos_inside
    end if
    if (min1 .eq. 1.0 .or. min1 .eq. (-1.0)) then
      angled = 0.0_8
    else
      angled = -(min1d/sqrt(1.d0-min1**2))
    end if
    angle = dacos(min1)
! if the cross product points in the same direction of the surface
! normal, we have an acute corner
    call dot(dr1crossdr2, n1, dr1crossdr2dotn1)
    if (dr1crossdr2dotn1 .gt. 0.) then
      angle = pi + angle
    else
      angled = -angled
      angle = pi - angle
    end if
  end subroutine giveangle_d
  subroutine giveangle(r0, r1, r2, n1, angle)
    implicit none
    real(kind=realtype), dimension(3), intent(in) :: r0, r1, r2, n1
!f2py intent(in) r0, r1, r2, n1
!f2py intent(out) angle
    real(kind=realtype), dimension(3) :: dr1, dr2, dr1crossdr2
    real(kind=realtype) :: dr1dotdr2, arccos_inside, pi, one, angle, tmp
    real(kind=realtype) :: normdr1, normdr2, dr1crossdr2dotn1
    intrinsic min
    intrinsic dacos
    real(kind=realtype) :: min1
    pi = 3.14159265358979323846264338
    one = 1.0
    dr1 = r1 - r0
    dr2 = r2 - r1
    call dot(dr1, dr2, dr1dotdr2)
! dot product
    call cross(dr1, dr2, dr1crossdr2)
! cross product
! compute acute angle and ensure it's <= 1.0
    call norm(dr1, normdr1)
    call norm(dr2, normdr2)
    arccos_inside = dr1dotdr2/normdr1/normdr2
    if (arccos_inside .gt. one) then
      min1 = one
    else
      min1 = arccos_inside
    end if
    angle = dacos(min1)
! if the cross product points in the same direction of the surface
! normal, we have an acute corner
    call dot(dr1crossdr2, n1, dr1crossdr2dotn1)
    if (dr1crossdr2dotn1 .gt. 0.) then
      angle = pi + angle
    else
      angle = pi - angle
    end if
  end subroutine giveangle
!  differentiation of dot in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: dot_
!   with respect to varying inputs: a b
!============================================================
  subroutine dot_d0(a, ad, b, bd, dot_, dot_d)
    implicit none
    real(kind=realtype), intent(in) :: a(3), b(3)
    real(kind=realtype), intent(in) :: ad(3), bd(3)
    real(kind=realtype), intent(out) :: dot_
    real(kind=realtype), intent(out) :: dot_d
    dot_d = ad(1)*b(1) + a(1)*bd(1) + ad(2)*b(2) + a(2)*bd(2) + ad(3)*b(&
&     3) + a(3)*bd(3)
    dot_ = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
  end subroutine dot_d0
!============================================================
  subroutine dot(a, b, dot_)
    implicit none
    real(kind=realtype), intent(in) :: a(3), b(3)
    real(kind=realtype), intent(out) :: dot_
    dot_ = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
  end subroutine dot
!  differentiation of norm in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: norm_
!   with respect to varying inputs: a
!============================================================
  subroutine norm_d0(a, ad, norm_, norm_d)
    implicit none
    real(kind=realtype), intent(in) :: a(3)
    real(kind=realtype), intent(in) :: ad(3)
    real(kind=realtype), intent(out) :: norm_
    real(kind=realtype), intent(out) :: norm_d
    intrinsic dsqrt
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
    arg1d = ad(1)*a(1) + a(1)*ad(1) + ad(2)*a(2) + a(2)*ad(2) + ad(3)*a(&
&     3) + a(3)*ad(3)
    arg1 = a(1)*a(1) + a(2)*a(2) + a(3)*a(3)
    if (arg1 .eq. 0.0_8) then
      norm_d = 0.0_8
    else
      norm_d = arg1d/(2.d0*dsqrt(arg1))
    end if
    norm_ = dsqrt(arg1)
  end subroutine norm_d0
!============================================================
  subroutine norm(a, norm_)
    implicit none
    real(kind=realtype), intent(in) :: a(3)
    real(kind=realtype), intent(out) :: norm_
    intrinsic dsqrt
    real(kind=realtype) :: arg1
    arg1 = a(1)*a(1) + a(2)*a(2) + a(3)*a(3)
    norm_ = dsqrt(arg1)
  end subroutine norm
!  differentiation of cross in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: c
!   with respect to varying inputs: a b c
  subroutine cross_d(a, ad, b, bd, c, cd)
    implicit none
    real(kind=realtype), intent(in) :: a(3), b(3)
    real(kind=realtype), intent(in) :: ad(3), bd(3)
    real(kind=realtype), intent(out) :: c(3)
    real(kind=realtype), intent(out) :: cd(3)
    cd(1) = ad(2)*b(3) + a(2)*bd(3) - ad(3)*b(2) - a(3)*bd(2)
    c(1) = a(2)*b(3) - a(3)*b(2)
    cd(2) = ad(3)*b(1) + a(3)*bd(1) - ad(1)*b(3) - a(1)*bd(3)
    c(2) = a(3)*b(1) - a(1)*b(3)
    cd(3) = ad(1)*b(2) + a(1)*bd(2) - ad(2)*b(1) - a(2)*bd(1)
    c(3) = a(1)*b(2) - a(2)*b(1)
  end subroutine cross_d
  subroutine cross(a, b, c)
    implicit none
    real(kind=realtype), intent(in) :: a(3), b(3)
    real(kind=realtype), intent(out) :: c(3)
    c(1) = a(2)*b(3) - a(3)*b(2)
    c(2) = a(3)*b(1) - a(1)*b(3)
    c(3) = a(1)*b(2) - a(2)*b(1)
  end subroutine cross
  subroutine m33det(a, det)
    implicit none
    real(kind=realtype), dimension(3, 3), intent(in) :: a
    real(kind=realtype), intent(out) :: det
    det = a(1, 1)*a(2, 2)*a(3, 3) - a(1, 1)*a(2, 3)*a(3, 2) - a(1, 2)*a(&
&     2, 1)*a(3, 3) + a(1, 2)*a(2, 3)*a(3, 1) + a(1, 3)*a(2, 1)*a(3, 2) &
&     - a(1, 3)*a(2, 2)*a(3, 1)
  end subroutine m33det
end module hypsurfmain_d
