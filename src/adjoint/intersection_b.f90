!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) - 22 Aug 2023 15:51
!
MODULE INTERSECTION_B
  USE UTILITIES_B
  USE PRECISION
  IMPLICIT NONE

CONTAINS
!============================================================
  SUBROUTINE FILTERELEMENTS(coor, triaconn, quadsconn, bbox, innertriaid&
&   , innerquadsid)
    IMPLICIT NONE
! INPUTS
    REAL(kind=realtype), DIMENSION(:, :), INTENT(IN) :: coor
    INTEGER(kind=inttype), DIMENSION(:, :), INTENT(IN) :: triaconn, &
&   quadsconn
    REAL(kind=realtype), DIMENSION(3, 2), INTENT(IN) :: bbox
! OUTPUTS
    INTEGER(kind=inttype), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: &
&   innertriaid, innerquadsid
! WORKING
    INTEGER(kind=inttype), DIMENSION(:), ALLOCATABLE :: extinnertriaid, &
&   extinnerquadsid
    LOGICAL, DIMENSION(:), ALLOCATABLE :: nodelocation
    INTEGER(kind=inttype), DIMENSION(:, :), ALLOCATABLE :: nodeontop
    INTEGER(kind=inttype) :: nnodes, ntria, nquads
    INTEGER(kind=inttype) :: elemid, nodeid
    INTEGER(kind=inttype) :: numinnertria, numinnerquads, i
    INTEGER(kind=inttype), DIMENSION(3) :: ontop
    REAL(kind=realtype) :: nodex, nodey, nodez
    LOGICAL :: nodeisinside
    INTRINSIC SIZE
! EXECUTION
! Get problem size
    nnodes = SIZE(coor, 2)
    ntria = SIZE(triaconn, 2)
    nquads = SIZE(quadsconn, 2)
! Allocate array that states whether a node is inside or outside of the BBox
! nodeLocation(nodeID) = .false. -> node is outside the BBox
! nodeLocation(nodeID) = .true.  -> node is inside the BBox
    ALLOCATE(nodelocation(nnodes))
    ALLOCATE(nodeontop(nnodes, 3))
! Initialize arrays
    nodelocation = .false.
    nodeontop = 0
! Now check each node
nodeloop:DO nodeid=1,nnodes
! Get current node coordinates
      nodex = coor(1, nodeid)
      nodey = coor(2, nodeid)
      nodez = coor(3, nodeid)
! Check each dimension
      IF (nodex .GE. bbox(1, 1) .AND. nodex .LE. bbox(1, 2)) THEN
        IF (nodey .GE. bbox(2, 1) .AND. nodey .LE. bbox(2, 2)) THEN
          IF (nodez .GE. bbox(3, 1) .AND. nodez .LE. bbox(3, 2)) &
&           nodelocation(nodeid) = .true.
        END IF
      END IF
! Check to see if all of the nodes are on the same side of the bounding box
! Check X dimension
      IF (nodex .GE. bbox(1, 2)) nodeontop(nodeid, 1) = 1
! Check Y dimension
      IF (nodey .GE. bbox(2, 2)) nodeontop(nodeid, 2) = 1
! Check Z dimension
      IF (nodez .GE. bbox(3, 2)) nodeontop(nodeid, 3) = 1
    END DO nodeloop
! Allocate extended arrays to store indices of the interior elements. In the worst
! case, all elements would be inside, so we would need to store nTria and nQuads
! indices in total.
    ALLOCATE(extinnertriaid(ntria))
    ALLOCATE(extinnerquadsid(nquads))
! Now we check all elements.
! If one node is inside the bounding box, then we flag the element as "inside"
! Initialize interior element counters
    numinnertria = 0
    numinnerquads = 0
! First we check triangles
trialoop:DO elemid=1,ntria
      ontop(:) = 0
! Loop over all the nodes of the element
      DO nodeid=1,3
! Get location flag of the current node
        nodeisinside = nodelocation(triaconn(nodeid, elemid))
! Flag the element if any node is inside
        IF (nodeisinside) THEN
          GOTO 100
        ELSE
! We do not need to check other nodes, so
! we jump out of the do loop
! Get a running sum of which nodes are on one side of the bounding box
          ontop = ontop + nodeontop(triaconn(nodeid, elemid), :)
        END IF
      END DO
! Check to see if all nodes are on the same side of the bounding box
! If any node is not on the same side as all the others, flag the element
! to check for intersections
 100  IF (nodeisinside .NEQV. .true.) THEN
        DO i=1,3
          IF (ontop(i) .NE. 0 .AND. ontop(i) .NE. 3) THEN
            nodeisinside = .true.
            GOTO 110
          END IF
        END DO
      END IF
 110  IF (nodeisinside) THEN
! Increment number of inside elements
        numinnertria = numinnertria + 1
! Store element index in the extended array
        extinnertriaid(numinnertria) = elemid
      END IF
    END DO trialoop
! Now we check quads
quadsloop:DO elemid=1,nquads
      ontop = 0
! Loop over all the nodes of the element
      DO nodeid=1,4
! Get location flag of the current node
        nodeisinside = nodelocation(quadsconn(nodeid, elemid))
! Flag the element if any node is inside
        IF (nodeisinside) THEN
          GOTO 120
        ELSE
! We do not need to check other nodes, so
! we jump out of the do loop
! Get a running sum of which nodes are on one side of the bounding box
          ontop = ontop + nodeontop(quadsconn(nodeid, elemid), :)
        END IF
      END DO
! Check to see if all nodes are on the same side of the bounding box
! If any node is not on the same side as all the others, flag the element
! to check for intersections
 120  IF (nodeisinside .NEQV. .true.) THEN
        DO i=1,3
          IF (ontop(i) .NE. 0 .AND. ontop(i) .NE. 4) THEN
            nodeisinside = .true.
            GOTO 130
          END IF
        END DO
      END IF
 130  IF (nodeisinside) THEN
! Increment number of inside elements
        numinnerquads = numinnerquads + 1
! Store element index in the extended array
        extinnerquadsid(numinnerquads) = elemid
      END IF
    END DO quadsloop
! Now that we know exactly how many elements are inside, we can
! allocate outputs arrays with the proper size
    ALLOCATE(innertriaid(numinnertria))
    ALLOCATE(innerquadsid(numinnerquads))
! Transfer values from the extended arrays to the output arrays
    innertriaid(:) = extinnertriaid(1:numinnertria)
    innerquadsid(:) = extinnerquadsid(1:numinnerquads)
! We can finally deallocate the extended arrays
    DEALLOCATE(extinnertriaid)
    DEALLOCATE(extinnerquadsid)
  END SUBROUTINE FILTERELEMENTS

!============================================================
  SUBROUTINE CONDENSEBARFES(disttol, coor, barsconn, newcoor)
    IMPLICIT NONE
! INPUTS
    REAL(kind=realtype), INTENT(IN) :: disttol
    REAL(kind=realtype), DIMENSION(:, :), INTENT(IN) :: coor
! OUTPUTS
    REAL(kind=realtype), DIMENSION(:, :), ALLOCATABLE, INTENT(OUT) :: &
&   newcoor
! INPUTS/OUTPUTS
    INTEGER(kind=inttype), DIMENSION(:, :), INTENT(INOUT) :: barsconn
! WORKING
    INTEGER(kind=inttype) :: nnodes, nelem, nuniquenodes, ncopies
    INTEGER(kind=inttype) :: currnodeid, prevnodeid, link, elemid
    REAL(kind=realtype), DIMENSION(3) :: currcoor, prevcoor
    REAL(kind=realtype) :: dist
    INTRINSIC SIZE
    INTEGER(kind=inttype), DIMENSION(SIZE(coor, 2)) :: linkold2new
    REAL(kind=realtype), DIMENSION(3) :: arg1
! EXECUTION
! Get problem size
    nnodes = SIZE(coor, 2)
    nelem = SIZE(barsconn, 2)
! Initialize number of unique nodes found so far.
! The first node is a unique one =P!
    nuniquenodes = 1
! As the first node is unique, its old-to-new link should point to itself
    linkold2new(1) = 1
! Loop over the nodes to find the unique ones
    DO currnodeid=2,nnodes
! Get coordinates of current node
      currcoor = coor(:, currnodeid)
! Now loop over the previous nodes to find if it is repeated
      DO prevnodeid=1,currnodeid-1
! Get coordinates of the previous node
        prevcoor = coor(:, prevnodeid)
! Compute distance between nodes
        arg1(:) = currcoor - prevcoor
        CALL NORM(arg1(:), dist)
! Check if the distance is below the merging tolerance
        IF (dist .LE. disttol) THEN
! Update link array.
! The array linkOld2New will contain newCoor indices that correspond to each
! coor index.
! So the current node should use the same link as the previous node, as they will
! point to the same index of the new coordinate array.
          linkold2new(currnodeid) = linkold2new(prevnodeid)
          GOTO 100
        END IF
      END DO
! Check if we did not find any copy. In this case, we need to initialize a new
! unique node
 100  IF (prevnodeid .EQ. currnodeid) THEN
! Increase the number of unique nodes found so far
        nuniquenodes = nuniquenodes + 1
! Create new link
        linkold2new(currnodeid) = nuniquenodes
      END IF
    END DO
! Now that we know the number of unique nodes, we can allocate memory for the new
! coordinate array.
    ALLOCATE(newcoor(3, nuniquenodes))
    newcoor = 0.0
! Initialize number of nodes copied so far
    ncopies = 0
! We loop once again over the nodes so we can copy the unique values
    DO currnodeid=1,nnodes
! Get coordinates of current node
      currcoor = coor(:, currnodeid)
! Get index of the current node in the new coordinate array
      link = linkold2new(currnodeid)
! Check if the new link is already used
      IF (link .GT. ncopies) THEN
! Increment number of copies done so far
        ncopies = ncopies + 1
! Copy coordinates
        newcoor(:, ncopies) = currcoor
      END IF
    END DO
! Now the last step is updating the bars connectivity.
! Loop over the elements
    DO elemid=1,nelem
! Update connectivities
      barsconn(1, elemid) = linkold2new(barsconn(1, elemid))
      barsconn(2, elemid) = linkold2new(barsconn(2, elemid))
    END DO
  END SUBROUTINE CONDENSEBARFES

!============================================================
  SUBROUTINE GETALLTRIAS(triaconn, quadsconn, innertriaid, innerquadsid&
&   , alltriaconn)
    IMPLICIT NONE
! INPUTS
    INTEGER(kind=inttype), DIMENSION(:, :), INTENT(IN) :: triaconn, &
&   quadsconn
    INTEGER(kind=inttype), DIMENSION(:), INTENT(IN) :: innertriaid, &
&   innerquadsid
! OUTPUTS
    INTEGER(kind=inttype), DIMENSION(:, :), ALLOCATABLE, INTENT(OUT) :: &
&   alltriaconn
! WORKING
    INTEGER(kind=inttype) :: ninnertria, ninnerquads, ii, node1, node2, &
&   node3, node4
    INTRINSIC SIZE
! EXECUTION
! Get number of interior elements
    ninnertria = SIZE(innertriaid)
    ninnerquads = SIZE(innerquadsid)
! Allocate connectivity arrays for triangles split from quads
    ALLOCATE(alltriaconn(3, ninnertria+ninnerquads*2))
! Copy connectivities of the interior triangles
    DO ii=1,ninnertria
      alltriaconn(:, ii) = triaconn(:, innertriaid(ii))
    END DO
! Loop over every interior element
    DO ii=1,ninnerquads
! Get nodes of the current quad
      node1 = quadsconn(1, innerquadsid(ii))
      node2 = quadsconn(2, innerquadsid(ii))
      node3 = quadsconn(3, innerquadsid(ii))
      node4 = quadsconn(4, innerquadsid(ii))
! Create two triangle elements
      alltriaconn(:, ninnertria+2*ii-1) = (/node1, node2, node3/)
      alltriaconn(:, ninnertria+2*ii) = (/node3, node4, node1/)
    END DO
  END SUBROUTINE GETALLTRIAS

!  Differentiation of tritriintersect in reverse (adjoint) mode:
!   gradient     of useful results: v0 v1 v2 vecend vecstart u0
!                u1 u2
!   with respect to varying inputs: v0 v1 v2 vecend vecstart u0
!                u1 u2
!   RW status of diff variables: v0:incr v1:incr v2:incr vecend:in-out
!                vecstart:in-out u0:incr u1:incr u2:incr
!============================================================
  SUBROUTINE TRITRIINTERSECT_B(v0, v0b, v1, v1b, v2, v2b, u0, u0b, u1, &
&   u1b, u2, u2b, intersect, vecstart, vecstartb, vecend, vecendb)
    IMPLICIT NONE
! This subroutine computes the line vector of intersection between two triangles
! John Jasa - 2016-08
!
! Adapted from Moller's 1997 paper "A Fast Triangle-Triangle Intersection Test"
!
! INPUTS:
!
! V0: real(3) -> coordinates (x,y,z) of the first node of triangle V
! V0: real(3) -> coordinates (x,y,z) of the second node of triangle V
! V0: real(3) -> coordinates (x,y,z) of the third node of triangle V
!
! U0: real(3) -> coordinates (x,y,z) of the first node of triangle U
! U0: real(3) -> coordinates (x,y,z) of the second node of triangle U
! U0: real(3) -> coordinates (x,y,z) of the third node of triangle U
!
! OUTPUTS:
!
! intersect: integer -> 1 if the triangles intersect, 0 if they do not
! vecStart: real(3) -> coordinates (x,y,z) of the start point of the intersection line
! vecEnd: real(3) -> coordinates (x,y,z) of the end point of the intersection line
! INPUTS
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: v0, v1, v2, u0, u1&
&   , u2
    REAL(kind=realtype), DIMENSION(3) :: v0b, v1b, v2b, u0b, u1b, u2b
! OUTPUTS
    INTEGER(kind=inttype) :: intersect
    REAL(kind=realtype), DIMENSION(3) :: vecstart, vecend
    REAL(kind=realtype), DIMENSION(3) :: vecstartb, vecendb
! WORKING
    REAL(kind=realtype), DIMENSION(3) :: e1, e2, n1, n2, dir
    REAL(kind=realtype), DIMENSION(3) :: e1b, e2b, n1b, n2b
    REAL(kind=realtype) :: d1, du0, du1, du2, du0du1, du0du2, epsilon
    REAL(kind=realtype) :: d1b, du0b, du1b, du2b
    REAL(kind=realtype) :: d2, dv0, dv1, dv2, dv0dv1, dv0dv2, maxd, bb, &
&   cc
    REAL(kind=realtype) :: d2b, dv0b, dv1b, dv2b
    REAL(kind=realtype) :: up0, up1, up2, vp0, vp1, vp2
    REAL(kind=realtype) :: isect1(2), isect2(2)
    REAL(kind=realtype), DIMENSION(3) :: isectpointa1, isectpointa2, &
&   isectpointb1, isectpointb2
    REAL(kind=realtype), DIMENSION(3) :: isectpointa1b, isectpointa2b, &
&   isectpointb1b, isectpointb2b
    INTEGER(kind=inttype) :: index
    INTEGER(kind=inttype) :: coplanar, smallest1, smallest2
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC MIN
    REAL(kind=realtype) :: max1
    REAL(kind=realtype) :: min1
    INTEGER :: branch
! Initialize intersect and coplanar values so the program does not stop prematurely
    intersect = 2
    coplanar = 0
! Compute plane of triangle (V0, V1, V2)
    e1 = v1 - v0
    e2 = v2 - v0
    CALL CROSS_PRODUCT(e1, e2, n1)
    CALL DOT(n1, v0, d1)
    d1 = -d1
! Get distances from U points to plane defined by V points
    CALL DOT(n1, u0, du0)
    du0 = du0 + d1
    CALL DOT(n1, u1, du1)
    du1 = du1 + d1
    CALL DOT(n1, u2, du2)
    du2 = du2 + d1
! Compute the signed distance product to see which side of the plane each point is on
    du0du1 = du0*du1
    du0du2 = du0*du2
! If all the points of one triangle are on the same side of the other triangle,
! there is no intersection
    IF (du0du1 .GT. 0.0 .AND. du0du2 .GT. 0.0) THEN
      du0b = 0.0_8
      du1b = 0.0_8
      du2b = 0.0_8
    ELSE
! Compute plane of triangle (U0, U1, U2)
      e1 = u1 - u0
      e2 = u2 - u0
      CALL CROSS_PRODUCT(e1, e2, n2)
      CALL DOT(n2, u0, d2)
      d2 = -d2
! Get distances from V points to plane defined by U points
      CALL DOT(n2, v0, dv0)
      dv0 = dv0 + d2
      CALL DOT(n2, v1, dv1)
      dv1 = dv1 + d2
      CALL DOT(n2, v2, dv2)
      dv2 = dv2 + d2
! Compute the signed distance product to see which side of the plane each point is on
      dv0dv1 = dv0*dv1
      dv0dv2 = dv0*dv2
! If all the points of one triangle are on the same side of the other triangle,
! there is no intersection
      IF (dv0dv1 .GT. 0.0 .AND. dv0dv2 .GT. 0.0) THEN
        dv0b = 0.0_8
        dv1b = 0.0_8
        dv2b = 0.0_8
        du0b = 0.0_8
        du1b = 0.0_8
        du2b = 0.0_8
      ELSE
! Compute the direction of the intersection line
        CALL CROSS_PRODUCT(n1, n2, dir)
        IF (dir(1) .GE. 0.) THEN
          maxd = dir(1)
        ELSE
          maxd = -dir(1)
        END IF
        index = 1
        IF (dir(2) .GE. 0.) THEN
          bb = dir(2)
        ELSE
          bb = -dir(2)
        END IF
        IF (dir(3) .GE. 0.) THEN
          cc = dir(3)
        ELSE
          cc = -dir(3)
        END IF
        IF (bb .GT. maxd) THEN
          maxd = bb
          index = 2
        END IF
        IF (cc .GT. maxd) index = 3
! Simplified projection onto L
        vp0 = v0(index)
        vp1 = v1(index)
        vp2 = v2(index)
        up0 = u0(index)
        up1 = u1(index)
        up2 = u2(index)
! isect1 and isect2 are the projected intersections of triangles 1 and 2,
! which are defined by the V and U points respectively.
! These isect values show where each triangle edge intersects the
! two triangle's intersection line
! Compute the intersection interval for the V points
        CALL COMPUTE_INTERVALS_ISECTLINE(v0, v1, v2, vp0, vp1, vp2, dv0&
&                                  , dv1, dv2, dv0dv1, dv0dv2, isect1(1)&
&                                  , isect1(2), isectpointa1, &
&                                  isectpointa2, coplanar, intersect)
        IF (intersect .EQ. 0) THEN
          isectpointa1b = 0.0_8
          isectpointa2b = 0.0_8
          du0b = 0.0_8
          du1b = 0.0_8
          du2b = 0.0_8
        ELSE
! Compute the intersection interval for the U points
          CALL COMPUTE_INTERVALS_ISECTLINE(u0, u1, u2, up0, up1, up2, &
&                                    du0, du1, du2, du0du1, du0du2, &
&                                    isect2(1), isect2(2), isectpointb1&
&                                    , isectpointb2, coplanar, intersect&
&                                   )
          IF (intersect .EQ. 0) THEN
            isectpointa1b = 0.0_8
            isectpointa2b = 0.0_8
            isectpointb1b = 0.0_8
            isectpointb2b = 0.0_8
          ELSE
! Sort the projected intersections so that the first index contains the
! smallest value. Also index which case has the smallest max so we
! can compute the actual intersection line
            CALL SORT(isect1(1), isect1(2), smallest1)
            CALL SORT(isect2(1), isect2(2), smallest2)
! If there is no interval where the isects overlap, there there is no intersection
            IF (isect1(2) .LT. isect2(1) .OR. isect2(2) .LT. isect1(1)) &
&           THEN
              isectpointa1b = 0.0_8
              isectpointa2b = 0.0_8
              isectpointb1b = 0.0_8
              isectpointb2b = 0.0_8
            ELSE
              IF (isect1(1) .LT. isect2(1)) THEN
                max1 = isect2(1)
              ELSE
                max1 = isect1(1)
              END IF
              IF (isect1(2) .GT. isect2(2)) THEN
                min1 = isect2(2)
              ELSE
                min1 = isect1(2)
              END IF
              IF (max1 .EQ. min1) THEN
                isectpointa1b = 0.0_8
                isectpointa2b = 0.0_8
                isectpointb1b = 0.0_8
                isectpointb2b = 0.0_8
              ELSE IF (coplanar .NE. 1) THEN
                IF (isect2(1) .LT. isect1(1)) THEN
                  IF (smallest1 .EQ. 0) THEN
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    CALL PUSHCONTROL1B(1)
                  END IF
                  IF (isect2(2) .LT. isect1(2)) THEN
                    IF (smallest2 .EQ. 0) THEN
                      isectpointb2b = 0.0_8
                      isectpointb2b = vecendb
                      isectpointb1b = 0.0_8
                    ELSE
                      isectpointb1b = 0.0_8
                      isectpointb1b = vecendb
                      isectpointb2b = 0.0_8
                    END IF
                    isectpointa1b = 0.0_8
                    isectpointa2b = 0.0_8
                  ELSE
                    IF (smallest1 .EQ. 0) THEN
                      isectpointa2b = 0.0_8
                      isectpointa2b = vecendb
                      isectpointa1b = 0.0_8
                    ELSE
                      isectpointa1b = 0.0_8
                      isectpointa1b = vecendb
                      isectpointa2b = 0.0_8
                    END IF
                    isectpointb1b = 0.0_8
                    isectpointb2b = 0.0_8
                  END IF
                  CALL POPCONTROL1B(branch)
                  IF (branch .EQ. 0) THEN
                    isectpointa1b = isectpointa1b + vecstartb
                  ELSE
                    isectpointa2b = isectpointa2b + vecstartb
                  END IF
                ELSE
                  IF (smallest2 .EQ. 0) THEN
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    CALL PUSHCONTROL1B(1)
                  END IF
                  IF (isect2(2) .GT. isect1(2)) THEN
                    IF (smallest1 .EQ. 0) THEN
                      isectpointa2b = 0.0_8
                      isectpointa2b = vecendb
                      isectpointa1b = 0.0_8
                    ELSE
                      isectpointa1b = 0.0_8
                      isectpointa1b = vecendb
                      isectpointa2b = 0.0_8
                    END IF
                    isectpointb1b = 0.0_8
                    isectpointb2b = 0.0_8
                  ELSE
                    IF (smallest2 .EQ. 0) THEN
                      isectpointb2b = 0.0_8
                      isectpointb2b = vecendb
                      isectpointb1b = 0.0_8
                    ELSE
                      isectpointb1b = 0.0_8
                      isectpointb1b = vecendb
                      isectpointb2b = 0.0_8
                    END IF
                    isectpointa1b = 0.0_8
                    isectpointa2b = 0.0_8
                  END IF
                  CALL POPCONTROL1B(branch)
                  IF (branch .EQ. 0) THEN
                    isectpointb1b = isectpointb1b + vecstartb
                  ELSE
                    isectpointb2b = isectpointb2b + vecstartb
                  END IF
                END IF
                vecendb = 0.0_8
                vecstartb = 0.0_8
              ELSE
                isectpointa1b = 0.0_8
                isectpointa2b = 0.0_8
                isectpointb1b = 0.0_8
                isectpointb2b = 0.0_8
              END IF
            END IF
          END IF
          CALL COMPUTE_INTERVALS_ISECTLINE_B(u0, u0b, u1, u1b, u2, u2b, &
&                                      up0, up1, up2, du0, du0b, du1, &
&                                      du1b, du2, du2b, du0du1, du0du2, &
&                                      isect2(1), isect2(2), &
&                                      isectpointb1, isectpointb1b, &
&                                      isectpointb2, isectpointb2b, &
&                                      coplanar, intersect)
        END IF
        CALL COMPUTE_INTERVALS_ISECTLINE_B(v0, v0b, v1, v1b, v2, v2b, &
&                                    vp0, vp1, vp2, dv0, dv0b, dv1, dv1b&
&                                    , dv2, dv2b, dv0dv1, dv0dv2, isect1&
&                                    (1), isect1(2), isectpointa1, &
&                                    isectpointa1b, isectpointa2, &
&                                    isectpointa2b, coplanar, intersect)
      END IF
      d2b = dv2b + dv1b + dv0b
      n2b = 0.0_8
      CALL DOT_B0(n2, n2b, v2, v2b, dv2, dv2b)
      CALL DOT_B0(n2, n2b, v1, v1b, dv1, dv1b)
      CALL DOT_B0(n2, n2b, v0, v0b, dv0, dv0b)
      d2b = -d2b
      CALL DOT_B0(n2, n2b, u0, u0b, d2, d2b)
      CALL CROSS_PRODUCT_B(e1, e1b, e2, e2b, n2, n2b)
      u2b = u2b + e2b
      u0b = u0b - e2b - e1b
      u1b = u1b + e1b
    END IF
    d1b = du2b + du1b + du0b
    n1b = 0.0_8
    CALL DOT_B0(n1, n1b, u2, u2b, du2, du2b)
    CALL DOT_B0(n1, n1b, u1, u1b, du1, du1b)
    CALL DOT_B0(n1, n1b, u0, u0b, du0, du0b)
    d1b = -d1b
    CALL DOT_B0(n1, n1b, v0, v0b, d1, d1b)
    e1 = v1 - v0
    e2 = v2 - v0
    CALL CROSS_PRODUCT_B(e1, e1b, e2, e2b, n1, n1b)
    v2b = v2b + e2b
    v0b = v0b - e2b - e1b
    v1b = v1b + e1b
  END SUBROUTINE TRITRIINTERSECT_B

!============================================================
  SUBROUTINE TRITRIINTERSECT(v0, v1, v2, u0, u1, u2, intersect, vecstart&
&   , vecend)
    IMPLICIT NONE
! This subroutine computes the line vector of intersection between two triangles
! John Jasa - 2016-08
!
! Adapted from Moller's 1997 paper "A Fast Triangle-Triangle Intersection Test"
!
! INPUTS:
!
! V0: real(3) -> coordinates (x,y,z) of the first node of triangle V
! V0: real(3) -> coordinates (x,y,z) of the second node of triangle V
! V0: real(3) -> coordinates (x,y,z) of the third node of triangle V
!
! U0: real(3) -> coordinates (x,y,z) of the first node of triangle U
! U0: real(3) -> coordinates (x,y,z) of the second node of triangle U
! U0: real(3) -> coordinates (x,y,z) of the third node of triangle U
!
! OUTPUTS:
!
! intersect: integer -> 1 if the triangles intersect, 0 if they do not
! vecStart: real(3) -> coordinates (x,y,z) of the start point of the intersection line
! vecEnd: real(3) -> coordinates (x,y,z) of the end point of the intersection line
! INPUTS
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: v0, v1, v2, u0, u1&
&   , u2
! OUTPUTS
    INTEGER(kind=inttype), INTENT(OUT) :: intersect
    REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: vecstart, vecend
! WORKING
    REAL(kind=realtype), DIMENSION(3) :: e1, e2, n1, n2, dir
    REAL(kind=realtype) :: d1, du0, du1, du2, du0du1, du0du2, epsilon
    REAL(kind=realtype) :: d2, dv0, dv1, dv2, dv0dv1, dv0dv2, maxd, bb, &
&   cc
    REAL(kind=realtype) :: up0, up1, up2, vp0, vp1, vp2
    REAL(kind=realtype) :: isect1(2), isect2(2)
    REAL(kind=realtype), DIMENSION(3) :: isectpointa1, isectpointa2, &
&   isectpointb1, isectpointb2
    INTEGER(kind=inttype) :: index
    INTEGER(kind=inttype) :: coplanar, smallest1, smallest2
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC MIN
    REAL(kind=realtype) :: max1
    REAL(kind=realtype) :: min1
! Initialize intersect and coplanar values so the program does not stop prematurely
    intersect = 2
    coplanar = 0
! Compute plane of triangle (V0, V1, V2)
    e1 = v1 - v0
    e2 = v2 - v0
    CALL CROSS_PRODUCT(e1, e2, n1)
    CALL DOT(n1, v0, d1)
    d1 = -d1
! Get distances from U points to plane defined by V points
    CALL DOT(n1, u0, du0)
    du0 = du0 + d1
    CALL DOT(n1, u1, du1)
    du1 = du1 + d1
    CALL DOT(n1, u2, du2)
    du2 = du2 + d1
! Compute the signed distance product to see which side of the plane each point is on
    du0du1 = du0*du1
    du0du2 = du0*du2
! If all the points of one triangle are on the same side of the other triangle,
! there is no intersection
    IF (du0du1 .GT. 0.0 .AND. du0du2 .GT. 0.0) THEN
      intersect = 0
      RETURN
    ELSE
! Compute plane of triangle (U0, U1, U2)
      e1 = u1 - u0
      e2 = u2 - u0
      CALL CROSS_PRODUCT(e1, e2, n2)
      CALL DOT(n2, u0, d2)
      d2 = -d2
! Get distances from V points to plane defined by U points
      CALL DOT(n2, v0, dv0)
      dv0 = dv0 + d2
      CALL DOT(n2, v1, dv1)
      dv1 = dv1 + d2
      CALL DOT(n2, v2, dv2)
      dv2 = dv2 + d2
! Compute the signed distance product to see which side of the plane each point is on
      dv0dv1 = dv0*dv1
      dv0dv2 = dv0*dv2
! If all the points of one triangle are on the same side of the other triangle,
! there is no intersection
      IF (dv0dv1 .GT. 0.0 .AND. dv0dv2 .GT. 0.0) THEN
        intersect = 0
        RETURN
      ELSE
! Compute the direction of the intersection line
        CALL CROSS_PRODUCT(n1, n2, dir)
        IF (dir(1) .GE. 0.) THEN
          maxd = dir(1)
        ELSE
          maxd = -dir(1)
        END IF
        index = 1
        IF (dir(2) .GE. 0.) THEN
          bb = dir(2)
        ELSE
          bb = -dir(2)
        END IF
        IF (dir(3) .GE. 0.) THEN
          cc = dir(3)
        ELSE
          cc = -dir(3)
        END IF
        IF (bb .GT. maxd) THEN
          maxd = bb
          index = 2
        END IF
        IF (cc .GT. maxd) index = 3
! Simplified projection onto L
        vp0 = v0(index)
        vp1 = v1(index)
        vp2 = v2(index)
        up0 = u0(index)
        up1 = u1(index)
        up2 = u2(index)
! isect1 and isect2 are the projected intersections of triangles 1 and 2,
! which are defined by the V and U points respectively.
! These isect values show where each triangle edge intersects the
! two triangle's intersection line
! Compute the intersection interval for the V points
        CALL COMPUTE_INTERVALS_ISECTLINE(v0, v1, v2, vp0, vp1, vp2, dv0&
&                                  , dv1, dv2, dv0dv1, dv0dv2, isect1(1)&
&                                  , isect1(2), isectpointa1, &
&                                  isectpointa2, coplanar, intersect)
        IF (intersect .EQ. 0) THEN
          RETURN
        ELSE
! Compute the intersection interval for the U points
          CALL COMPUTE_INTERVALS_ISECTLINE(u0, u1, u2, up0, up1, up2, &
&                                    du0, du1, du2, du0du1, du0du2, &
&                                    isect2(1), isect2(2), isectpointb1&
&                                    , isectpointb2, coplanar, intersect&
&                                   )
          IF (intersect .EQ. 0) THEN
            RETURN
          ELSE
! Sort the projected intersections so that the first index contains the
! smallest value. Also index which case has the smallest max so we
! can compute the actual intersection line
            CALL SORT(isect1(1), isect1(2), smallest1)
            CALL SORT(isect2(1), isect2(2), smallest2)
! If there is no interval where the isects overlap, there there is no intersection
            IF (isect1(2) .LT. isect2(1) .OR. isect2(2) .LT. isect1(1)) &
&           THEN
              intersect = 0
! If the intersection is only a point, we do not treat it as an intersection
            ELSE
              IF (isect1(1) .LT. isect2(1)) THEN
                max1 = isect2(1)
              ELSE
                max1 = isect1(1)
              END IF
              IF (isect1(2) .GT. isect2(2)) THEN
                min1 = isect2(2)
              ELSE
                min1 = isect1(2)
              END IF
              IF (max1 .EQ. min1) THEN
                intersect = 0
! Only continue if the triangles are not coplanar.
! Choose the triangle edges that intersect the intersection line in the
! most restrictive interval.
              ELSE IF (coplanar .NE. 1) THEN
                IF (isect2(1) .LT. isect1(1)) THEN
                  IF (smallest1 .EQ. 0) THEN
                    vecstart = isectpointa1
                  ELSE
                    vecstart = isectpointa2
                  END IF
                  IF (isect2(2) .LT. isect1(2)) THEN
                    IF (smallest2 .EQ. 0) THEN
                      vecend = isectpointb2
                    ELSE
                      vecend = isectpointb1
                    END IF
                  ELSE IF (smallest1 .EQ. 0) THEN
                    vecend = isectpointa2
                  ELSE
                    vecend = isectpointa1
                  END IF
                ELSE
                  IF (smallest2 .EQ. 0) THEN
                    vecstart = isectpointb1
                  ELSE
                    vecstart = isectpointb2
                  END IF
                  IF (isect2(2) .GT. isect1(2)) THEN
                    IF (smallest1 .EQ. 0) THEN
                      vecend = isectpointa2
                    ELSE
                      vecend = isectpointa1
                    END IF
                  ELSE IF (smallest2 .EQ. 0) THEN
                    vecend = isectpointb2
                  ELSE
                    vecend = isectpointb1
                  END IF
                END IF
                intersect = 1
              END IF
            END IF
          END IF
        END IF
      END IF
    END IF
  END SUBROUTINE TRITRIINTERSECT

!  Differentiation of compute_intervals_isectline in reverse (adjoint) mode:
!   gradient     of useful results: vert0 vert1 vert2 isectpoint0
!                isectpoint1
!   with respect to varying inputs: d0 d1 d2 vert0 vert1 vert2
  SUBROUTINE COMPUTE_INTERVALS_ISECTLINE_B(vert0, vert0b, vert1, vert1b&
&   , vert2, vert2b, vv0, vv1, vv2, d0, d0b, d1, d1b, d2, d2b, d0d1, &
&   d0d2, isect0, isect1, isectpoint0, isectpoint0b, isectpoint1, &
&   isectpoint1b, coplanar, intersect)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: vv0, vv1, vv2, d0, d1, d2, d0d1, &
&   d0d2
    REAL(kind=realtype) :: d0b, d1b, d2b
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: vert0, vert1, vert2
    REAL(kind=realtype), DIMENSION(3) :: vert0b, vert1b, vert2b
    REAL(kind=realtype) :: isectpoint0(3), isectpoint1(3), isect0, &
&   isect1
    REAL(kind=realtype) :: isectpoint0b(3), isectpoint1b(3)
    INTEGER(kind=inttype) :: coplanar, intersect
! Test if d0 and d1 are on the same side
    IF (d0d1 .GT. 0.0) THEN
      CALL INTERSECT2_B(vert2, vert2b, vert0, vert0b, vert1, vert1b, vv2&
&                 , vv0, vv1, d2, d2b, d0, d0b, d1, d1b, isect0, isect1&
&                 , isectpoint0, isectpoint0b, isectpoint1, isectpoint1b&
&                )
    ELSE IF (d0d2 .GT. 0.0) THEN
      CALL INTERSECT2_B(vert1, vert1b, vert0, vert0b, vert2, vert2b, vv1&
&                 , vv0, vv2, d1, d1b, d0, d0b, d2, d2b, isect0, isect1&
&                 , isectpoint0, isectpoint0b, isectpoint1, isectpoint1b&
&                )
    ELSE IF (d1*d2 .GT. 0.0 .OR. d0 .NE. 0.0) THEN
      CALL INTERSECT2_B(vert0, vert0b, vert1, vert1b, vert2, vert2b, vv0&
&                 , vv1, vv2, d0, d0b, d1, d1b, d2, d2b, isect0, isect1&
&                 , isectpoint0, isectpoint0b, isectpoint1, isectpoint1b&
&                )
    ELSE IF (d1 .NE. 0.0) THEN
      CALL INTERSECT2_B(vert1, vert1b, vert0, vert0b, vert2, vert2b, vv1&
&                 , vv0, vv2, d1, d1b, d0, d0b, d2, d2b, isect0, isect1&
&                 , isectpoint0, isectpoint0b, isectpoint1, isectpoint1b&
&                )
    ELSE IF (d2 .NE. 0.0) THEN
      CALL INTERSECT2_B(vert2, vert2b, vert0, vert0b, vert1, vert1b, vv2&
&                 , vv0, vv1, d2, d2b, d0, d0b, d1, d1b, isect0, isect1&
&                 , isectpoint0, isectpoint0b, isectpoint1, isectpoint1b&
&                )
    ELSE
      d0b = 0.0_8
      d1b = 0.0_8
      d2b = 0.0_8
    END IF
  END SUBROUTINE COMPUTE_INTERVALS_ISECTLINE_B

  SUBROUTINE COMPUTE_INTERVALS_ISECTLINE(vert0, vert1, vert2, vv0, vv1, &
&   vv2, d0, d1, d2, d0d1, d0d2, isect0, isect1, isectpoint0, &
&   isectpoint1, coplanar, intersect)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: vv0, vv1, vv2, d0, d1, d2, d0d1, &
&   d0d2
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: vert0, vert1, vert2
    REAL(kind=realtype), INTENT(OUT) :: isectpoint0(3), isectpoint1(3), &
&   isect0, isect1
    INTEGER(kind=inttype), INTENT(OUT) :: coplanar, intersect
! Test if d0 and d1 are on the same side
    IF (d0d1 .GT. 0.0) THEN
      CALL INTERSECT2(vert2, vert0, vert1, vv2, vv0, vv1, d2, d0, d1, &
&               isect0, isect1, isectpoint0, isectpoint1)
! Test if d0 and d2 are on the same side
    ELSE IF (d0d2 .GT. 0.0) THEN
      CALL INTERSECT2(vert1, vert0, vert2, vv1, vv0, vv2, d1, d0, d2, &
&               isect0, isect1, isectpoint0, isectpoint1)
! Test if d1 and d2 are on the same side or if d0 is not equal to 0
    ELSE IF (d1*d2 .GT. 0.0 .OR. d0 .NE. 0.0) THEN
      CALL INTERSECT2(vert0, vert1, vert2, vv0, vv1, vv2, d0, d1, d2, &
&               isect0, isect1, isectpoint0, isectpoint1)
! Called only if d0 is 0
    ELSE IF (d1 .NE. 0.0) THEN
      CALL INTERSECT2(vert1, vert0, vert2, vv1, vv0, vv2, d1, d0, d2, &
&               isect0, isect1, isectpoint0, isectpoint1)
! Called only if d1 and d0 is 0
    ELSE IF (d2 .NE. 0.0) THEN
      CALL INTERSECT2(vert2, vert0, vert1, vv2, vv0, vv1, d2, d0, d1, &
&               isect0, isect1, isectpoint0, isectpoint1)
    ELSE
! For now, we are not interested in coplanar triangle intersections
!intersect = coplanarTriTri(N1, V0, V1, V2, U0, U1, U2)
      intersect = 0
      coplanar = 1
    END IF
  END SUBROUTINE COMPUTE_INTERVALS_ISECTLINE

!  Differentiation of intersect2 in reverse (adjoint) mode:
!   gradient     of useful results: isectpoint0 isectpoint1 vtx0
!                vtx1 vtx2
!   with respect to varying inputs: d0 d1 d2 vtx0 vtx1 vtx2
  SUBROUTINE INTERSECT2_B(vtx0, vtx0b, vtx1, vtx1b, vtx2, vtx2b, vv0, &
&   vv1, vv2, d0, d0b, d1, d1b, d2, d2b, isect0, isect1, isectpoint0, &
&   isectpoint0b, isectpoint1, isectpoint1b)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: vv0, vv1, vv2, d0, d1, d2
    REAL(kind=realtype) :: d0b, d1b, d2b
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: vtx0, vtx1, vtx2
    REAL(kind=realtype), DIMENSION(3) :: vtx0b, vtx1b, vtx2b
    REAL(kind=realtype) :: isect0, isect1, isectpoint0(3), isectpoint1(3&
&   )
    REAL(kind=realtype) :: isectpoint0b(3), isectpoint1b(3)
    REAL(kind=realtype) :: tmp
    REAL(kind=realtype) :: tmpb
    REAL(kind=realtype), DIMENSION(3) :: diff
    REAL(kind=realtype), DIMENSION(3) :: diffb
    REAL(kind=realtype) :: tempb
    REAL(kind=realtype) :: tempb0
    diff = vtx1 - vtx0
    tmp = d0/(d0-d2)
    CALL PUSHREAL8ARRAY(diff, 3)
    diff = vtx2 - vtx0
    diffb = 0.0_8
    diffb = isectpoint1b
    tmpb = SUM(diff*diffb)
    diffb = tmp*diffb
    vtx0b = vtx0b + isectpoint1b - diffb
    CALL POPREAL8ARRAY(diff, 3)
    vtx2b = vtx2b + diffb
    tempb0 = tmpb/(d0-d2)
    tempb = -(d0*tempb0/(d0-d2))
    d0b = tempb0 + tempb
    d2b = -tempb
    diffb = 0.0_8
    diffb = isectpoint0b
    tmp = d0/(d0-d1)
    tmpb = SUM(diff*diffb)
    diffb = tmp*diffb
    vtx0b = vtx0b + isectpoint0b - diffb
    vtx1b = vtx1b + diffb
    tempb = tmpb/(d0-d1)
    tempb0 = -(d0*tempb/(d0-d1))
    d0b = d0b + tempb + tempb0
    d1b = -tempb0
  END SUBROUTINE INTERSECT2_B

  SUBROUTINE INTERSECT2(vtx0, vtx1, vtx2, vv0, vv1, vv2, d0, d1, d2, &
&   isect0, isect1, isectpoint0, isectpoint1)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: vv0, vv1, vv2, d0, d1, d2
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: vtx0, vtx1, vtx2
    REAL(kind=realtype), INTENT(OUT) :: isect0, isect1, isectpoint0(3), &
&   isectpoint1(3)
    REAL(kind=realtype) :: tmp
    REAL(kind=realtype), DIMENSION(3) :: diff
    tmp = d0/(d0-d1)
    isect0 = vv0 + (vv1-vv0)*tmp
    diff = vtx1 - vtx0
    diff = diff*tmp
    isectpoint0 = diff + vtx0
    tmp = d0/(d0-d2)
    isect1 = vv0 + (vv2-vv0)*tmp
    diff = vtx2 - vtx0
    diff = diff*tmp
    isectpoint1 = diff + vtx0
  END SUBROUTINE INTERSECT2

  FUNCTION COPLANARTRITRI(n, v0, v1, v2, u0, u1, u2) RESULT (intersect)
    IMPLICIT NONE
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: n, v0, v1, v2, u0, &
&   u1, u2
    INTEGER(kind=inttype) :: intersect
    REAL(kind=realtype), DIMENSION(3) :: a
    INTEGER(kind=inttype) :: i0, i1
    INTRINSIC ABS
    IF (n(1) .GE. 0.) THEN
      a(1) = n(1)
    ELSE
      a(1) = -n(1)
    END IF
    IF (n(2) .GE. 0.) THEN
      a(2) = n(2)
    ELSE
      a(2) = -n(2)
    END IF
    IF (n(3) .GE. 0.) THEN
      a(3) = n(3)
    ELSE
      a(3) = -n(3)
    END IF
    IF (a(1) .GT. a(2)) THEN
      IF (a(1) .GT. a(3)) THEN
        i0 = 2
        i1 = 3
      ELSE
        i0 = 1
        i1 = 2
      END IF
    ELSE IF (a(3) .GT. a(2)) THEN
      i0 = 1
      i1 = 2
    ELSE
      i0 = 1
      i1 = 3
    END IF
! Test all edges of triangle 1 against the edges of triangle 2
    intersect = EDGEAGAINSTTRIEDGES(v0, v1, u0, u1, u2, i0, i1)
    IF (intersect .EQ. 1) THEN
      RETURN
    ELSE
      intersect = EDGEAGAINSTTRIEDGES(v1, v2, u0, u1, u2, i0, i1)
      IF (intersect .EQ. 1) THEN
        RETURN
      ELSE
        intersect = EDGEAGAINSTTRIEDGES(v2, v0, u0, u1, u2, i0, i1)
        IF (intersect .EQ. 1) THEN
          RETURN
        ELSE
! Finally, test if tri1 is totally contained in tri2 or vice versa
          intersect = POINTINTRI(v0, u0, u1, u2, i0, i1)
          IF (intersect .EQ. 1) THEN
            RETURN
          ELSE
            intersect = POINTINTRI(u0, v0, v1, v2, i0, i1)
            IF (intersect .EQ. 1) RETURN
          END IF
        END IF
      END IF
    END IF
  END FUNCTION COPLANARTRITRI

  FUNCTION POINTINTRI(v0, u0, u1, u2, i0, i1) RESULT (intersect)
    IMPLICIT NONE
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: v0, u0, u1, u2
    INTEGER(kind=inttype) :: intersect
    REAL(kind=realtype) :: a, b, c, d0, d1, d2
    INTEGER(kind=inttype) :: i0, i1
    intersect = 0
    a = u1(i1) - u0(i1)
    b = -(u1(i0)-u0(i0))
    c = -(a*u0(i0)) - b*u0(i1)
    d0 = a*v0(i0) + b*v0(i1) + c
    a = u2(i1) - u1(i1)
    b = -(u2(i0)-u1(i0))
    c = -(a*u1(i0)) - b*u1(i1)
    d1 = a*v0(i0) + b*v0(i1) + c
    a = u0(i1) - u2(i1)
    b = -(u0(i0)-u2(i0))
    c = -(a*u2(i0)) - b*u2(i1)
    d2 = a*v0(i0) + b*v0(i1) + c
    IF (d0*d1 .GT. 0.) THEN
      IF (d0*d2 .GT. 0.) intersect = 1
      RETURN
    END IF
  END FUNCTION POINTINTRI

  FUNCTION EDGEAGAINSTTRIEDGES(v0, v1, u0, u1, u2, i0, i1) RESULT (&
& intersect)
    IMPLICIT NONE
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: v0, v1, u0, u1, u2
    INTEGER(kind=inttype), INTENT(IN) :: i0, i1
    INTEGER(kind=inttype) :: intersect
    REAL(kind=realtype) :: ax, ay
    ax = v1(i0) - v0(i0)
    ay = v1(i1) - v0(i1)
    intersect = EDGE_EDGE_TEST(v0, u0, u1, ax, ay, i0, i1)
    IF (intersect .EQ. 1) THEN
      RETURN
    ELSE
      intersect = EDGE_EDGE_TEST(v0, u1, u2, ax, ay, i0, i1)
      IF (intersect .EQ. 1) THEN
        RETURN
      ELSE
        intersect = EDGE_EDGE_TEST(v0, u2, u0, ax, ay, i0, i1)
        IF (intersect .EQ. 1) RETURN
      END IF
    END IF
  END FUNCTION EDGEAGAINSTTRIEDGES

  FUNCTION EDGE_EDGE_TEST(v0, u0, u1, ax, ay, i0, i1) RESULT (intersect)
    IMPLICIT NONE
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: v0, u0, u1
    REAL(kind=realtype), INTENT(IN) :: ax, ay
    INTEGER(kind=inttype), INTENT(IN) :: i0, i1
    REAL(kind=realtype) :: bx, by, cx, cy, f, d, e
    INTEGER(kind=inttype) :: intersect
    bx = u0(i0) - u1(i0)
    by = u0(i1) - u1(i1)
    cx = v0(i0) - u0(i0)
    cy = v0(i1) - u0(i1)
    f = ay*bx - ax*by
    d = by*cx - bx*cy
    intersect = 0
    IF ((f .GT. 0 .AND. d .GE. 0 .AND. d .LE. f) .OR. (f .LT. 0 .AND. d &
&       .LE. 0 .AND. d .GE. f)) THEN
      e = ax*cy - ay*cx
      IF (f .GT. 0) THEN
        IF (e .GE. 0 .AND. e .LE. f) intersect = 1
        RETURN
      ELSE
        IF (e .LE. 0 .AND. e .GE. f) intersect = 1
        RETURN
      END IF
    END IF
  END FUNCTION EDGE_EDGE_TEST

!  Differentiation of cross_product in reverse (adjoint) mode:
!   gradient     of useful results: c
!   with respect to varying inputs: a b
  SUBROUTINE CROSS_PRODUCT_B(a, ab, b, bb, c, cb)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: a(3), b(3)
    REAL(kind=realtype) :: ab(3), bb(3)
    REAL(kind=realtype) :: c(3)
    REAL(kind=realtype) :: cb(3)
    ab = 0.0_8
    bb = 0.0_8
    ab(1) = ab(1) + b(2)*cb(3) - b(3)*cb(2)
    bb(2) = bb(2) + a(1)*cb(3) - a(3)*cb(1)
    ab(2) = ab(2) + b(3)*cb(1) - b(1)*cb(3)
    bb(1) = bb(1) + a(3)*cb(2) - a(2)*cb(3)
    cb(3) = 0.0_8
    ab(3) = ab(3) + b(1)*cb(2) - b(2)*cb(1)
    bb(3) = bb(3) + a(2)*cb(1) - a(1)*cb(2)
    cb(2) = 0.0_8
  END SUBROUTINE CROSS_PRODUCT_B

  SUBROUTINE CROSS_PRODUCT(a, b, c)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: a(3), b(3)
    REAL(kind=realtype), INTENT(OUT) :: c(3)
    c(1) = a(2)*b(3) - a(3)*b(2)
    c(2) = a(3)*b(1) - a(1)*b(3)
    c(3) = a(1)*b(2) - a(2)*b(1)
  END SUBROUTINE CROSS_PRODUCT

  SUBROUTINE SORT(a, b, smallest)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(INOUT) :: a, b
    INTEGER(kind=inttype), INTENT(OUT) :: smallest
    REAL(kind=realtype) :: c
    IF (a .GT. b) THEN
      c = a
      a = b
      b = c
      smallest = 1
    ELSE
      smallest = 0
    END IF
  END SUBROUTINE SORT

END MODULE INTERSECTION_B

