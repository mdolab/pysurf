!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) - 22 Aug 2023 15:51
!
MODULE INTERSECTION_D
  USE UTILITIES_D
  USE PRECISION
  IMPLICIT NONE

CONTAINS
!============================================================
  SUBROUTINE FILTERELEMENTS(coor, triaconn, quadsconn, bbox, innertriaid&
&   , innerquadsid)
    IMPLICIT NONE
! INPUTS
    REAL(kind=realtype), DIMENSION(:, :), INTENT(IN) :: coor
    INTEGER(kind=inttype), DIMENSION(:, :), INTENT(IN) :: triaconn, &
&   quadsconn
    REAL(kind=realtype), DIMENSION(3, 2), INTENT(IN) :: bbox
! OUTPUTS
    INTEGER(kind=inttype), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: &
&   innertriaid, innerquadsid
! WORKING
    INTEGER(kind=inttype), DIMENSION(:), ALLOCATABLE :: extinnertriaid, &
&   extinnerquadsid
    LOGICAL, DIMENSION(:), ALLOCATABLE :: nodelocation
    INTEGER(kind=inttype), DIMENSION(:, :), ALLOCATABLE :: nodeontop
    INTEGER(kind=inttype) :: nnodes, ntria, nquads
    INTEGER(kind=inttype) :: elemid, nodeid
    INTEGER(kind=inttype) :: numinnertria, numinnerquads, i
    INTEGER(kind=inttype), DIMENSION(3) :: ontop
    REAL(kind=realtype) :: nodex, nodey, nodez
    LOGICAL :: nodeisinside
    INTRINSIC SIZE
! EXECUTION
! Get problem size
    nnodes = SIZE(coor, 2)
    ntria = SIZE(triaconn, 2)
    nquads = SIZE(quadsconn, 2)
! Allocate array that states whether a node is inside or outside of the BBox
! nodeLocation(nodeID) = .false. -> node is outside the BBox
! nodeLocation(nodeID) = .true.  -> node is inside the BBox
    ALLOCATE(nodelocation(nnodes))
    ALLOCATE(nodeontop(nnodes, 3))
! Initialize arrays
    nodelocation = .false.
    nodeontop = 0
! Now check each node
nodeloop:DO nodeid=1,nnodes
! Get current node coordinates
      nodex = coor(1, nodeid)
      nodey = coor(2, nodeid)
      nodez = coor(3, nodeid)
! Check each dimension
      IF (nodex .GE. bbox(1, 1) .AND. nodex .LE. bbox(1, 2)) THEN
        IF (nodey .GE. bbox(2, 1) .AND. nodey .LE. bbox(2, 2)) THEN
          IF (nodez .GE. bbox(3, 1) .AND. nodez .LE. bbox(3, 2)) &
&           nodelocation(nodeid) = .true.
        END IF
      END IF
! Check to see if all of the nodes are on the same side of the bounding box
! Check X dimension
      IF (nodex .GE. bbox(1, 2)) nodeontop(nodeid, 1) = 1
! Check Y dimension
      IF (nodey .GE. bbox(2, 2)) nodeontop(nodeid, 2) = 1
! Check Z dimension
      IF (nodez .GE. bbox(3, 2)) nodeontop(nodeid, 3) = 1
    END DO nodeloop
! Allocate extended arrays to store indices of the interior elements. In the worst
! case, all elements would be inside, so we would need to store nTria and nQuads
! indices in total.
    ALLOCATE(extinnertriaid(ntria))
    ALLOCATE(extinnerquadsid(nquads))
! Now we check all elements.
! If one node is inside the bounding box, then we flag the element as "inside"
! Initialize interior element counters
    numinnertria = 0
    numinnerquads = 0
! First we check triangles
trialoop:DO elemid=1,ntria
      ontop(:) = 0
! Loop over all the nodes of the element
      DO nodeid=1,3
! Get location flag of the current node
        nodeisinside = nodelocation(triaconn(nodeid, elemid))
! Flag the element if any node is inside
        IF (nodeisinside) THEN
          GOTO 100
        ELSE
! We do not need to check other nodes, so
! we jump out of the do loop
! Get a running sum of which nodes are on one side of the bounding box
          ontop = ontop + nodeontop(triaconn(nodeid, elemid), :)
        END IF
      END DO
! Check to see if all nodes are on the same side of the bounding box
! If any node is not on the same side as all the others, flag the element
! to check for intersections
 100  IF (nodeisinside .NEQV. .true.) THEN
        DO i=1,3
          IF (ontop(i) .NE. 0 .AND. ontop(i) .NE. 3) THEN
            nodeisinside = .true.
            GOTO 110
          END IF
        END DO
      END IF
 110  IF (nodeisinside) THEN
! Increment number of inside elements
        numinnertria = numinnertria + 1
! Store element index in the extended array
        extinnertriaid(numinnertria) = elemid
      END IF
    END DO trialoop
! Now we check quads
quadsloop:DO elemid=1,nquads
      ontop = 0
! Loop over all the nodes of the element
      DO nodeid=1,4
! Get location flag of the current node
        nodeisinside = nodelocation(quadsconn(nodeid, elemid))
! Flag the element if any node is inside
        IF (nodeisinside) THEN
          GOTO 120
        ELSE
! We do not need to check other nodes, so
! we jump out of the do loop
! Get a running sum of which nodes are on one side of the bounding box
          ontop = ontop + nodeontop(quadsconn(nodeid, elemid), :)
        END IF
      END DO
! Check to see if all nodes are on the same side of the bounding box
! If any node is not on the same side as all the others, flag the element
! to check for intersections
 120  IF (nodeisinside .NEQV. .true.) THEN
        DO i=1,3
          IF (ontop(i) .NE. 0 .AND. ontop(i) .NE. 4) THEN
            nodeisinside = .true.
            GOTO 130
          END IF
        END DO
      END IF
 130  IF (nodeisinside) THEN
! Increment number of inside elements
        numinnerquads = numinnerquads + 1
! Store element index in the extended array
        extinnerquadsid(numinnerquads) = elemid
      END IF
    END DO quadsloop
! Now that we know exactly how many elements are inside, we can
! allocate outputs arrays with the proper size
    ALLOCATE(innertriaid(numinnertria))
    ALLOCATE(innerquadsid(numinnerquads))
! Transfer values from the extended arrays to the output arrays
    innertriaid(:) = extinnertriaid(1:numinnertria)
    innerquadsid(:) = extinnerquadsid(1:numinnerquads)
! We can finally deallocate the extended arrays
    DEALLOCATE(extinnertriaid)
    DEALLOCATE(extinnerquadsid)
  END SUBROUTINE FILTERELEMENTS

!============================================================
  SUBROUTINE CONDENSEBARFES(disttol, coor, barsconn, newcoor)
    IMPLICIT NONE
! INPUTS
    REAL(kind=realtype), INTENT(IN) :: disttol
    REAL(kind=realtype), DIMENSION(:, :), INTENT(IN) :: coor
! OUTPUTS
    REAL(kind=realtype), DIMENSION(:, :), ALLOCATABLE, INTENT(OUT) :: &
&   newcoor
! INPUTS/OUTPUTS
    INTEGER(kind=inttype), DIMENSION(:, :), INTENT(INOUT) :: barsconn
! WORKING
    INTEGER(kind=inttype) :: nnodes, nelem, nuniquenodes, ncopies
    INTEGER(kind=inttype) :: currnodeid, prevnodeid, link, elemid
    REAL(kind=realtype), DIMENSION(3) :: currcoor, prevcoor
    REAL(kind=realtype) :: dist
    INTRINSIC SIZE
    INTEGER(kind=inttype), DIMENSION(SIZE(coor, 2)) :: linkold2new
! EXECUTION
! Get problem size
    nnodes = SIZE(coor, 2)
    nelem = SIZE(barsconn, 2)
! Initialize number of unique nodes found so far.
! The first node is a unique one =P!
    nuniquenodes = 1
! As the first node is unique, its old-to-new link should point to itself
    linkold2new(1) = 1
! Loop over the nodes to find the unique ones
    DO currnodeid=2,nnodes
! Get coordinates of current node
      currcoor = coor(:, currnodeid)
! Now loop over the previous nodes to find if it is repeated
      DO prevnodeid=1,currnodeid-1
! Get coordinates of the previous node
        prevcoor = coor(:, prevnodeid)
! Compute distance between nodes
        CALL NORM(currcoor - prevcoor, dist)
! Check if the distance is below the merging tolerance
        IF (dist .LE. disttol) THEN
! Update link array.
! The array linkOld2New will contain newCoor indices that correspond to each
! coor index.
! So the current node should use the same link as the previous node, as they will
! point to the same index of the new coordinate array.
          linkold2new(currnodeid) = linkold2new(prevnodeid)
          GOTO 100
        END IF
      END DO
! Check if we did not find any copy. In this case, we need to initialize a new
! unique node
 100  IF (prevnodeid .EQ. currnodeid) THEN
! Increase the number of unique nodes found so far
        nuniquenodes = nuniquenodes + 1
! Create new link
        linkold2new(currnodeid) = nuniquenodes
      END IF
    END DO
! Now that we know the number of unique nodes, we can allocate memory for the new
! coordinate array.
    ALLOCATE(newcoor(3, nuniquenodes))
    newcoor = 0.0
! Initialize number of nodes copied so far
    ncopies = 0
! We loop once again over the nodes so we can copy the unique values
    DO currnodeid=1,nnodes
! Get coordinates of current node
      currcoor = coor(:, currnodeid)
! Get index of the current node in the new coordinate array
      link = linkold2new(currnodeid)
! Check if the new link is already used
      IF (link .GT. ncopies) THEN
! Increment number of copies done so far
        ncopies = ncopies + 1
! Copy coordinates
        newcoor(:, ncopies) = currcoor
      END IF
    END DO
! Now the last step is updating the bars connectivity.
! Loop over the elements
    DO elemid=1,nelem
! Update connectivities
      barsconn(1, elemid) = linkold2new(barsconn(1, elemid))
      barsconn(2, elemid) = linkold2new(barsconn(2, elemid))
    END DO
  END SUBROUTINE CONDENSEBARFES

!============================================================
  SUBROUTINE GETALLTRIAS(triaconn, quadsconn, innertriaid, innerquadsid&
&   , alltriaconn)
    IMPLICIT NONE
! INPUTS
    INTEGER(kind=inttype), DIMENSION(:, :), INTENT(IN) :: triaconn, &
&   quadsconn
    INTEGER(kind=inttype), DIMENSION(:), INTENT(IN) :: innertriaid, &
&   innerquadsid
! OUTPUTS
    INTEGER(kind=inttype), DIMENSION(:, :), ALLOCATABLE, INTENT(OUT) :: &
&   alltriaconn
! WORKING
    INTEGER(kind=inttype) :: ninnertria, ninnerquads, ii, node1, node2, &
&   node3, node4
    INTRINSIC SIZE
! EXECUTION
! Get number of interior elements
    ninnertria = SIZE(innertriaid)
    ninnerquads = SIZE(innerquadsid)
! Allocate connectivity arrays for triangles split from quads
    ALLOCATE(alltriaconn(3, ninnertria+ninnerquads*2))
! Copy connectivities of the interior triangles
    DO ii=1,ninnertria
      alltriaconn(:, ii) = triaconn(:, innertriaid(ii))
    END DO
! Loop over every interior element
    DO ii=1,ninnerquads
! Get nodes of the current quad
      node1 = quadsconn(1, innerquadsid(ii))
      node2 = quadsconn(2, innerquadsid(ii))
      node3 = quadsconn(3, innerquadsid(ii))
      node4 = quadsconn(4, innerquadsid(ii))
! Create two triangle elements
      alltriaconn(:, ninnertria+2*ii-1) = (/node1, node2, node3/)
      alltriaconn(:, ninnertria+2*ii) = (/node3, node4, node1/)
    END DO
  END SUBROUTINE GETALLTRIAS

!  Differentiation of tritriintersect in forward (tangent) mode:
!   variations   of useful results: vecend vecstart
!   with respect to varying inputs: v0 v1 v2 vecend vecstart u0
!                u1 u2
!   RW status of diff variables: v0:in v1:in v2:in vecend:in-out
!                vecstart:in-out u0:in u1:in u2:in
!============================================================
  SUBROUTINE TRITRIINTERSECT_D(v0, v0d, v1, v1d, v2, v2d, u0, u0d, u1, &
&   u1d, u2, u2d, intersect, vecstart, vecstartd, vecend, vecendd)
    IMPLICIT NONE
! This subroutine computes the line vector of intersection between two triangles
! John Jasa - 2016-08
!
! Adapted from Moller's 1997 paper "A Fast Triangle-Triangle Intersection Test"
!
! INPUTS:
!
! V0: real(3) -> coordinates (x,y,z) of the first node of triangle V
! V0: real(3) -> coordinates (x,y,z) of the second node of triangle V
! V0: real(3) -> coordinates (x,y,z) of the third node of triangle V
!
! U0: real(3) -> coordinates (x,y,z) of the first node of triangle U
! U0: real(3) -> coordinates (x,y,z) of the second node of triangle U
! U0: real(3) -> coordinates (x,y,z) of the third node of triangle U
!
! OUTPUTS:
!
! intersect: integer -> 1 if the triangles intersect, 0 if they do not
! vecStart: real(3) -> coordinates (x,y,z) of the start point of the intersection line
! vecEnd: real(3) -> coordinates (x,y,z) of the end point of the intersection line
! INPUTS
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: v0, v1, v2, u0, u1&
&   , u2
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: v0d, v1d, v2d, u0d&
&   , u1d, u2d
! OUTPUTS
    INTEGER(kind=inttype), INTENT(OUT) :: intersect
    REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: vecstart, vecend
    REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: vecstartd, vecendd
! WORKING
    REAL(kind=realtype), DIMENSION(3) :: e1, e2, n1, n2, dir
    REAL(kind=realtype), DIMENSION(3) :: e1d, e2d, n1d, n2d
    REAL(kind=realtype) :: d1, du0, du1, du2, du0du1, du0du2, epsilon
    REAL(kind=realtype) :: d1d, du0d, du1d, du2d
    REAL(kind=realtype) :: d2, dv0, dv1, dv2, dv0dv1, dv0dv2, maxd, bb, &
&   cc
    REAL(kind=realtype) :: d2d, dv0d, dv1d, dv2d
    REAL(kind=realtype) :: up0, up1, up2, vp0, vp1, vp2
    REAL(kind=realtype) :: isect1(2), isect2(2)
    REAL(kind=realtype), DIMENSION(3) :: isectpointa1, isectpointa2, &
&   isectpointb1, isectpointb2
    REAL(kind=realtype), DIMENSION(3) :: isectpointa1d, isectpointa2d, &
&   isectpointb1d, isectpointb2d
    INTEGER(kind=inttype) :: index
    INTEGER(kind=inttype) :: coplanar, smallest1, smallest2
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC MIN
    REAL(kind=realtype) :: max1
    REAL(kind=realtype) :: min1
! Initialize intersect and coplanar values so the program does not stop prematurely
    intersect = 2
    coplanar = 0
! Compute plane of triangle (V0, V1, V2)
    e1d = v1d - v0d
    e1 = v1 - v0
    e2d = v2d - v0d
    e2 = v2 - v0
    n1d = 0.0_8
    CALL CROSS_PRODUCT_D(e1, e1d, e2, e2d, n1, n1d)
    CALL DOT_D0(n1, n1d, v0, v0d, d1, d1d)
    d1d = -d1d
    d1 = -d1
! Get distances from U points to plane defined by V points
    CALL DOT_D0(n1, n1d, u0, u0d, du0, du0d)
    du0d = du0d + d1d
    du0 = du0 + d1
    CALL DOT_D0(n1, n1d, u1, u1d, du1, du1d)
    du1d = du1d + d1d
    du1 = du1 + d1
    CALL DOT_D0(n1, n1d, u2, u2d, du2, du2d)
    du2d = du2d + d1d
    du2 = du2 + d1
! Compute the signed distance product to see which side of the plane each point is on
    du0du1 = du0*du1
    du0du2 = du0*du2
! If all the points of one triangle are on the same side of the other triangle,
! there is no intersection
    IF (du0du1 .GT. 0.0 .AND. du0du2 .GT. 0.0) THEN
      intersect = 0
      RETURN
    ELSE
! Compute plane of triangle (U0, U1, U2)
      e1d = u1d - u0d
      e1 = u1 - u0
      e2d = u2d - u0d
      e2 = u2 - u0
      n2d = 0.0_8
      CALL CROSS_PRODUCT_D(e1, e1d, e2, e2d, n2, n2d)
      CALL DOT_D0(n2, n2d, u0, u0d, d2, d2d)
      d2d = -d2d
      d2 = -d2
! Get distances from V points to plane defined by U points
      CALL DOT_D0(n2, n2d, v0, v0d, dv0, dv0d)
      dv0d = dv0d + d2d
      dv0 = dv0 + d2
      CALL DOT_D0(n2, n2d, v1, v1d, dv1, dv1d)
      dv1d = dv1d + d2d
      dv1 = dv1 + d2
      CALL DOT_D0(n2, n2d, v2, v2d, dv2, dv2d)
      dv2d = dv2d + d2d
      dv2 = dv2 + d2
! Compute the signed distance product to see which side of the plane each point is on
      dv0dv1 = dv0*dv1
      dv0dv2 = dv0*dv2
! If all the points of one triangle are on the same side of the other triangle,
! there is no intersection
      IF (dv0dv1 .GT. 0.0 .AND. dv0dv2 .GT. 0.0) THEN
        intersect = 0
        RETURN
      ELSE
! Compute the direction of the intersection line
        CALL CROSS_PRODUCT(n1, n2, dir)
        IF (dir(1) .GE. 0.) THEN
          maxd = dir(1)
        ELSE
          maxd = -dir(1)
        END IF
        index = 1
        IF (dir(2) .GE. 0.) THEN
          bb = dir(2)
        ELSE
          bb = -dir(2)
        END IF
        IF (dir(3) .GE. 0.) THEN
          cc = dir(3)
        ELSE
          cc = -dir(3)
        END IF
        IF (bb .GT. maxd) THEN
          maxd = bb
          index = 2
        END IF
        IF (cc .GT. maxd) index = 3
! Simplified projection onto L
        vp0 = v0(index)
        vp1 = v1(index)
        vp2 = v2(index)
        up0 = u0(index)
        up1 = u1(index)
        up2 = u2(index)
! isect1 and isect2 are the projected intersections of triangles 1 and 2,
! which are defined by the V and U points respectively.
! These isect values show where each triangle edge intersects the
! two triangle's intersection line
! Compute the intersection interval for the V points
        isectpointa2d = 0.0_8
        isectpointa1d = 0.0_8
        CALL COMPUTE_INTERVALS_ISECTLINE_D(v0, v0d, v1, v1d, v2, v2d, &
&                                    vp0, vp1, vp2, dv0, dv0d, dv1, dv1d&
&                                    , dv2, dv2d, dv0dv1, dv0dv2, isect1&
&                                    (1), isect1(2), isectpointa1, &
&                                    isectpointa1d, isectpointa2, &
&                                    isectpointa2d, coplanar, intersect)
        IF (intersect .EQ. 0) THEN
          RETURN
        ELSE
! Compute the intersection interval for the U points
          isectpointb2d = 0.0_8
          isectpointb1d = 0.0_8
          CALL COMPUTE_INTERVALS_ISECTLINE_D(u0, u0d, u1, u1d, u2, u2d, &
&                                      up0, up1, up2, du0, du0d, du1, &
&                                      du1d, du2, du2d, du0du1, du0du2, &
&                                      isect2(1), isect2(2), &
&                                      isectpointb1, isectpointb1d, &
&                                      isectpointb2, isectpointb2d, &
&                                      coplanar, intersect)
          IF (intersect .EQ. 0) THEN
            RETURN
          ELSE
! Sort the projected intersections so that the first index contains the
! smallest value. Also index which case has the smallest max so we
! can compute the actual intersection line
            CALL SORT(isect1(1), isect1(2), smallest1)
            CALL SORT(isect2(1), isect2(2), smallest2)
! If there is no interval where the isects overlap, there there is no intersection
            IF (isect1(2) .LT. isect2(1) .OR. isect2(2) .LT. isect1(1)) &
&           THEN
              intersect = 0
! If the intersection is only a point, we do not treat it as an intersection
            ELSE
              IF (isect1(1) .LT. isect2(1)) THEN
                max1 = isect2(1)
              ELSE
                max1 = isect1(1)
              END IF
              IF (isect1(2) .GT. isect2(2)) THEN
                min1 = isect2(2)
              ELSE
                min1 = isect1(2)
              END IF
              IF (max1 .EQ. min1) THEN
                intersect = 0
! Only continue if the triangles are not coplanar.
! Choose the triangle edges that intersect the intersection line in the
! most restrictive interval.
              ELSE IF (coplanar .NE. 1) THEN
                IF (isect2(1) .LT. isect1(1)) THEN
                  IF (smallest1 .EQ. 0) THEN
                    vecstartd = isectpointa1d
                    vecstart = isectpointa1
                  ELSE
                    vecstartd = isectpointa2d
                    vecstart = isectpointa2
                  END IF
                  IF (isect2(2) .LT. isect1(2)) THEN
                    IF (smallest2 .EQ. 0) THEN
                      vecendd = isectpointb2d
                      vecend = isectpointb2
                    ELSE
                      vecendd = isectpointb1d
                      vecend = isectpointb1
                    END IF
                  ELSE IF (smallest1 .EQ. 0) THEN
                    vecendd = isectpointa2d
                    vecend = isectpointa2
                  ELSE
                    vecendd = isectpointa1d
                    vecend = isectpointa1
                  END IF
                ELSE
                  IF (smallest2 .EQ. 0) THEN
                    vecstartd = isectpointb1d
                    vecstart = isectpointb1
                  ELSE
                    vecstartd = isectpointb2d
                    vecstart = isectpointb2
                  END IF
                  IF (isect2(2) .GT. isect1(2)) THEN
                    IF (smallest1 .EQ. 0) THEN
                      vecendd = isectpointa2d
                      vecend = isectpointa2
                    ELSE
                      vecendd = isectpointa1d
                      vecend = isectpointa1
                    END IF
                  ELSE IF (smallest2 .EQ. 0) THEN
                    vecendd = isectpointb2d
                    vecend = isectpointb2
                  ELSE
                    vecendd = isectpointb1d
                    vecend = isectpointb1
                  END IF
                END IF
                intersect = 1
              END IF
            END IF
          END IF
        END IF
      END IF
    END IF
  END SUBROUTINE TRITRIINTERSECT_D

!============================================================
  SUBROUTINE TRITRIINTERSECT(v0, v1, v2, u0, u1, u2, intersect, vecstart&
&   , vecend)
    IMPLICIT NONE
! This subroutine computes the line vector of intersection between two triangles
! John Jasa - 2016-08
!
! Adapted from Moller's 1997 paper "A Fast Triangle-Triangle Intersection Test"
!
! INPUTS:
!
! V0: real(3) -> coordinates (x,y,z) of the first node of triangle V
! V0: real(3) -> coordinates (x,y,z) of the second node of triangle V
! V0: real(3) -> coordinates (x,y,z) of the third node of triangle V
!
! U0: real(3) -> coordinates (x,y,z) of the first node of triangle U
! U0: real(3) -> coordinates (x,y,z) of the second node of triangle U
! U0: real(3) -> coordinates (x,y,z) of the third node of triangle U
!
! OUTPUTS:
!
! intersect: integer -> 1 if the triangles intersect, 0 if they do not
! vecStart: real(3) -> coordinates (x,y,z) of the start point of the intersection line
! vecEnd: real(3) -> coordinates (x,y,z) of the end point of the intersection line
! INPUTS
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: v0, v1, v2, u0, u1&
&   , u2
! OUTPUTS
    INTEGER(kind=inttype), INTENT(OUT) :: intersect
    REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: vecstart, vecend
! WORKING
    REAL(kind=realtype), DIMENSION(3) :: e1, e2, n1, n2, dir
    REAL(kind=realtype) :: d1, du0, du1, du2, du0du1, du0du2, epsilon
    REAL(kind=realtype) :: d2, dv0, dv1, dv2, dv0dv1, dv0dv2, maxd, bb, &
&   cc
    REAL(kind=realtype) :: up0, up1, up2, vp0, vp1, vp2
    REAL(kind=realtype) :: isect1(2), isect2(2)
    REAL(kind=realtype), DIMENSION(3) :: isectpointa1, isectpointa2, &
&   isectpointb1, isectpointb2
    INTEGER(kind=inttype) :: index
    INTEGER(kind=inttype) :: coplanar, smallest1, smallest2
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC MIN
    REAL(kind=realtype) :: max1
    REAL(kind=realtype) :: min1
! Initialize intersect and coplanar values so the program does not stop prematurely
    intersect = 2
    coplanar = 0
! Compute plane of triangle (V0, V1, V2)
    e1 = v1 - v0
    e2 = v2 - v0
    CALL CROSS_PRODUCT(e1, e2, n1)
    CALL DOT(n1, v0, d1)
    d1 = -d1
! Get distances from U points to plane defined by V points
    CALL DOT(n1, u0, du0)
    du0 = du0 + d1
    CALL DOT(n1, u1, du1)
    du1 = du1 + d1
    CALL DOT(n1, u2, du2)
    du2 = du2 + d1
! Compute the signed distance product to see which side of the plane each point is on
    du0du1 = du0*du1
    du0du2 = du0*du2
! If all the points of one triangle are on the same side of the other triangle,
! there is no intersection
    IF (du0du1 .GT. 0.0 .AND. du0du2 .GT. 0.0) THEN
      intersect = 0
      RETURN
    ELSE
! Compute plane of triangle (U0, U1, U2)
      e1 = u1 - u0
      e2 = u2 - u0
      CALL CROSS_PRODUCT(e1, e2, n2)
      CALL DOT(n2, u0, d2)
      d2 = -d2
! Get distances from V points to plane defined by U points
      CALL DOT(n2, v0, dv0)
      dv0 = dv0 + d2
      CALL DOT(n2, v1, dv1)
      dv1 = dv1 + d2
      CALL DOT(n2, v2, dv2)
      dv2 = dv2 + d2
! Compute the signed distance product to see which side of the plane each point is on
      dv0dv1 = dv0*dv1
      dv0dv2 = dv0*dv2
! If all the points of one triangle are on the same side of the other triangle,
! there is no intersection
      IF (dv0dv1 .GT. 0.0 .AND. dv0dv2 .GT. 0.0) THEN
        intersect = 0
        RETURN
      ELSE
! Compute the direction of the intersection line
        CALL CROSS_PRODUCT(n1, n2, dir)
        IF (dir(1) .GE. 0.) THEN
          maxd = dir(1)
        ELSE
          maxd = -dir(1)
        END IF
        index = 1
        IF (dir(2) .GE. 0.) THEN
          bb = dir(2)
        ELSE
          bb = -dir(2)
        END IF
        IF (dir(3) .GE. 0.) THEN
          cc = dir(3)
        ELSE
          cc = -dir(3)
        END IF
        IF (bb .GT. maxd) THEN
          maxd = bb
          index = 2
        END IF
        IF (cc .GT. maxd) index = 3
! Simplified projection onto L
        vp0 = v0(index)
        vp1 = v1(index)
        vp2 = v2(index)
        up0 = u0(index)
        up1 = u1(index)
        up2 = u2(index)
! isect1 and isect2 are the projected intersections of triangles 1 and 2,
! which are defined by the V and U points respectively.
! These isect values show where each triangle edge intersects the
! two triangle's intersection line
! Compute the intersection interval for the V points
        CALL COMPUTE_INTERVALS_ISECTLINE(v0, v1, v2, vp0, vp1, vp2, dv0&
&                                  , dv1, dv2, dv0dv1, dv0dv2, isect1(1)&
&                                  , isect1(2), isectpointa1, &
&                                  isectpointa2, coplanar, intersect)
        IF (intersect .EQ. 0) THEN
          RETURN
        ELSE
! Compute the intersection interval for the U points
          CALL COMPUTE_INTERVALS_ISECTLINE(u0, u1, u2, up0, up1, up2, &
&                                    du0, du1, du2, du0du1, du0du2, &
&                                    isect2(1), isect2(2), isectpointb1&
&                                    , isectpointb2, coplanar, intersect&
&                                   )
          IF (intersect .EQ. 0) THEN
            RETURN
          ELSE
! Sort the projected intersections so that the first index contains the
! smallest value. Also index which case has the smallest max so we
! can compute the actual intersection line
            CALL SORT(isect1(1), isect1(2), smallest1)
            CALL SORT(isect2(1), isect2(2), smallest2)
! If there is no interval where the isects overlap, there there is no intersection
            IF (isect1(2) .LT. isect2(1) .OR. isect2(2) .LT. isect1(1)) &
&           THEN
              intersect = 0
! If the intersection is only a point, we do not treat it as an intersection
            ELSE
              IF (isect1(1) .LT. isect2(1)) THEN
                max1 = isect2(1)
              ELSE
                max1 = isect1(1)
              END IF
              IF (isect1(2) .GT. isect2(2)) THEN
                min1 = isect2(2)
              ELSE
                min1 = isect1(2)
              END IF
              IF (max1 .EQ. min1) THEN
                intersect = 0
! Only continue if the triangles are not coplanar.
! Choose the triangle edges that intersect the intersection line in the
! most restrictive interval.
              ELSE IF (coplanar .NE. 1) THEN
                IF (isect2(1) .LT. isect1(1)) THEN
                  IF (smallest1 .EQ. 0) THEN
                    vecstart = isectpointa1
                  ELSE
                    vecstart = isectpointa2
                  END IF
                  IF (isect2(2) .LT. isect1(2)) THEN
                    IF (smallest2 .EQ. 0) THEN
                      vecend = isectpointb2
                    ELSE
                      vecend = isectpointb1
                    END IF
                  ELSE IF (smallest1 .EQ. 0) THEN
                    vecend = isectpointa2
                  ELSE
                    vecend = isectpointa1
                  END IF
                ELSE
                  IF (smallest2 .EQ. 0) THEN
                    vecstart = isectpointb1
                  ELSE
                    vecstart = isectpointb2
                  END IF
                  IF (isect2(2) .GT. isect1(2)) THEN
                    IF (smallest1 .EQ. 0) THEN
                      vecend = isectpointa2
                    ELSE
                      vecend = isectpointa1
                    END IF
                  ELSE IF (smallest2 .EQ. 0) THEN
                    vecend = isectpointb2
                  ELSE
                    vecend = isectpointb1
                  END IF
                END IF
                intersect = 1
              END IF
            END IF
          END IF
        END IF
      END IF
    END IF
  END SUBROUTINE TRITRIINTERSECT

!  Differentiation of compute_intervals_isectline in forward (tangent) mode:
!   variations   of useful results: isectpoint0 isectpoint1
!   with respect to varying inputs: d0 d1 d2 vert0 vert1 vert2
  SUBROUTINE COMPUTE_INTERVALS_ISECTLINE_D(vert0, vert0d, vert1, vert1d&
&   , vert2, vert2d, vv0, vv1, vv2, d0, d0d, d1, d1d, d2, d2d, d0d1, &
&   d0d2, isect0, isect1, isectpoint0, isectpoint0d, isectpoint1, &
&   isectpoint1d, coplanar, intersect)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: vv0, vv1, vv2, d0, d1, d2, d0d1, &
&   d0d2
    REAL(kind=realtype), INTENT(IN) :: d0d, d1d, d2d
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: vert0, vert1, vert2
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: vert0d, vert1d, &
&   vert2d
    REAL(kind=realtype), INTENT(OUT) :: isectpoint0(3), isectpoint1(3), &
&   isect0, isect1
    REAL(kind=realtype), INTENT(OUT) :: isectpoint0d(3), isectpoint1d(3)
    INTEGER(kind=inttype), INTENT(OUT) :: coplanar, intersect
! Test if d0 and d1 are on the same side
    IF (d0d1 .GT. 0.0) THEN
      CALL INTERSECT2_D(vert2, vert2d, vert0, vert0d, vert1, vert1d, vv2&
&                 , vv0, vv1, d2, d2d, d0, d0d, d1, d1d, isect0, isect1&
&                 , isectpoint0, isectpoint0d, isectpoint1, isectpoint1d&
&                )
! Test if d0 and d2 are on the same side
    ELSE IF (d0d2 .GT. 0.0) THEN
      CALL INTERSECT2_D(vert1, vert1d, vert0, vert0d, vert2, vert2d, vv1&
&                 , vv0, vv2, d1, d1d, d0, d0d, d2, d2d, isect0, isect1&
&                 , isectpoint0, isectpoint0d, isectpoint1, isectpoint1d&
&                )
! Test if d1 and d2 are on the same side or if d0 is not equal to 0
    ELSE IF (d1*d2 .GT. 0.0 .OR. d0 .NE. 0.0) THEN
      CALL INTERSECT2_D(vert0, vert0d, vert1, vert1d, vert2, vert2d, vv0&
&                 , vv1, vv2, d0, d0d, d1, d1d, d2, d2d, isect0, isect1&
&                 , isectpoint0, isectpoint0d, isectpoint1, isectpoint1d&
&                )
! Called only if d0 is 0
    ELSE IF (d1 .NE. 0.0) THEN
      CALL INTERSECT2_D(vert1, vert1d, vert0, vert0d, vert2, vert2d, vv1&
&                 , vv0, vv2, d1, d1d, d0, d0d, d2, d2d, isect0, isect1&
&                 , isectpoint0, isectpoint0d, isectpoint1, isectpoint1d&
&                )
! Called only if d1 and d0 is 0
    ELSE IF (d2 .NE. 0.0) THEN
      CALL INTERSECT2_D(vert2, vert2d, vert0, vert0d, vert1, vert1d, vv2&
&                 , vv0, vv1, d2, d2d, d0, d0d, d1, d1d, isect0, isect1&
&                 , isectpoint0, isectpoint0d, isectpoint1, isectpoint1d&
&                )
    ELSE
! For now, we are not interested in coplanar triangle intersections
!intersect = coplanarTriTri(N1, V0, V1, V2, U0, U1, U2)
      intersect = 0
      coplanar = 1
      isectpoint0d = 0.0_8
      isectpoint1d = 0.0_8
    END IF
  END SUBROUTINE COMPUTE_INTERVALS_ISECTLINE_D

  SUBROUTINE COMPUTE_INTERVALS_ISECTLINE(vert0, vert1, vert2, vv0, vv1, &
&   vv2, d0, d1, d2, d0d1, d0d2, isect0, isect1, isectpoint0, &
&   isectpoint1, coplanar, intersect)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: vv0, vv1, vv2, d0, d1, d2, d0d1, &
&   d0d2
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: vert0, vert1, vert2
    REAL(kind=realtype), INTENT(OUT) :: isectpoint0(3), isectpoint1(3), &
&   isect0, isect1
    INTEGER(kind=inttype), INTENT(OUT) :: coplanar, intersect
! Test if d0 and d1 are on the same side
    IF (d0d1 .GT. 0.0) THEN
      CALL INTERSECT2(vert2, vert0, vert1, vv2, vv0, vv1, d2, d0, d1, &
&               isect0, isect1, isectpoint0, isectpoint1)
! Test if d0 and d2 are on the same side
    ELSE IF (d0d2 .GT. 0.0) THEN
      CALL INTERSECT2(vert1, vert0, vert2, vv1, vv0, vv2, d1, d0, d2, &
&               isect0, isect1, isectpoint0, isectpoint1)
! Test if d1 and d2 are on the same side or if d0 is not equal to 0
    ELSE IF (d1*d2 .GT. 0.0 .OR. d0 .NE. 0.0) THEN
      CALL INTERSECT2(vert0, vert1, vert2, vv0, vv1, vv2, d0, d1, d2, &
&               isect0, isect1, isectpoint0, isectpoint1)
! Called only if d0 is 0
    ELSE IF (d1 .NE. 0.0) THEN
      CALL INTERSECT2(vert1, vert0, vert2, vv1, vv0, vv2, d1, d0, d2, &
&               isect0, isect1, isectpoint0, isectpoint1)
! Called only if d1 and d0 is 0
    ELSE IF (d2 .NE. 0.0) THEN
      CALL INTERSECT2(vert2, vert0, vert1, vv2, vv0, vv1, d2, d0, d1, &
&               isect0, isect1, isectpoint0, isectpoint1)
    ELSE
! For now, we are not interested in coplanar triangle intersections
!intersect = coplanarTriTri(N1, V0, V1, V2, U0, U1, U2)
      intersect = 0
      coplanar = 1
    END IF
  END SUBROUTINE COMPUTE_INTERVALS_ISECTLINE

!  Differentiation of intersect2 in forward (tangent) mode:
!   variations   of useful results: isectpoint0 isectpoint1
!   with respect to varying inputs: d0 d1 d2 vtx0 vtx1 vtx2
  SUBROUTINE INTERSECT2_D(vtx0, vtx0d, vtx1, vtx1d, vtx2, vtx2d, vv0, &
&   vv1, vv2, d0, d0d, d1, d1d, d2, d2d, isect0, isect1, isectpoint0, &
&   isectpoint0d, isectpoint1, isectpoint1d)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: vv0, vv1, vv2, d0, d1, d2
    REAL(kind=realtype), INTENT(IN) :: d0d, d1d, d2d
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: vtx0, vtx1, vtx2
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: vtx0d, vtx1d, vtx2d
    REAL(kind=realtype), INTENT(OUT) :: isect0, isect1, isectpoint0(3), &
&   isectpoint1(3)
    REAL(kind=realtype), INTENT(OUT) :: isectpoint0d(3), isectpoint1d(3)
    REAL(kind=realtype) :: tmp
    REAL(kind=realtype) :: tmpd
    REAL(kind=realtype), DIMENSION(3) :: diff
    REAL(kind=realtype), DIMENSION(3) :: diffd
    REAL(kind=realtype) :: temp
    temp = d0/(d0-d1)
    tmpd = (d0d-temp*(d0d-d1d))/(d0-d1)
    tmp = temp
    isect0 = vv0 + (vv1-vv0)*tmp
    diffd = vtx1d - vtx0d
    diff = vtx1 - vtx0
    diffd = tmp*diffd + diff*tmpd
    diff = diff*tmp
    isectpoint0d = diffd + vtx0d
    isectpoint0 = diff + vtx0
    temp = d0/(d0-d2)
    tmpd = (d0d-temp*(d0d-d2d))/(d0-d2)
    tmp = temp
    isect1 = vv0 + (vv2-vv0)*tmp
    diffd = vtx2d - vtx0d
    diff = vtx2 - vtx0
    diffd = tmp*diffd + diff*tmpd
    diff = diff*tmp
    isectpoint1d = diffd + vtx0d
    isectpoint1 = diff + vtx0
  END SUBROUTINE INTERSECT2_D

  SUBROUTINE INTERSECT2(vtx0, vtx1, vtx2, vv0, vv1, vv2, d0, d1, d2, &
&   isect0, isect1, isectpoint0, isectpoint1)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: vv0, vv1, vv2, d0, d1, d2
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: vtx0, vtx1, vtx2
    REAL(kind=realtype), INTENT(OUT) :: isect0, isect1, isectpoint0(3), &
&   isectpoint1(3)
    REAL(kind=realtype) :: tmp
    REAL(kind=realtype), DIMENSION(3) :: diff
    tmp = d0/(d0-d1)
    isect0 = vv0 + (vv1-vv0)*tmp
    diff = vtx1 - vtx0
    diff = diff*tmp
    isectpoint0 = diff + vtx0
    tmp = d0/(d0-d2)
    isect1 = vv0 + (vv2-vv0)*tmp
    diff = vtx2 - vtx0
    diff = diff*tmp
    isectpoint1 = diff + vtx0
  END SUBROUTINE INTERSECT2

  FUNCTION COPLANARTRITRI(n, v0, v1, v2, u0, u1, u2) RESULT (intersect)
    IMPLICIT NONE
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: n, v0, v1, v2, u0, &
&   u1, u2
    INTEGER(kind=inttype) :: intersect
    REAL(kind=realtype), DIMENSION(3) :: a
    INTEGER(kind=inttype) :: i0, i1
    INTRINSIC ABS
    IF (n(1) .GE. 0.) THEN
      a(1) = n(1)
    ELSE
      a(1) = -n(1)
    END IF
    IF (n(2) .GE. 0.) THEN
      a(2) = n(2)
    ELSE
      a(2) = -n(2)
    END IF
    IF (n(3) .GE. 0.) THEN
      a(3) = n(3)
    ELSE
      a(3) = -n(3)
    END IF
    IF (a(1) .GT. a(2)) THEN
      IF (a(1) .GT. a(3)) THEN
        i0 = 2
        i1 = 3
      ELSE
        i0 = 1
        i1 = 2
      END IF
    ELSE IF (a(3) .GT. a(2)) THEN
      i0 = 1
      i1 = 2
    ELSE
      i0 = 1
      i1 = 3
    END IF
! Test all edges of triangle 1 against the edges of triangle 2
    intersect = EDGEAGAINSTTRIEDGES(v0, v1, u0, u1, u2, i0, i1)
    IF (intersect .EQ. 1) THEN
      RETURN
    ELSE
      intersect = EDGEAGAINSTTRIEDGES(v1, v2, u0, u1, u2, i0, i1)
      IF (intersect .EQ. 1) THEN
        RETURN
      ELSE
        intersect = EDGEAGAINSTTRIEDGES(v2, v0, u0, u1, u2, i0, i1)
        IF (intersect .EQ. 1) THEN
          RETURN
        ELSE
! Finally, test if tri1 is totally contained in tri2 or vice versa
          intersect = POINTINTRI(v0, u0, u1, u2, i0, i1)
          IF (intersect .EQ. 1) THEN
            RETURN
          ELSE
            intersect = POINTINTRI(u0, v0, v1, v2, i0, i1)
            IF (intersect .EQ. 1) RETURN
          END IF
        END IF
      END IF
    END IF
  END FUNCTION COPLANARTRITRI

  FUNCTION POINTINTRI(v0, u0, u1, u2, i0, i1) RESULT (intersect)
    IMPLICIT NONE
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: v0, u0, u1, u2
    INTEGER(kind=inttype) :: intersect
    REAL(kind=realtype) :: a, b, c, d0, d1, d2
    INTEGER(kind=inttype) :: i0, i1
    intersect = 0
    a = u1(i1) - u0(i1)
    b = -(u1(i0)-u0(i0))
    c = -(a*u0(i0)) - b*u0(i1)
    d0 = a*v0(i0) + b*v0(i1) + c
    a = u2(i1) - u1(i1)
    b = -(u2(i0)-u1(i0))
    c = -(a*u1(i0)) - b*u1(i1)
    d1 = a*v0(i0) + b*v0(i1) + c
    a = u0(i1) - u2(i1)
    b = -(u0(i0)-u2(i0))
    c = -(a*u2(i0)) - b*u2(i1)
    d2 = a*v0(i0) + b*v0(i1) + c
    IF (d0*d1 .GT. 0.) THEN
      IF (d0*d2 .GT. 0.) intersect = 1
      RETURN
    END IF
  END FUNCTION POINTINTRI

  FUNCTION EDGEAGAINSTTRIEDGES(v0, v1, u0, u1, u2, i0, i1) RESULT (&
& intersect)
    IMPLICIT NONE
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: v0, v1, u0, u1, u2
    INTEGER(kind=inttype), INTENT(IN) :: i0, i1
    INTEGER(kind=inttype) :: intersect
    REAL(kind=realtype) :: ax, ay
    ax = v1(i0) - v0(i0)
    ay = v1(i1) - v0(i1)
    intersect = EDGE_EDGE_TEST(v0, u0, u1, ax, ay, i0, i1)
    IF (intersect .EQ. 1) THEN
      RETURN
    ELSE
      intersect = EDGE_EDGE_TEST(v0, u1, u2, ax, ay, i0, i1)
      IF (intersect .EQ. 1) THEN
        RETURN
      ELSE
        intersect = EDGE_EDGE_TEST(v0, u2, u0, ax, ay, i0, i1)
        IF (intersect .EQ. 1) RETURN
      END IF
    END IF
  END FUNCTION EDGEAGAINSTTRIEDGES

  FUNCTION EDGE_EDGE_TEST(v0, u0, u1, ax, ay, i0, i1) RESULT (intersect)
    IMPLICIT NONE
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: v0, u0, u1
    REAL(kind=realtype), INTENT(IN) :: ax, ay
    INTEGER(kind=inttype), INTENT(IN) :: i0, i1
    REAL(kind=realtype) :: bx, by, cx, cy, f, d, e
    INTEGER(kind=inttype) :: intersect
    bx = u0(i0) - u1(i0)
    by = u0(i1) - u1(i1)
    cx = v0(i0) - u0(i0)
    cy = v0(i1) - u0(i1)
    f = ay*bx - ax*by
    d = by*cx - bx*cy
    intersect = 0
    IF ((f .GT. 0 .AND. d .GE. 0 .AND. d .LE. f) .OR. (f .LT. 0 .AND. d &
&       .LE. 0 .AND. d .GE. f)) THEN
      e = ax*cy - ay*cx
      IF (f .GT. 0) THEN
        IF (e .GE. 0 .AND. e .LE. f) intersect = 1
        RETURN
      ELSE
        IF (e .LE. 0 .AND. e .GE. f) intersect = 1
        RETURN
      END IF
    END IF
  END FUNCTION EDGE_EDGE_TEST

!  Differentiation of cross_product in forward (tangent) mode:
!   variations   of useful results: c
!   with respect to varying inputs: a b
  SUBROUTINE CROSS_PRODUCT_D(a, ad, b, bd, c, cd)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: a(3), b(3)
    REAL(kind=realtype), INTENT(IN) :: ad(3), bd(3)
    REAL(kind=realtype), INTENT(OUT) :: c(3)
    REAL(kind=realtype), INTENT(OUT) :: cd(3)
    cd = 0.0_8
    cd(1) = b(3)*ad(2) + a(2)*bd(3) - b(2)*ad(3) - a(3)*bd(2)
    c(1) = a(2)*b(3) - a(3)*b(2)
    cd(2) = b(1)*ad(3) + a(3)*bd(1) - b(3)*ad(1) - a(1)*bd(3)
    c(2) = a(3)*b(1) - a(1)*b(3)
    cd(3) = b(2)*ad(1) + a(1)*bd(2) - b(1)*ad(2) - a(2)*bd(1)
    c(3) = a(1)*b(2) - a(2)*b(1)
  END SUBROUTINE CROSS_PRODUCT_D

  SUBROUTINE CROSS_PRODUCT(a, b, c)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: a(3), b(3)
    REAL(kind=realtype), INTENT(OUT) :: c(3)
    c(1) = a(2)*b(3) - a(3)*b(2)
    c(2) = a(3)*b(1) - a(1)*b(3)
    c(3) = a(1)*b(2) - a(2)*b(1)
  END SUBROUTINE CROSS_PRODUCT

  SUBROUTINE SORT(a, b, smallest)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(INOUT) :: a, b
    INTEGER(kind=inttype), INTENT(OUT) :: smallest
    REAL(kind=realtype) :: c
    IF (a .GT. b) THEN
      c = a
      a = b
      b = c
      smallest = 1
    ELSE
      smallest = 0
    END IF
  END SUBROUTINE SORT

END MODULE INTERSECTION_D

