!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) - 22 Aug 2023 15:51
!
!
!     ******************************************************************
!     *                                                                *
!     * File:          adtProjections.F90                              *
!     * Author:        Edwin van der Weide                             *
!     * Starting date: 10-27-2016                                      *
!     * Last modified: 10-27-2016                                      *
!     *                                                                *
!     ******************************************************************
!
MODULE ADTPROJECTIONS_D
!
!     ******************************************************************
!     *                                                                *
!     * Module, which contains small subroutines which perform         *
!     * projection tasks. They are grouped here so they could be       *
!     * easily differentiated.                                         *
!     *                                                                *
!     ******************************************************************
!
  USE PRECISION
  USE CONSTANTS
  IMPLICIT NONE

CONTAINS
!  Differentiation of triaprojection in forward (tangent) mode:
!   variations   of useful results: u v xf
!   with respect to varying inputs: x x1 x2 x3
!   RW status of diff variables: u:out v:out x:in xf:out x1:in
!                x2:in x3:in
!===============================================================
  SUBROUTINE TRIAPROJECTION_D(x1, x1d, x2, x2d, x3, x3d, x, xd, xf, xfd&
&   , u, ud, v, vd, val)
    IMPLICIT NONE
! DECLARATIONS
! Input variables
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x1, x2, x3
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x1d, x2d, x3d
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: xd
! Output variables
    REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: xf
    REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: xfd
    REAL(kind=realtype), INTENT(OUT) :: u, v, val
    REAL(kind=realtype), INTENT(OUT) :: ud, vd
! Working variables
    REAL(kind=realtype), DIMENSION(3) :: a, b, vf, vt
    REAL(kind=realtype), DIMENSION(3) :: ad, bd, vfd, vtd
    REAL(kind=realtype), DIMENSION(3) :: an, bn, norm
    REAL(kind=realtype), DIMENSION(3) :: and, bnd, normd
    REAL(kind=realtype) :: invlen, vn, dx, dy, dz, uv
    REAL(kind=realtype) :: invlend, vnd, uvd
    INTRINSIC SQRT
    INTRINSIC MAX
    INTRINSIC ABS
    INTRINSIC SIGN
    INTRINSIC MIN
    REAL(kind=realtype) :: y1
    REAL(kind=realtype) :: y1d
    REAL(kind=realtype) :: y2
    REAL(kind=realtype) :: y2d
    REAL(kind=realtype) :: y3
    REAL(kind=realtype) :: y3d
    REAL(kind=realtype) :: y4
    REAL(kind=realtype) :: y4d
    REAL(kind=realtype) :: y5
    REAL(kind=realtype) :: y5d
    REAL(kind=realtype) :: max1
    REAL(kind=realtype) :: max1d
    REAL(kind=realtype) :: max2
    REAL(kind=realtype) :: max2d
    REAL(kind=realtype) :: max3
    REAL(kind=realtype) :: max3d
    REAL(kind=realtype) :: arg1
    REAL(kind=realtype) :: arg1d
    REAL(kind=realtype) :: temp
! EXECUTION
! Determine the tangent vectors in u- and v-direction.
! Store these in a and b respectively.
    ad = x2d - x1d
    a = x2 - x1
    bd = x3d - x1d
    b = x3 - x1
! Determine the normal vector of the face by taking the
! cross product of a and b. Afterwards this vector will
! be scaled to a unit vector.
    normd = 0.0_8
    normd(1) = b(3)*ad(2) + a(2)*bd(3) - b(2)*ad(3) - a(3)*bd(2)
    norm(1) = a(2)*b(3) - a(3)*b(2)
    normd(2) = b(1)*ad(3) + a(3)*bd(1) - b(3)*ad(1) - a(1)*bd(3)
    norm(2) = a(3)*b(1) - a(1)*b(3)
    normd(3) = b(2)*ad(1) + a(1)*bd(2) - b(1)*ad(2) - a(2)*bd(1)
    norm(3) = a(1)*b(2) - a(2)*b(1)
    arg1d = 2*norm(1)*normd(1) + 2*norm(2)*normd(2) + 2*norm(3)*normd(3)
    arg1 = norm(1)*norm(1) + norm(2)*norm(2) + norm(3)*norm(3)
    temp = SQRT(arg1)
    IF (arg1 .EQ. 0.0) THEN
      y1d = 0.0_8
    ELSE
      y1d = arg1d/(2.0*temp)
    END IF
    y1 = temp
    IF (eps .LT. y1) THEN
      max1d = y1d
      max1 = y1
    ELSE
      max1 = eps
      max1d = 0.0_8
    END IF
    invlend = -(one*max1d/max1**2)
    invlen = one/max1
    normd(1) = invlen*normd(1) + norm(1)*invlend
    norm(1) = norm(1)*invlen
    normd(2) = invlen*normd(2) + norm(2)*invlend
    norm(2) = norm(2)*invlen
    normd(3) = invlen*normd(3) + norm(3)*invlend
    norm(3) = norm(3)*invlen
! Determine the vector vf from xf to given coordinate.
    vfd = 0.0_8
    vfd(1) = xd(1) - x1d(1)
    vf(1) = x(1) - x1(1)
    vfd(2) = xd(2) - x1d(2)
    vf(2) = x(2) - x1(2)
    vfd(3) = xd(3) - x1d(3)
    vf(3) = x(3) - x1(3)
! Determine the projection of the vector vf onto
! the face.
    vnd = norm(1)*vfd(1) + vf(1)*normd(1) + norm(2)*vfd(2) + vf(2)*normd&
&     (2) + norm(3)*vfd(3) + vf(3)*normd(3)
    vn = vf(1)*norm(1) + vf(2)*norm(2) + vf(3)*norm(3)
    vtd = 0.0_8
    vtd(1) = vfd(1) - norm(1)*vnd - vn*normd(1)
    vt(1) = vf(1) - vn*norm(1)
    vtd(2) = vfd(2) - norm(2)*vnd - vn*normd(2)
    vt(2) = vf(2) - vn*norm(2)
    vtd(3) = vfd(3) - norm(3)*vnd - vn*normd(3)
    vt(3) = vf(3) - vn*norm(3)
! The vector vt points from the current point on the
! face to the new point. However this new point lies on
! the plane determined by the vectors a and b, but not
! necessarily on the face itself. The new point on the
! face is obtained by projecting the point in the a-b
! plane onto the face. this can be done by determining
! the coefficients du and dv, such that vt = du*a + dv*b.
! To solve du and dv the vectors normal to a and b
! inside the plane ab are needed.
    and = 0.0_8
    and(1) = norm(3)*ad(2) + a(2)*normd(3) - norm(2)*ad(3) - a(3)*normd(&
&     2)
    an(1) = a(2)*norm(3) - a(3)*norm(2)
    and(2) = norm(1)*ad(3) + a(3)*normd(1) - norm(3)*ad(1) - a(1)*normd(&
&     3)
    an(2) = a(3)*norm(1) - a(1)*norm(3)
    and(3) = norm(2)*ad(1) + a(1)*normd(2) - norm(1)*ad(2) - a(2)*normd(&
&     1)
    an(3) = a(1)*norm(2) - a(2)*norm(1)
    bnd = 0.0_8
    bnd(1) = norm(3)*bd(2) + b(2)*normd(3) - norm(2)*bd(3) - b(3)*normd(&
&     2)
    bn(1) = b(2)*norm(3) - b(3)*norm(2)
    bnd(2) = norm(1)*bd(3) + b(3)*normd(1) - norm(3)*bd(1) - b(1)*normd(&
&     3)
    bn(2) = b(3)*norm(1) - b(1)*norm(3)
    bnd(3) = norm(2)*bd(1) + b(1)*normd(2) - norm(1)*bd(2) - b(2)*normd(&
&     1)
    bn(3) = b(1)*norm(2) - b(2)*norm(1)
! Solve parametric coordinates u and v.
! The clipping of vn should not be
! active, as this would mean that the vectors a and b
! are parallel. This corresponds to a tria degenerated
! to a line, which should not occur in the surface mesh.
    vnd = bn(1)*ad(1) + a(1)*bnd(1) + bn(2)*ad(2) + a(2)*bnd(2) + bn(3)*&
&     ad(3) + a(3)*bnd(3)
    vn = a(1)*bn(1) + a(2)*bn(2) + a(3)*bn(3)
    IF (vn .GE. 0.) THEN
      y2d = vnd
      y2 = vn
    ELSE
      y2d = -vnd
      y2 = -vn
    END IF
    IF (eps .LT. y2) THEN
      max2d = y2d
      max2 = y2
    ELSE
      max2 = eps
      max2d = 0.0_8
    END IF
    vnd = SIGN(1.d0, max2*vn)*max2d
    vn = SIGN(max2, vn)
    temp = (vt(1)*bn(1)+vt(2)*bn(2)+vt(3)*bn(3))/vn
    ud = (bn(1)*vtd(1)+vt(1)*bnd(1)+bn(2)*vtd(2)+vt(2)*bnd(2)+bn(3)*vtd(&
&     3)+vt(3)*bnd(3)-temp*vnd)/vn
    u = temp
    vnd = an(1)*bd(1) + b(1)*and(1) + an(2)*bd(2) + b(2)*and(2) + an(3)*&
&     bd(3) + b(3)*and(3)
    vn = b(1)*an(1) + b(2)*an(2) + b(3)*an(3)
    IF (vn .GE. 0.) THEN
      y3d = vnd
      y3 = vn
    ELSE
      y3d = -vnd
      y3 = -vn
    END IF
    IF (eps .LT. y3) THEN
      max3d = y3d
      max3 = y3
    ELSE
      max3 = eps
      max3d = 0.0_8
    END IF
    vnd = SIGN(1.d0, max3*vn)*max3d
    vn = SIGN(max3, vn)
    temp = (vt(1)*an(1)+vt(2)*an(2)+vt(3)*an(3))/vn
    vd = (an(1)*vtd(1)+vt(1)*and(1)+an(2)*vtd(2)+vt(2)*and(2)+an(3)*vtd(&
&     3)+vt(3)*and(3)-temp*vnd)/vn
    v = temp
! Triangles should be bounded by the line u + v = 1
    uvd = ud + vd
    uv = u + v
    IF (uv .GT. one) THEN
      ud = (ud-u*uvd/uv)/uv
      u = u/uv
      vd = (vd-v*uvd/uv)/uv
      v = v/uv
    END IF
    IF (zero .LT. u) THEN
      y4d = ud
      y4 = u
    ELSE
      y4 = zero
      y4d = 0.0_8
    END IF
    IF (one .GT. y4) THEN
      ud = y4d
      u = y4
    ELSE
      u = one
      ud = 0.0_8
    END IF
    IF (zero .LT. v) THEN
      y5d = vd
      y5 = v
    ELSE
      y5 = zero
      y5d = 0.0_8
    END IF
    IF (one .GT. y5) THEN
      vd = y5d
      v = y5
    ELSE
      v = one
      vd = 0.0_8
    END IF
! Determine the new coordinates of the point xf.
    xfd = x1d + a*ud + u*ad + b*vd + v*bd
    xf = x1 + u*a + v*b
! Compute the distance squared between the given
! coordinate and the point xf.
    dx = x(1) - xf(1)
    dy = x(2) - xf(2)
    dz = x(3) - xf(3)
    val = dx*dx + dy*dy + dz*dz
  END SUBROUTINE TRIAPROJECTION_D

!===============================================================
  SUBROUTINE TRIAPROJECTION(x1, x2, x3, x, xf, u, v, val)
    IMPLICIT NONE
! DECLARATIONS
! Input variables
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x1, x2, x3
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x
! Output variables
    REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: xf
    REAL(kind=realtype), INTENT(OUT) :: u, v, val
! Working variables
    REAL(kind=realtype), DIMENSION(3) :: a, b, vf, vt
    REAL(kind=realtype), DIMENSION(3) :: an, bn, norm
    REAL(kind=realtype) :: invlen, vn, dx, dy, dz, uv
    INTRINSIC SQRT
    INTRINSIC MAX
    INTRINSIC ABS
    INTRINSIC SIGN
    INTRINSIC MIN
    REAL(kind=realtype) :: y1
    REAL(kind=realtype) :: y2
    REAL(kind=realtype) :: y3
    REAL(kind=realtype) :: y4
    REAL(kind=realtype) :: y5
    REAL(kind=realtype) :: max1
    REAL(kind=realtype) :: max2
    REAL(kind=realtype) :: max3
    REAL(kind=realtype) :: arg1
! EXECUTION
! Determine the tangent vectors in u- and v-direction.
! Store these in a and b respectively.
    a = x2 - x1
    b = x3 - x1
! Determine the normal vector of the face by taking the
! cross product of a and b. Afterwards this vector will
! be scaled to a unit vector.
    norm(1) = a(2)*b(3) - a(3)*b(2)
    norm(2) = a(3)*b(1) - a(1)*b(3)
    norm(3) = a(1)*b(2) - a(2)*b(1)
    arg1 = norm(1)*norm(1) + norm(2)*norm(2) + norm(3)*norm(3)
    y1 = SQRT(arg1)
    IF (eps .LT. y1) THEN
      max1 = y1
    ELSE
      max1 = eps
    END IF
    invlen = one/max1
    norm(1) = norm(1)*invlen
    norm(2) = norm(2)*invlen
    norm(3) = norm(3)*invlen
! Determine the vector vf from xf to given coordinate.
    vf(1) = x(1) - x1(1)
    vf(2) = x(2) - x1(2)
    vf(3) = x(3) - x1(3)
! Determine the projection of the vector vf onto
! the face.
    vn = vf(1)*norm(1) + vf(2)*norm(2) + vf(3)*norm(3)
    vt(1) = vf(1) - vn*norm(1)
    vt(2) = vf(2) - vn*norm(2)
    vt(3) = vf(3) - vn*norm(3)
! The vector vt points from the current point on the
! face to the new point. However this new point lies on
! the plane determined by the vectors a and b, but not
! necessarily on the face itself. The new point on the
! face is obtained by projecting the point in the a-b
! plane onto the face. this can be done by determining
! the coefficients du and dv, such that vt = du*a + dv*b.
! To solve du and dv the vectors normal to a and b
! inside the plane ab are needed.
    an(1) = a(2)*norm(3) - a(3)*norm(2)
    an(2) = a(3)*norm(1) - a(1)*norm(3)
    an(3) = a(1)*norm(2) - a(2)*norm(1)
    bn(1) = b(2)*norm(3) - b(3)*norm(2)
    bn(2) = b(3)*norm(1) - b(1)*norm(3)
    bn(3) = b(1)*norm(2) - b(2)*norm(1)
! Solve parametric coordinates u and v.
! The clipping of vn should not be
! active, as this would mean that the vectors a and b
! are parallel. This corresponds to a tria degenerated
! to a line, which should not occur in the surface mesh.
    vn = a(1)*bn(1) + a(2)*bn(2) + a(3)*bn(3)
    IF (vn .GE. 0.) THEN
      y2 = vn
    ELSE
      y2 = -vn
    END IF
    IF (eps .LT. y2) THEN
      max2 = y2
    ELSE
      max2 = eps
    END IF
    vn = SIGN(max2, vn)
    u = (vt(1)*bn(1)+vt(2)*bn(2)+vt(3)*bn(3))/vn
    vn = b(1)*an(1) + b(2)*an(2) + b(3)*an(3)
    IF (vn .GE. 0.) THEN
      y3 = vn
    ELSE
      y3 = -vn
    END IF
    IF (eps .LT. y3) THEN
      max3 = y3
    ELSE
      max3 = eps
    END IF
    vn = SIGN(max3, vn)
    v = (vt(1)*an(1)+vt(2)*an(2)+vt(3)*an(3))/vn
! Triangles should be bounded by the line u + v = 1
    uv = u + v
    IF (uv .GT. one) THEN
      u = u/uv
      v = v/uv
    END IF
    IF (zero .LT. u) THEN
      y4 = u
    ELSE
      y4 = zero
    END IF
    IF (one .GT. y4) THEN
      u = y4
    ELSE
      u = one
    END IF
    IF (zero .LT. v) THEN
      y5 = v
    ELSE
      y5 = zero
    END IF
    IF (one .GT. y5) THEN
      v = y5
    ELSE
      v = one
    END IF
! Determine the new coordinates of the point xf.
    xf = x1 + u*a + v*b
! Compute the distance squared between the given
! coordinate and the point xf.
    dx = x(1) - xf(1)
    dy = x(2) - xf(2)
    dz = x(3) - xf(3)
    val = dx*dx + dy*dy + dz*dz
  END SUBROUTINE TRIAPROJECTION

!***************************************************************
!***************************************************************
  SUBROUTINE QUADPROJECTION(x1, x2, x3, x4, x, xf, u, v, val)
    IMPLICIT NONE
! DECLARATIONS
! Input variables
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x1, x2, x3, x4
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x
! Output variables
    REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: xf
    REAL(kind=realtype), INTENT(OUT) :: u, v, val
! Working variables
    REAL(kind=realtype), DIMENSION(2) :: residual
    REAL(kind=realtype), DIMENSION(2, 2) :: invjac
    REAL(kind=realtype) :: u_old, v_old, du, dv
    REAL(kind=realtype) :: dx, dy, dz, update
    INTEGER(kind=inttype) :: ll
! Local parameters used in the Newton algorithm.
    INTEGER(kind=inttype), PARAMETER :: itermax=15
    REAL(kind=realtype), PARAMETER :: thresconv=1.e-12_realType
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC SQRT
    REAL(kind=realtype) :: y1
    REAL(kind=realtype) :: y2
    REAL(kind=realtype) :: result1
! EXECUTION
! Initialize u and v to 0.5 and determine the
! corresponding coordinates on the face, which is the
! centroid.
    u = half
    v = half
! Newton loop to determine the point on the surface,
! which minimizes the distance to the given coordinate.
newtonquads:DO ll=1,itermax
! Store previous parametric coordinates
      u_old = u
      v_old = v
      CALL QUADPROJRESIDUAL(x1, x2, x3, x4, x, u, v, residual, invjac)
! Compute the updates (remember to flip signs)
      CALL DOTPROD(invjac(1, :), residual, du)
      CALL DOTPROD(invjac(2, :), residual, dv)
      du = -du
      dv = -dv
! Determine the new parameter values uu and vv. These
! are limited to 0 <= (uu,vv) <= 1.
      u = u + du
      IF (zero .LT. u) THEN
        y1 = u
      ELSE
        y1 = zero
      END IF
      IF (one .GT. y1) THEN
        u = y1
      ELSE
        u = one
      END IF
      v = v + dv
      IF (zero .LT. v) THEN
        y2 = v
      ELSE
        y2 = zero
      END IF
      IF (one .GT. y2) THEN
        v = y2
      ELSE
        v = one
      END IF
! Update error metric (after the cropping)
      du = u - u_old
      dv = v - v_old
      update = du*du + dv*dv
! Exit the loop if the update of the parametric
! weights is below the threshold
      result1 = SQRT(update)
      IF (result1 .LE. thresconv) GOTO 100
    END DO newtonquads
! Call projection one more time for the updated value of u and v
 100 CALL QUADPROJOUTPUT(x1, x2, x3, x4, u, v, xf)
! Compute the distance squared between the given
! coordinate and the point xf.
    dx = x(1) - xf(1)
    dy = x(2) - xf(2)
    dz = x(3) - xf(3)
    val = dx*dx + dy*dy + dz*dz
  END SUBROUTINE QUADPROJECTION

!  Differentiation of quadprojresidual in forward (tangent) mode:
!   variations   of useful results: residual
!   with respect to varying inputs: u v x x1 x2 x3 x4
!   RW status of diff variables: u:in v:in x:in residual:out x1:in
!                x2:in x3:in x4:in
  SUBROUTINE QUADPROJRESIDUAL_D(x1, x1d, x2, x2d, x3, x3d, x4, x4d, x, &
&   xd, u, ud, v, vd, residual, residuald, invjac)
    IMPLICIT NONE
! DECLARATIONS
! Input variables
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x1, x2, x3, x4
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x1d, x2d, x3d, x4d
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: xd
    REAL(kind=realtype), INTENT(IN) :: u, v
    REAL(kind=realtype), INTENT(IN) :: ud, vd
! Output variables
    REAL(kind=realtype), DIMENSION(2), INTENT(OUT) :: residual
    REAL(kind=realtype), DIMENSION(2), INTENT(OUT) :: residuald
    REAL(kind=realtype), DIMENSION(2, 2), INTENT(OUT) :: invjac
! Working variables
    REAL(kind=realtype), DIMENSION(3) :: x10, x21, x41, x3142, dummyvec
    REAL(kind=realtype), DIMENSION(3) :: x10d, x21d, x41d, x3142d, &
&   dummyvecd
    REAL(kind=realtype), DIMENSION(9) :: a
    REAL(kind=realtype), DIMENSION(9) :: ad
    REAL(kind=realtype), DIMENSION(2, 9) :: graduv
    REAL(kind=realtype), DIMENSION(2, 9) :: graduvd
    REAL(kind=realtype), DIMENSION(2) :: graddist2
    REAL(kind=realtype), DIMENSION(2) :: graddist2d
    REAL(kind=realtype), DIMENSION(2, 2) :: jac
    REAL(kind=realtype) :: dotresult
    REAL(kind=realtype) :: dotresultd
! EXECUTION
! Determine auxiliary vectors
    x10d = x1d - xd
    x10 = x1 - x
    x21d = x2d - x1d
    x21 = x2 - x1
    x41d = x4d - x1d
    x41 = x4 - x1
    x3142d = x3d - x1d - x21d - x41d
    x3142 = x3 - x1 - x21 - x41
! Determine vector of coefficients (A)
    dummyvecd = x10d
    dummyvec = x10
    CALL DOTPROD_D(x10, x10d, dummyvec, dummyvecd, dotresult, dotresultd&
&           )
    ad = 0.0_8
    ad(1) = dotresultd
    a(1) = dotresult
    CALL DOTPROD_D(x10, x10d, x21, x21d, dotresult, dotresultd)
    ad(2) = 2*dotresultd
    a(2) = 2*dotresult
    CALL DOTPROD_D(x10, x10d, x41, x41d, dotresult, dotresultd)
    ad(3) = 2*dotresultd
    a(3) = 2*dotresult
    dummyvecd = x21d
    dummyvec = x21
    CALL DOTPROD_D(x21, x21d, dummyvec, dummyvecd, dotresult, dotresultd&
&           )
    ad(4) = dotresultd
    a(4) = dotresult
    CALL DOTPROD_D(x10, x10d, x3142, x3142d, dotresult, dotresultd)
    ad(5) = 2*dotresultd
    a(5) = 2*dotresult
    CALL DOTPROD_D(x21, x21d, x41, x41d, dotresult, dotresultd)
    ad(5) = ad(5) + 2*dotresultd
    a(5) = a(5) + 2*dotresult
    dummyvecd = x41d
    dummyvec = x41
    CALL DOTPROD_D(x41, x41d, dummyvec, dummyvecd, dotresult, dotresultd&
&           )
    ad(6) = dotresultd
    a(6) = dotresult
    CALL DOTPROD_D(x21, x21d, x3142, x3142d, dotresult, dotresultd)
    ad(7) = 2*dotresultd
    a(7) = 2*dotresult
    CALL DOTPROD_D(x41, x41d, x3142, x3142d, dotresult, dotresultd)
    ad(8) = 2*dotresultd
    a(8) = 2*dotresult
    dummyvecd = x3142d
    dummyvec = x3142
    CALL DOTPROD_D(x3142, x3142d, dummyvec, dummyvecd, dotresult, &
&            dotresultd)
    ad(9) = dotresultd
    a(9) = dotresult
! Assemble the gradient of the vector of independent variables (grad(X))
! gradUV(1,:) are derivatives with respect to u
! gradUV(2,:) are derivatives with respect to v
    graduv(1, 1) = 0.0
    graduv(1, 2) = 1.0
    graduv(1, 3) = 0.0
    graduvd = 0.0_8
    graduvd(1, 4) = 2.0*ud
    graduv(1, 4) = 2.0*u
    graduvd(1, 5) = vd
    graduv(1, 5) = v
    graduvd(1, 6) = 0.0_8
    graduv(1, 6) = 0.0
    graduvd(1, 7) = 2.0*(v*ud+u*vd)
    graduv(1, 7) = 2.0*u*v
    graduvd(1, 8) = 2*v*vd
    graduv(1, 8) = v*v
    graduvd(1, 9) = 2.0*(v**2*ud+u*2*v*vd)
    graduv(1, 9) = 2.0*u*v*v
    graduvd(2, 1) = 0.0_8
    graduv(2, 1) = 0.0
    graduvd(2, 2) = 0.0_8
    graduv(2, 2) = 0.0
    graduvd(2, 3) = 0.0_8
    graduv(2, 3) = 1.0
    graduvd(2, 4) = 0.0_8
    graduv(2, 4) = 0.0
    graduvd(2, 5) = ud
    graduv(2, 5) = u
    graduvd(2, 6) = 2.0*vd
    graduv(2, 6) = 2.0*v
    graduvd(2, 7) = 2*u*ud
    graduv(2, 7) = u*u
    graduvd(2, 8) = 2.0*(v*ud+u*vd)
    graduv(2, 8) = 2.0*u*v
    graduvd(2, 9) = 2.0*(v*2*u*ud+u**2*vd)
    graduv(2, 9) = 2.0*u*u*v
! Now compute the gradient of the objective function (grad(dist2))
    graddist2d = 0.0_8
    CALL DOTPROD_D(a, ad, graduv(1, :), graduvd(1, :), graddist2(1), &
&            graddist2d(1))
    CALL DOTPROD_D(a, ad, graduv(2, :), graduvd(2, :), graddist2(2), &
&            graddist2d(2))
! The residual is the objective function gradient
    residuald = graddist2d
    residual = graddist2
! Now assemble the Jacobian of the function we are solving (Jac(grad(dist2)))
    jac(1, 1) = 2.0*(a(4)+v*a(7)+v*v*a(9))
    jac(1, 2) = a(5) + 2.0*(u*a(7)+v*a(8)+2*u*v*a(9))
    jac(2, 1) = jac(1, 2)
    jac(2, 2) = 2.0*(a(6)+u*a(8)+u*u*a(9))
! Invert the Jacobian
    CALL INVERT2X2(jac, invjac)
  END SUBROUTINE QUADPROJRESIDUAL_D

  SUBROUTINE QUADPROJRESIDUAL(x1, x2, x3, x4, x, u, v, residual, invjac)
    IMPLICIT NONE
! DECLARATIONS
! Input variables
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x1, x2, x3, x4
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x
    REAL(kind=realtype), INTENT(IN) :: u, v
! Output variables
    REAL(kind=realtype), DIMENSION(2), INTENT(OUT) :: residual
    REAL(kind=realtype), DIMENSION(2, 2), INTENT(OUT) :: invjac
! Working variables
    REAL(kind=realtype), DIMENSION(3) :: x10, x21, x41, x3142, dummyvec
    REAL(kind=realtype), DIMENSION(9) :: a
    REAL(kind=realtype), DIMENSION(2, 9) :: graduv
    REAL(kind=realtype), DIMENSION(2) :: graddist2
    REAL(kind=realtype), DIMENSION(2, 2) :: jac
    REAL(kind=realtype) :: dotresult
! EXECUTION
! Determine auxiliary vectors
    x10 = x1 - x
    x21 = x2 - x1
    x41 = x4 - x1
    x3142 = x3 - x1 - x21 - x41
! Determine vector of coefficients (A)
    dummyvec = x10
    CALL DOTPROD(x10, dummyvec, dotresult)
    a(1) = dotresult
    CALL DOTPROD(x10, x21, dotresult)
    a(2) = 2*dotresult
    CALL DOTPROD(x10, x41, dotresult)
    a(3) = 2*dotresult
    dummyvec = x21
    CALL DOTPROD(x21, dummyvec, dotresult)
    a(4) = dotresult
    CALL DOTPROD(x10, x3142, dotresult)
    a(5) = 2*dotresult
    CALL DOTPROD(x21, x41, dotresult)
    a(5) = a(5) + 2*dotresult
    dummyvec = x41
    CALL DOTPROD(x41, dummyvec, dotresult)
    a(6) = dotresult
    CALL DOTPROD(x21, x3142, dotresult)
    a(7) = 2*dotresult
    CALL DOTPROD(x41, x3142, dotresult)
    a(8) = 2*dotresult
    dummyvec = x3142
    CALL DOTPROD(x3142, dummyvec, dotresult)
    a(9) = dotresult
! Assemble the gradient of the vector of independent variables (grad(X))
! gradUV(1,:) are derivatives with respect to u
! gradUV(2,:) are derivatives with respect to v
    graduv(1, 1) = 0.0
    graduv(1, 2) = 1.0
    graduv(1, 3) = 0.0
    graduv(1, 4) = 2.0*u
    graduv(1, 5) = v
    graduv(1, 6) = 0.0
    graduv(1, 7) = 2.0*u*v
    graduv(1, 8) = v*v
    graduv(1, 9) = 2.0*u*v*v
    graduv(2, 1) = 0.0
    graduv(2, 2) = 0.0
    graduv(2, 3) = 1.0
    graduv(2, 4) = 0.0
    graduv(2, 5) = u
    graduv(2, 6) = 2.0*v
    graduv(2, 7) = u*u
    graduv(2, 8) = 2.0*u*v
    graduv(2, 9) = 2.0*u*u*v
! Now compute the gradient of the objective function (grad(dist2))
    CALL DOTPROD(a, graduv(1, :), graddist2(1))
    CALL DOTPROD(a, graduv(2, :), graddist2(2))
! The residual is the objective function gradient
    residual = graddist2
! Now assemble the Jacobian of the function we are solving (Jac(grad(dist2)))
    jac(1, 1) = 2.0*(a(4)+v*a(7)+v*v*a(9))
    jac(1, 2) = a(5) + 2.0*(u*a(7)+v*a(8)+2*u*v*a(9))
    jac(2, 1) = jac(1, 2)
    jac(2, 2) = 2.0*(a(6)+u*a(8)+u*u*a(9))
! Invert the Jacobian
    CALL INVERT2X2(jac, invjac)
  END SUBROUTINE QUADPROJRESIDUAL

!  Differentiation of quadprojoutput in forward (tangent) mode:
!   variations   of useful results: xf
!   with respect to varying inputs: u v x1 x2 x3 x4
!   RW status of diff variables: u:in v:in xf:out x1:in x2:in x3:in
!                x4:in
!===============================================================
  SUBROUTINE QUADPROJOUTPUT_D(x1, x1d, x2, x2d, x3, x3d, x4, x4d, u, ud&
&   , v, vd, xf, xfd)
    IMPLICIT NONE
! DECLARATIONS
! Input variables
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x1, x2, x3, x4
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x1d, x2d, x3d, x4d
    REAL(kind=realtype), INTENT(IN) :: u, v
    REAL(kind=realtype), INTENT(IN) :: ud, vd
! Output variables
    REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: xf
    REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: xfd
! Working variables
    REAL(kind=realtype), DIMENSION(3) :: x21, x41, x3142
    REAL(kind=realtype), DIMENSION(3) :: x21d, x41d, x3142d
! EXECUTION
! Determine auxiliary vectors
    x21d = x2d - x1d
    x21 = x2 - x1
    x41d = x4d - x1d
    x41 = x4 - x1
    x3142d = x3d - x1d - x21d - x41d
    x3142 = x3 - x1 - x21 - x41
! Compute guess for projection point
    xfd = x1d + x21*ud + u*x21d + x41*vd + v*x41d + x3142*(v*ud+u*vd) + &
&     u*v*x3142d
    xf = x1 + u*x21 + v*x41 + u*v*x3142
  END SUBROUTINE QUADPROJOUTPUT_D

!===============================================================
  SUBROUTINE QUADPROJOUTPUT(x1, x2, x3, x4, u, v, xf)
    IMPLICIT NONE
! DECLARATIONS
! Input variables
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x1, x2, x3, x4
    REAL(kind=realtype), INTENT(IN) :: u, v
! Output variables
    REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: xf
! Working variables
    REAL(kind=realtype), DIMENSION(3) :: x21, x41, x3142
! EXECUTION
! Determine auxiliary vectors
    x21 = x2 - x1
    x41 = x4 - x1
    x3142 = x3 - x1 - x21 - x41
! Compute guess for projection point
    xf = x1 + u*x21 + v*x41 + u*v*x3142
  END SUBROUTINE QUADPROJOUTPUT

!  Differentiation of triaweights in forward (tangent) mode:
!   variations   of useful results: weight
!   with respect to varying inputs: u v
!   RW status of diff variables: u:in v:in weight:out
!===============================================================
!===============================================================
!===============================================================
! WEIGHT FUNCTIONS
  SUBROUTINE TRIAWEIGHTS_D(u, ud, v, vd, weight, weightd)
    IMPLICIT NONE
! This subroutine compute the interpolation weights based
! on parametric coordinates.
! DECLARATIONS
! Inputs variables
    REAL(kind=realtype), INTENT(IN) :: u, v
    REAL(kind=realtype), INTENT(IN) :: ud, vd
! Output variables
    REAL(kind=realtype), DIMENSION(8), INTENT(OUT) :: weight
    REAL(kind=realtype), DIMENSION(8), INTENT(OUT) :: weightd
! EXECUTION
! Initialize weight vector
    weight = 0.0
! Update values according to the current element type
    weightd = 0.0_8
    weightd(1) = -ud - vd
    weight(1) = one - u - v
    weightd(2) = ud
    weight(2) = u
    weightd(3) = vd
    weight(3) = v
  END SUBROUTINE TRIAWEIGHTS_D

!===============================================================
!===============================================================
!===============================================================
! WEIGHT FUNCTIONS
  SUBROUTINE TRIAWEIGHTS(u, v, weight)
    IMPLICIT NONE
! This subroutine compute the interpolation weights based
! on parametric coordinates.
! DECLARATIONS
! Inputs variables
    REAL(kind=realtype), INTENT(IN) :: u, v
! Output variables
    REAL(kind=realtype), DIMENSION(8), INTENT(OUT) :: weight
! EXECUTION
! Initialize weight vector
    weight = 0.0
! Update values according to the current element type
    weight(1) = one - u - v
    weight(2) = u
    weight(3) = v
  END SUBROUTINE TRIAWEIGHTS

!  Differentiation of quadweights in forward (tangent) mode:
!   variations   of useful results: weight
!   with respect to varying inputs: u v
!   RW status of diff variables: u:in v:in weight:out
!===============================================================
  SUBROUTINE QUADWEIGHTS_D(u, ud, v, vd, weight, weightd)
    IMPLICIT NONE
! This subroutine compute the interpolation weights based
! on parametric coordinates.
! DECLARATIONS
! Inputs variables
    REAL(kind=realtype), INTENT(IN) :: u, v
    REAL(kind=realtype), INTENT(IN) :: ud, vd
! Output variables
    REAL(kind=realtype), DIMENSION(8), INTENT(OUT) :: weight
    REAL(kind=realtype), DIMENSION(8), INTENT(OUT) :: weightd
! EXECUTION
! Initialize weight vector
    weight = 0.0
! Update values according to the current element type
    weightd = 0.0_8
    weightd(1) = -((one-v)*ud) - (one-u)*vd
    weight(1) = (one-u)*(one-v)
    weightd(2) = (one-v)*ud - u*vd
    weight(2) = u*(one-v)
    weightd(3) = v*ud + u*vd
    weight(3) = u*v
    weightd(4) = (one-u)*vd - v*ud
    weight(4) = (one-u)*v
  END SUBROUTINE QUADWEIGHTS_D

!===============================================================
  SUBROUTINE QUADWEIGHTS(u, v, weight)
    IMPLICIT NONE
! This subroutine compute the interpolation weights based
! on parametric coordinates.
! DECLARATIONS
! Inputs variables
    REAL(kind=realtype), INTENT(IN) :: u, v
! Output variables
    REAL(kind=realtype), DIMENSION(8), INTENT(OUT) :: weight
! EXECUTION
! Initialize weight vector
    weight = 0.0
! Update values according to the current element type
    weight(1) = (one-u)*(one-v)
    weight(2) = u*(one-v)
    weight(3) = u*v
    weight(4) = (one-u)*v
  END SUBROUTINE QUADWEIGHTS

!  Differentiation of computenodalnormals in forward (tangent) mode:
!   variations   of useful results: nodalnormals
!   with respect to varying inputs: coor
!   RW status of diff variables: coor:in nodalnormals:out
!===============================================================
!===============================================================
!===============================================================
  SUBROUTINE COMPUTENODALNORMALS_D(ncoor, ntria, nquads, coor, coord, &
&   triaconn, quadsconn, nodalnormals, nodalnormalsd)
    IMPLICIT NONE
!
!       Subroutine arguments.
!
! Input
    INTEGER(kind=inttype), INTENT(IN) :: ncoor, ntria, nquads
    REAL(kind=realtype), DIMENSION(3, ncoor), INTENT(IN) :: coor
    REAL(kind=realtype), DIMENSION(3, ncoor), INTENT(IN) :: coord
    INTEGER(kind=inttype), DIMENSION(3, ntria), INTENT(IN) :: triaconn
    INTEGER(kind=inttype), DIMENSION(4, nquads), INTENT(IN) :: quadsconn
! Output
    REAL(kind=realtype), DIMENSION(3, ncoor), INTENT(OUT) :: &
&   nodalnormals
    REAL(kind=realtype), DIMENSION(3, ncoor), INTENT(OUT) :: &
&   nodalnormalsd
! Working
    INTEGER(kind=inttype), DIMENSION(ncoor) :: connect_count
    REAL(kind=realtype) :: normal1(3), normal2(3), normal3(3), normal4(3&
&   )
    REAL(kind=realtype) :: normal1d(3)
    INTEGER(kind=inttype) :: i, ind1, ind2, ind3, ind4
    REAL(kind=realtype) :: x1(3), x2(3), x3(3), x4(3)
    REAL(kind=realtype) :: x1d(3), x2d(3), x3d(3), x4d(3)
    REAL(kind=realtype) :: x12(3), x23(3), x13(3), x24(3)
    REAL(kind=realtype) :: x12d(3), x23d(3), x13d(3), x24d(3)
    REAL(kind=realtype) :: dotresult, dummyvec(3)
    REAL(kind=realtype) :: dotresultd, dummyvecd(3)
    INTRINSIC SQRT
    REAL(kind=realtype) :: result1
    REAL(kind=realtype) :: result1d
    REAL(kind=realtype) :: temp
!===============================================================
! Initialize cumulative variables
    nodalnormals = 0.0
    connect_count = 0
    nodalnormalsd = 0.0_8
    normal1d = 0.0_8
! Loop over triangle connectivities
    DO i=1,ntria
! Get the indices for each node of the triangle element
      ind1 = triaconn(1, i)
      ind2 = triaconn(2, i)
      ind3 = triaconn(3, i)
! Get the coordinates for each node of the triangle element
      x1d = coord(:, ind1)
      x1 = coor(:, ind1)
      x2d = coord(:, ind2)
      x2 = coor(:, ind2)
      x3d = coord(:, ind3)
      x3 = coor(:, ind3)
! Compute relative vectors for the triangle sides
      x12d = x1d - x2d
      x12 = x1 - x2
      x23d = x2d - x3d
      x23 = x2 - x3
! Take the cross-product of these vectors to obtain the normal vector
      CALL CROSSPROD_D(x12, x12d, x23, x23d, normal1, normal1d)
! Normalize this normal vector
      dummyvecd = normal1d
      dummyvec = normal1
      CALL DOTPROD_D(normal1, normal1d, dummyvec, dummyvecd, dotresult, &
&              dotresultd)
      temp = SQRT(dotresult)
      IF (dotresult .EQ. 0.0) THEN
        result1d = 0.0_8
      ELSE
        result1d = dotresultd/(2.0*temp)
      END IF
      result1 = temp
      normal1d = (normal1d-normal1*result1d/result1)/result1
      normal1 = normal1/result1
! Add the contribution of this normal to the nodalNormals array
      nodalnormalsd(:, ind1) = nodalnormalsd(:, ind1) + normal1d
      nodalnormals(:, ind1) = nodalnormals(:, ind1) + normal1
      nodalnormalsd(:, ind2) = nodalnormalsd(:, ind2) + normal1d
      nodalnormals(:, ind2) = nodalnormals(:, ind2) + normal1
      nodalnormalsd(:, ind3) = nodalnormalsd(:, ind3) + normal1d
      nodalnormals(:, ind3) = nodalnormals(:, ind3) + normal1
! Add connectivity information to the connect_count array so we
! know how many edges are connected to a node.
! We divide the nodalNormals vector by this number to obtain the
! averaged nodal normal.
      connect_count(ind1) = connect_count(ind1) + 1
      connect_count(ind2) = connect_count(ind2) + 1
      connect_count(ind3) = connect_count(ind3) + 1
    END DO
! Loop over quad connectivities
    DO i=1,nquads
! Get the indices for each node of the quad element
      ind1 = quadsconn(1, i)
      ind2 = quadsconn(2, i)
      ind3 = quadsconn(3, i)
      ind4 = quadsconn(4, i)
! Get the coordinates for each node of the quad element
      x1d = coord(:, ind1)
      x1 = coor(:, ind1)
      x2d = coord(:, ind2)
      x2 = coor(:, ind2)
      x3d = coord(:, ind3)
      x3 = coor(:, ind3)
      x4d = coord(:, ind4)
      x4 = coor(:, ind4)
! Compute relative vectors for the quad sides
      x13d = x3d - x1d
      x13 = x3 - x1
      x24d = x4d - x2d
      x24 = x4 - x2
! Take the cross-product of these vectors to obtain the normal vectors
! Normalize these normal vectors
      CALL CROSSPROD_D(x13, x13d, x24, x24d, normal1, normal1d)
      dummyvecd = normal1d
      dummyvec = normal1
      CALL DOTPROD_D(normal1, normal1d, dummyvec, dummyvecd, dotresult, &
&              dotresultd)
      temp = SQRT(dotresult)
      IF (dotresult .EQ. 0.0) THEN
        result1d = 0.0_8
      ELSE
        result1d = dotresultd/(2.0*temp)
      END IF
      result1 = temp
      normal1d = (normal1d-normal1*result1d/result1)/result1
      normal1 = normal1/result1
! Add the contribution of this normal to the nodalNormals array
      nodalnormalsd(:, ind1) = nodalnormalsd(:, ind1) + normal1d
      nodalnormals(:, ind1) = nodalnormals(:, ind1) + normal1
      nodalnormalsd(:, ind2) = nodalnormalsd(:, ind2) + normal1d
      nodalnormals(:, ind2) = nodalnormals(:, ind2) + normal1
      nodalnormalsd(:, ind3) = nodalnormalsd(:, ind3) + normal1d
      nodalnormals(:, ind3) = nodalnormals(:, ind3) + normal1
      nodalnormalsd(:, ind4) = nodalnormalsd(:, ind4) + normal1d
      nodalnormals(:, ind4) = nodalnormals(:, ind4) + normal1
! Add connectivity information to the connect_count array so we
! know how many edges are connected to a node.
! We divide the nodalNormals vector by this number to obtain the
! averaged nodal normal.
      connect_count(ind1) = connect_count(ind1) + 1
      connect_count(ind2) = connect_count(ind2) + 1
      connect_count(ind3) = connect_count(ind3) + 1
      connect_count(ind4) = connect_count(ind4) + 1
    END DO
    DO i=1,3
! Divide the nodal normals by the number of edges that each node has
      nodalnormalsd(i, :) = nodalnormalsd(i, :)/connect_count
      nodalnormals(i, :) = nodalnormals(i, :)/connect_count
    END DO
    DO i=1,ncoor
! Normalize these new averaged nodal normals
      normal1d = nodalnormalsd(:, i)
      normal1 = nodalnormals(:, i)
      dummyvecd = normal1d
      dummyvec = normal1
      CALL DOTPROD_D(normal1, normal1d, dummyvec, dummyvecd, dotresult, &
&              dotresultd)
      temp = SQRT(dotresult)
      IF (dotresult .EQ. 0.0) THEN
        result1d = 0.0_8
      ELSE
        result1d = dotresultd/(2.0*temp)
      END IF
      result1 = temp
      nodalnormalsd(:, i) = (normal1d-normal1*result1d/result1)/result1
      nodalnormals(:, i) = normal1/result1
    END DO
  END SUBROUTINE COMPUTENODALNORMALS_D

!===============================================================
!===============================================================
!===============================================================
  SUBROUTINE COMPUTENODALNORMALS(ncoor, ntria, nquads, coor, triaconn, &
&   quadsconn, nodalnormals)
    IMPLICIT NONE
!
!       Subroutine arguments.
!
! Input
    INTEGER(kind=inttype), INTENT(IN) :: ncoor, ntria, nquads
    REAL(kind=realtype), DIMENSION(3, ncoor), INTENT(IN) :: coor
    INTEGER(kind=inttype), DIMENSION(3, ntria), INTENT(IN) :: triaconn
    INTEGER(kind=inttype), DIMENSION(4, nquads), INTENT(IN) :: quadsconn
! Output
    REAL(kind=realtype), DIMENSION(3, ncoor), INTENT(OUT) :: &
&   nodalnormals
! Working
    INTEGER(kind=inttype), DIMENSION(ncoor) :: connect_count
    REAL(kind=realtype) :: normal1(3), normal2(3), normal3(3), normal4(3&
&   )
    INTEGER(kind=inttype) :: i, ind1, ind2, ind3, ind4
    REAL(kind=realtype) :: x1(3), x2(3), x3(3), x4(3)
    REAL(kind=realtype) :: x12(3), x23(3), x13(3), x24(3)
    REAL(kind=realtype) :: dotresult, dummyvec(3)
    INTRINSIC SQRT
    REAL(kind=realtype) :: result1
!===============================================================
! Initialize cumulative variables
    nodalnormals = 0.0
    connect_count = 0
! Loop over triangle connectivities
    DO i=1,ntria
! Get the indices for each node of the triangle element
      ind1 = triaconn(1, i)
      ind2 = triaconn(2, i)
      ind3 = triaconn(3, i)
! Get the coordinates for each node of the triangle element
      x1 = coor(:, ind1)
      x2 = coor(:, ind2)
      x3 = coor(:, ind3)
! Compute relative vectors for the triangle sides
      x12 = x1 - x2
      x23 = x2 - x3
! Take the cross-product of these vectors to obtain the normal vector
      CALL CROSSPROD(x12, x23, normal1)
! Normalize this normal vector
      dummyvec = normal1
      CALL DOTPROD(normal1, dummyvec, dotresult)
      result1 = SQRT(dotresult)
      normal1 = normal1/result1
! Add the contribution of this normal to the nodalNormals array
      nodalnormals(:, ind1) = nodalnormals(:, ind1) + normal1
      nodalnormals(:, ind2) = nodalnormals(:, ind2) + normal1
      nodalnormals(:, ind3) = nodalnormals(:, ind3) + normal1
! Add connectivity information to the connect_count array so we
! know how many edges are connected to a node.
! We divide the nodalNormals vector by this number to obtain the
! averaged nodal normal.
      connect_count(ind1) = connect_count(ind1) + 1
      connect_count(ind2) = connect_count(ind2) + 1
      connect_count(ind3) = connect_count(ind3) + 1
    END DO
! Loop over quad connectivities
    DO i=1,nquads
! Get the indices for each node of the quad element
      ind1 = quadsconn(1, i)
      ind2 = quadsconn(2, i)
      ind3 = quadsconn(3, i)
      ind4 = quadsconn(4, i)
! Get the coordinates for each node of the quad element
      x1 = coor(:, ind1)
      x2 = coor(:, ind2)
      x3 = coor(:, ind3)
      x4 = coor(:, ind4)
! Compute relative vectors for the quad sides
      x13 = x3 - x1
      x24 = x4 - x2
! Take the cross-product of these vectors to obtain the normal vectors
! Normalize these normal vectors
      CALL CROSSPROD(x13, x24, normal1)
      dummyvec = normal1
      CALL DOTPROD(normal1, dummyvec, dotresult)
      result1 = SQRT(dotresult)
      normal1 = normal1/result1
! Add the contribution of this normal to the nodalNormals array
      nodalnormals(:, ind1) = nodalnormals(:, ind1) + normal1
      nodalnormals(:, ind2) = nodalnormals(:, ind2) + normal1
      nodalnormals(:, ind3) = nodalnormals(:, ind3) + normal1
      nodalnormals(:, ind4) = nodalnormals(:, ind4) + normal1
! Add connectivity information to the connect_count array so we
! know how many edges are connected to a node.
! We divide the nodalNormals vector by this number to obtain the
! averaged nodal normal.
      connect_count(ind1) = connect_count(ind1) + 1
      connect_count(ind2) = connect_count(ind2) + 1
      connect_count(ind3) = connect_count(ind3) + 1
      connect_count(ind4) = connect_count(ind4) + 1
    END DO
    DO i=1,3
! Divide the nodal normals by the number of edges that each node has
      nodalnormals(i, :) = nodalnormals(i, :)/connect_count
    END DO
    DO i=1,ncoor
! Normalize these new averaged nodal normals
      normal1 = nodalnormals(:, i)
      dummyvec = normal1
      CALL DOTPROD(normal1, dummyvec, dotresult)
      result1 = SQRT(dotresult)
      nodalnormals(:, i) = normal1/result1
    END DO
  END SUBROUTINE COMPUTENODALNORMALS

!  Differentiation of crossprod in forward (tangent) mode:
!   variations   of useful results: c
!   with respect to varying inputs: a b c
!===============================================================
!===============================================================
!===============================================================
  SUBROUTINE CROSSPROD_D(a, ad, b, bd, c, cd)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: a(3), b(3)
    REAL(kind=realtype), INTENT(IN) :: ad(3), bd(3)
    REAL(kind=realtype), INTENT(OUT) :: c(3)
    REAL(kind=realtype), INTENT(OUT) :: cd(3)
    cd(1) = b(3)*ad(2) + a(2)*bd(3) - b(2)*ad(3) - a(3)*bd(2)
    c(1) = a(2)*b(3) - a(3)*b(2)
    cd(2) = b(1)*ad(3) + a(3)*bd(1) - b(3)*ad(1) - a(1)*bd(3)
    c(2) = a(3)*b(1) - a(1)*b(3)
    cd(3) = b(2)*ad(1) + a(1)*bd(2) - b(1)*ad(2) - a(2)*bd(1)
    c(3) = a(1)*b(2) - a(2)*b(1)
  END SUBROUTINE CROSSPROD_D

!===============================================================
!===============================================================
!===============================================================
  SUBROUTINE CROSSPROD(a, b, c)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: a(3), b(3)
    REAL(kind=realtype), INTENT(OUT) :: c(3)
    c(1) = a(2)*b(3) - a(3)*b(2)
    c(2) = a(3)*b(1) - a(1)*b(3)
    c(3) = a(1)*b(2) - a(2)*b(1)
  END SUBROUTINE CROSSPROD

!  Differentiation of dotprod in forward (tangent) mode:
!   variations   of useful results: c
!   with respect to varying inputs: a b
!===============================================================
  SUBROUTINE DOTPROD_D(a, ad, b, bd, c, cd)
    IMPLICIT NONE
! DECLARATIONS
! Input variables
    REAL(kind=realtype), DIMENSION(:), INTENT(IN) :: a, b
    REAL(kind=realtype), DIMENSION(:), INTENT(IN) :: ad, bd
! Output variables
    REAL(kind=realtype), INTENT(OUT) :: c
    REAL(kind=realtype), INTENT(OUT) :: cd
! Working variables
    INTEGER(kind=inttype) :: ii
    INTRINSIC SUM
! EXECUTION
    cd = SUM(b*ad + a*bd)
    c = SUM(a*b)
  END SUBROUTINE DOTPROD_D

!===============================================================
  SUBROUTINE DOTPROD(a, b, c)
    IMPLICIT NONE
! DECLARATIONS
! Input variables
    REAL(kind=realtype), DIMENSION(:), INTENT(IN) :: a, b
! Output variables
    REAL(kind=realtype), INTENT(OUT) :: c
! Working variables
    INTEGER(kind=inttype) :: ii
    INTRINSIC SUM
! EXECUTION
    c = SUM(a*b)
  END SUBROUTINE DOTPROD

!===============================================================
  SUBROUTINE INVERT2X2(a, ainv)
    IMPLICIT NONE
! DECLARATIONS
! Input variables
    REAL(kind=realtype), DIMENSION(2, 2), INTENT(IN) :: a
! Output variables
    REAL(kind=realtype), DIMENSION(2, 2), INTENT(OUT) :: ainv
! Working variables
    REAL(kind=realtype) :: detinv
! EXECUTION
! Compute the determinant
    detinv = 1.0/(a(1, 1)*a(2, 2)-a(1, 2)*a(2, 1))
! Compute inverted matrix
    ainv(1, 1) = a(2, 2)*detinv
    ainv(1, 2) = -(a(1, 2)*detinv)
    ainv(2, 1) = -(a(2, 1)*detinv)
    ainv(2, 2) = a(1, 1)*detinv
  END SUBROUTINE INVERT2X2

END MODULE ADTPROJECTIONS_D

