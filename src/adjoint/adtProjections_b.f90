!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) - 22 Aug 2023 15:51
!
!
!     ******************************************************************
!     *                                                                *
!     * File:          adtProjections.F90                              *
!     * Author:        Edwin van der Weide                             *
!     * Starting date: 10-27-2016                                      *
!     * Last modified: 10-27-2016                                      *
!     *                                                                *
!     ******************************************************************
!
MODULE ADTPROJECTIONS_B
!
!     ******************************************************************
!     *                                                                *
!     * Module, which contains small subroutines which perform         *
!     * projection tasks. They are grouped here so they could be       *
!     * easily differentiated.                                         *
!     *                                                                *
!     ******************************************************************
!
  USE PRECISION
  USE CONSTANTS
  IMPLICIT NONE

CONTAINS
!  Differentiation of triaprojection in reverse (adjoint) mode:
!   gradient     of useful results: u v xf
!   with respect to varying inputs: u v x xf x1 x2 x3
!   RW status of diff variables: u:in-zero v:in-zero x:out xf:in-zero
!                x1:out x2:out x3:out
!===============================================================
  SUBROUTINE TRIAPROJECTION_B(x1, x1b, x2, x2b, x3, x3b, x, xb, xf, xfb&
&   , u, ub, v, vb, val)
    IMPLICIT NONE
! DECLARATIONS
! Input variables
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x1, x2, x3
    REAL(kind=realtype), DIMENSION(3) :: x1b, x2b, x3b
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x
    REAL(kind=realtype), DIMENSION(3) :: xb
! Output variables
    REAL(kind=realtype), DIMENSION(3) :: xf
    REAL(kind=realtype), DIMENSION(3) :: xfb
    REAL(kind=realtype) :: u, v, val
    REAL(kind=realtype) :: ub, vb
! Working variables
    REAL(kind=realtype), DIMENSION(3) :: a, b, vf, vt
    REAL(kind=realtype), DIMENSION(3) :: ab, bb, vfb, vtb
    REAL(kind=realtype), DIMENSION(3) :: an, bn, norm
    REAL(kind=realtype), DIMENSION(3) :: anb, bnb, normb
    REAL(kind=realtype) :: invlen, vn, dx, dy, dz, uv
    REAL(kind=realtype) :: invlenb, vnb, uvb
    INTRINSIC SQRT
    INTRINSIC MAX
    INTRINSIC ABS
    INTRINSIC SIGN
    INTRINSIC MIN
    REAL(kind=realtype) :: y1
    REAL(kind=realtype) :: y1b
    REAL(kind=realtype) :: y2
    REAL(kind=realtype) :: y2b
    REAL(kind=realtype) :: y3
    REAL(kind=realtype) :: y3b
    REAL(kind=realtype) :: y4
    REAL(kind=realtype) :: y4b
    REAL(kind=realtype) :: y5
    REAL(kind=realtype) :: y5b
    REAL(kind=realtype) :: max1
    REAL(kind=realtype) :: max1b
    REAL(kind=realtype) :: max2
    REAL(kind=realtype) :: max2b
    REAL(kind=realtype) :: max3
    REAL(kind=realtype) :: max3b
    REAL(kind=realtype) :: tempb
    INTEGER :: branch
! EXECUTION
! Determine the tangent vectors in u- and v-direction.
! Store these in a and b respectively.
    a = x2 - x1
    b = x3 - x1
! Determine the normal vector of the face by taking the
! cross product of a and b. Afterwards this vector will
! be scaled to a unit vector.
    norm(1) = a(2)*b(3) - a(3)*b(2)
    norm(2) = a(3)*b(1) - a(1)*b(3)
    norm(3) = a(1)*b(2) - a(2)*b(1)
    y1 = SQRT(norm(1)*norm(1) + norm(2)*norm(2) + norm(3)*norm(3))
    IF (eps .LT. y1) THEN
      max1 = y1
      CALL PUSHCONTROL1B(0)
    ELSE
      max1 = eps
      CALL PUSHCONTROL1B(1)
    END IF
    invlen = one/max1
    CALL PUSHREAL8(norm(1))
    norm(1) = norm(1)*invlen
    CALL PUSHREAL8(norm(2))
    norm(2) = norm(2)*invlen
    CALL PUSHREAL8(norm(3))
    norm(3) = norm(3)*invlen
! Determine the vector vf from xf to given coordinate.
    vf(1) = x(1) - x1(1)
    vf(2) = x(2) - x1(2)
    vf(3) = x(3) - x1(3)
! Determine the projection of the vector vf onto
! the face.
    vn = vf(1)*norm(1) + vf(2)*norm(2) + vf(3)*norm(3)
    vt(1) = vf(1) - vn*norm(1)
    vt(2) = vf(2) - vn*norm(2)
    vt(3) = vf(3) - vn*norm(3)
! The vector vt points from the current point on the
! face to the new point. However this new point lies on
! the plane determined by the vectors a and b, but not
! necessarily on the face itself. The new point on the
! face is obtained by projecting the point in the a-b
! plane onto the face. this can be done by determining
! the coefficients du and dv, such that vt = du*a + dv*b.
! To solve du and dv the vectors normal to a and b
! inside the plane ab are needed.
    an(1) = a(2)*norm(3) - a(3)*norm(2)
    an(2) = a(3)*norm(1) - a(1)*norm(3)
    an(3) = a(1)*norm(2) - a(2)*norm(1)
    bn(1) = b(2)*norm(3) - b(3)*norm(2)
    bn(2) = b(3)*norm(1) - b(1)*norm(3)
    bn(3) = b(1)*norm(2) - b(2)*norm(1)
! Solve parametric coordinates u and v.
! The clipping of vn should not be
! active, as this would mean that the vectors a and b
! are parallel. This corresponds to a tria degenerated
! to a line, which should not occur in the surface mesh.
    vn = a(1)*bn(1) + a(2)*bn(2) + a(3)*bn(3)
    IF (vn .GE. 0.) THEN
      y2 = vn
      CALL PUSHCONTROL1B(0)
    ELSE
      y2 = -vn
      CALL PUSHCONTROL1B(1)
    END IF
    IF (eps .LT. y2) THEN
      max2 = y2
      CALL PUSHCONTROL1B(0)
    ELSE
      max2 = eps
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8(vn)
    vn = SIGN(max2, vn)
    u = (vt(1)*bn(1)+vt(2)*bn(2)+vt(3)*bn(3))/vn
    CALL PUSHREAL8(vn)
    vn = b(1)*an(1) + b(2)*an(2) + b(3)*an(3)
    IF (vn .GE. 0.) THEN
      y3 = vn
      CALL PUSHCONTROL1B(0)
    ELSE
      y3 = -vn
      CALL PUSHCONTROL1B(1)
    END IF
    IF (eps .LT. y3) THEN
      max3 = y3
      CALL PUSHCONTROL1B(0)
    ELSE
      max3 = eps
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8(vn)
    vn = SIGN(max3, vn)
    v = (vt(1)*an(1)+vt(2)*an(2)+vt(3)*an(3))/vn
! Triangles should be bounded by the line u + v = 1
    uv = u + v
    IF (uv .GT. one) THEN
      CALL PUSHREAL8(u)
      u = u/uv
      CALL PUSHREAL8(v)
      v = v/uv
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (zero .LT. u) THEN
      y4 = u
      CALL PUSHCONTROL1B(0)
    ELSE
      y4 = zero
      CALL PUSHCONTROL1B(1)
    END IF
    IF (one .GT. y4) THEN
      u = y4
      CALL PUSHCONTROL1B(0)
    ELSE
      u = one
      CALL PUSHCONTROL1B(1)
    END IF
    IF (zero .LT. v) THEN
      y5 = v
      CALL PUSHCONTROL1B(0)
    ELSE
      y5 = zero
      CALL PUSHCONTROL1B(1)
    END IF
    IF (one .GT. y5) THEN
      v = y5
      CALL PUSHCONTROL1B(0)
    ELSE
      v = one
      CALL PUSHCONTROL1B(1)
    END IF
    x1b = 0.0_8
    ab = 0.0_8
    bb = 0.0_8
    x1b = xfb
    ub = ub + SUM(a*xfb)
    ab = u*xfb
    vb = vb + SUM(b*xfb)
    bb = v*xfb
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      y5b = vb
    ELSE
      y5b = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      vb = y5b
    ELSE
      vb = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      y4b = ub
    ELSE
      y4b = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      ub = y4b
    ELSE
      ub = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(v)
      CALL POPREAL8(u)
      uvb = -(v*vb/uv**2) - u*ub/uv**2
      vb = vb/uv
      ub = ub/uv
    ELSE
      uvb = 0.0_8
    END IF
    ub = ub + uvb
    vb = vb + uvb
    anb = 0.0_8
    vtb = 0.0_8
    tempb = vb/vn
    vtb(1) = vtb(1) + an(1)*tempb
    anb(1) = anb(1) + vt(1)*tempb
    vtb(2) = vtb(2) + an(2)*tempb
    anb(2) = anb(2) + vt(2)*tempb
    vtb(3) = vtb(3) + an(3)*tempb
    anb(3) = anb(3) + vt(3)*tempb
    vnb = -((vt(1)*an(1)+vt(2)*an(2)+vt(3)*an(3))*tempb/vn)
    CALL POPREAL8(vn)
    max3b = SIGN(1.d0, max3*vn)*vnb
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      y3b = max3b
    ELSE
      y3b = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      vnb = y3b
    ELSE
      vnb = -y3b
    END IF
    CALL POPREAL8(vn)
    bb(1) = bb(1) + an(1)*vnb
    anb(1) = anb(1) + b(1)*vnb
    bb(2) = bb(2) + an(2)*vnb
    anb(2) = anb(2) + b(2)*vnb
    bb(3) = bb(3) + an(3)*vnb
    anb(3) = anb(3) + b(3)*vnb
    bnb = 0.0_8
    tempb = ub/vn
    vtb(1) = vtb(1) + bn(1)*tempb
    bnb(1) = bnb(1) + vt(1)*tempb
    vtb(2) = vtb(2) + bn(2)*tempb
    bnb(2) = bnb(2) + vt(2)*tempb
    vtb(3) = vtb(3) + bn(3)*tempb
    bnb(3) = bnb(3) + vt(3)*tempb
    vnb = -((vt(1)*bn(1)+vt(2)*bn(2)+vt(3)*bn(3))*tempb/vn)
    CALL POPREAL8(vn)
    max2b = SIGN(1.d0, max2*vn)*vnb
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      y2b = max2b
    ELSE
      y2b = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      vnb = y2b
    ELSE
      vnb = -y2b
    END IF
    ab(1) = ab(1) + bn(1)*vnb + norm(2)*anb(3) - norm(3)*anb(2)
    bnb(1) = bnb(1) + a(1)*vnb
    ab(2) = ab(2) + bn(2)*vnb + norm(3)*anb(1) - norm(1)*anb(3)
    bnb(2) = bnb(2) + a(2)*vnb
    ab(3) = ab(3) + bn(3)*vnb + norm(1)*anb(2) - norm(2)*anb(1)
    bnb(3) = bnb(3) + a(3)*vnb
    normb = 0.0_8
    bb(1) = bb(1) + norm(2)*bnb(3) - norm(3)*bnb(2)
    bb(2) = bb(2) + norm(3)*bnb(1) - norm(1)*bnb(3)
    bb(3) = bb(3) + norm(1)*bnb(2) - norm(2)*bnb(1)
    vn = vf(1)*norm(1) + vf(2)*norm(2) + vf(3)*norm(3)
    vfb = 0.0_8
    vnb = -(norm(3)*vtb(3)) - norm(2)*vtb(2) - norm(1)*vtb(1)
    normb(2) = normb(2) + b(1)*bnb(3) + a(1)*anb(3) - b(3)*bnb(1) + vf(2&
&     )*vnb - a(3)*anb(1) - vn*vtb(2)
    normb(1) = normb(1) + b(3)*bnb(2) - b(2)*bnb(3) + a(3)*anb(2) - a(2)&
&     *anb(3) + vf(1)*vnb - vn*vtb(1)
    bnb(3) = 0.0_8
    normb(3) = normb(3) + b(2)*bnb(1) - b(1)*bnb(2) + a(2)*anb(1) - a(1)&
&     *anb(2) + vf(3)*vnb - vn*vtb(3)
    bnb(2) = 0.0_8
    anb(3) = 0.0_8
    anb(2) = 0.0_8
    vfb(3) = vfb(3) + vtb(3) + norm(3)*vnb
    vtb(3) = 0.0_8
    vfb(2) = vfb(2) + vtb(2) + norm(2)*vnb
    vtb(2) = 0.0_8
    vfb(1) = vfb(1) + vtb(1) + norm(1)*vnb
    xb = 0.0_8
    xb(3) = xb(3) + vfb(3)
    x1b(3) = x1b(3) - vfb(3)
    vfb(3) = 0.0_8
    xb(2) = xb(2) + vfb(2)
    x1b(2) = x1b(2) - vfb(2)
    vfb(2) = 0.0_8
    xb(1) = xb(1) + vfb(1)
    x1b(1) = x1b(1) - vfb(1)
    CALL POPREAL8(norm(3))
    CALL POPREAL8(norm(2))
    CALL POPREAL8(norm(1))
    invlenb = norm(3)*normb(3) + norm(2)*normb(2) + norm(1)*normb(1)
    normb(3) = invlen*normb(3)
    normb(2) = invlen*normb(2)
    normb(1) = invlen*normb(1)
    max1b = -(one*invlenb/max1**2)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      y1b = max1b
    ELSE
      y1b = 0.0_8
    END IF
    IF (norm(1)**2 + norm(2)**2 + norm(3)**2 .EQ. 0.0) THEN
      tempb = 0.0_8
    ELSE
      tempb = y1b/(2.0*SQRT(norm(1)**2+norm(2)**2+norm(3)**2))
    END IF
    normb(1) = normb(1) + 2*norm(1)*tempb
    normb(2) = normb(2) + 2*norm(2)*tempb
    normb(3) = normb(3) + 2*norm(3)*tempb
    ab(1) = ab(1) + b(2)*normb(3) - b(3)*normb(2)
    bb(2) = bb(2) + a(1)*normb(3) - a(3)*normb(1)
    ab(2) = ab(2) + b(3)*normb(1) - b(1)*normb(3)
    bb(1) = bb(1) + a(3)*normb(2) - a(2)*normb(3)
    normb(3) = 0.0_8
    ab(3) = ab(3) + b(1)*normb(2) - b(2)*normb(1)
    bb(3) = bb(3) + a(2)*normb(1) - a(1)*normb(2)
    normb(2) = 0.0_8
    x3b = 0.0_8
    x3b = bb
    x1b = x1b - bb - ab
    x2b = 0.0_8
    x2b = ab
    ub = 0.0_8
    vb = 0.0_8
    xfb = 0.0_8
  END SUBROUTINE TRIAPROJECTION_B

!===============================================================
  SUBROUTINE TRIAPROJECTION(x1, x2, x3, x, xf, u, v, val)
    IMPLICIT NONE
! DECLARATIONS
! Input variables
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x1, x2, x3
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x
! Output variables
    REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: xf
    REAL(kind=realtype), INTENT(OUT) :: u, v, val
! Working variables
    REAL(kind=realtype), DIMENSION(3) :: a, b, vf, vt
    REAL(kind=realtype), DIMENSION(3) :: an, bn, norm
    REAL(kind=realtype) :: invlen, vn, dx, dy, dz, uv
    INTRINSIC SQRT
    INTRINSIC MAX
    INTRINSIC ABS
    INTRINSIC SIGN
    INTRINSIC MIN
    REAL(kind=realtype) :: y1
    REAL(kind=realtype) :: y2
    REAL(kind=realtype) :: y3
    REAL(kind=realtype) :: y4
    REAL(kind=realtype) :: y5
    REAL(kind=realtype) :: max1
    REAL(kind=realtype) :: max2
    REAL(kind=realtype) :: max3
! EXECUTION
! Determine the tangent vectors in u- and v-direction.
! Store these in a and b respectively.
    a = x2 - x1
    b = x3 - x1
! Determine the normal vector of the face by taking the
! cross product of a and b. Afterwards this vector will
! be scaled to a unit vector.
    norm(1) = a(2)*b(3) - a(3)*b(2)
    norm(2) = a(3)*b(1) - a(1)*b(3)
    norm(3) = a(1)*b(2) - a(2)*b(1)
    y1 = SQRT(norm(1)*norm(1) + norm(2)*norm(2) + norm(3)*norm(3))
    IF (eps .LT. y1) THEN
      max1 = y1
    ELSE
      max1 = eps
    END IF
    invlen = one/max1
    norm(1) = norm(1)*invlen
    norm(2) = norm(2)*invlen
    norm(3) = norm(3)*invlen
! Determine the vector vf from xf to given coordinate.
    vf(1) = x(1) - x1(1)
    vf(2) = x(2) - x1(2)
    vf(3) = x(3) - x1(3)
! Determine the projection of the vector vf onto
! the face.
    vn = vf(1)*norm(1) + vf(2)*norm(2) + vf(3)*norm(3)
    vt(1) = vf(1) - vn*norm(1)
    vt(2) = vf(2) - vn*norm(2)
    vt(3) = vf(3) - vn*norm(3)
! The vector vt points from the current point on the
! face to the new point. However this new point lies on
! the plane determined by the vectors a and b, but not
! necessarily on the face itself. The new point on the
! face is obtained by projecting the point in the a-b
! plane onto the face. this can be done by determining
! the coefficients du and dv, such that vt = du*a + dv*b.
! To solve du and dv the vectors normal to a and b
! inside the plane ab are needed.
    an(1) = a(2)*norm(3) - a(3)*norm(2)
    an(2) = a(3)*norm(1) - a(1)*norm(3)
    an(3) = a(1)*norm(2) - a(2)*norm(1)
    bn(1) = b(2)*norm(3) - b(3)*norm(2)
    bn(2) = b(3)*norm(1) - b(1)*norm(3)
    bn(3) = b(1)*norm(2) - b(2)*norm(1)
! Solve parametric coordinates u and v.
! The clipping of vn should not be
! active, as this would mean that the vectors a and b
! are parallel. This corresponds to a tria degenerated
! to a line, which should not occur in the surface mesh.
    vn = a(1)*bn(1) + a(2)*bn(2) + a(3)*bn(3)
    IF (vn .GE. 0.) THEN
      y2 = vn
    ELSE
      y2 = -vn
    END IF
    IF (eps .LT. y2) THEN
      max2 = y2
    ELSE
      max2 = eps
    END IF
    vn = SIGN(max2, vn)
    u = (vt(1)*bn(1)+vt(2)*bn(2)+vt(3)*bn(3))/vn
    vn = b(1)*an(1) + b(2)*an(2) + b(3)*an(3)
    IF (vn .GE. 0.) THEN
      y3 = vn
    ELSE
      y3 = -vn
    END IF
    IF (eps .LT. y3) THEN
      max3 = y3
    ELSE
      max3 = eps
    END IF
    vn = SIGN(max3, vn)
    v = (vt(1)*an(1)+vt(2)*an(2)+vt(3)*an(3))/vn
! Triangles should be bounded by the line u + v = 1
    uv = u + v
    IF (uv .GT. one) THEN
      u = u/uv
      v = v/uv
    END IF
    IF (zero .LT. u) THEN
      y4 = u
    ELSE
      y4 = zero
    END IF
    IF (one .GT. y4) THEN
      u = y4
    ELSE
      u = one
    END IF
    IF (zero .LT. v) THEN
      y5 = v
    ELSE
      y5 = zero
    END IF
    IF (one .GT. y5) THEN
      v = y5
    ELSE
      v = one
    END IF
! Determine the new coordinates of the point xf.
    xf = x1 + u*a + v*b
! Compute the distance squared between the given
! coordinate and the point xf.
    dx = x(1) - xf(1)
    dy = x(2) - xf(2)
    dz = x(3) - xf(3)
    val = dx*dx + dy*dy + dz*dz
  END SUBROUTINE TRIAPROJECTION

!***************************************************************
!***************************************************************
  SUBROUTINE QUADPROJECTION(x1, x2, x3, x4, x, xf, u, v, val)
    IMPLICIT NONE
! DECLARATIONS
! Input variables
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x1, x2, x3, x4
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x
! Output variables
    REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: xf
    REAL(kind=realtype), INTENT(OUT) :: u, v, val
! Working variables
    REAL(kind=realtype), DIMENSION(2) :: residual
    REAL(kind=realtype), DIMENSION(2, 2) :: invjac
    REAL(kind=realtype) :: u_old, v_old, du, dv
    REAL(kind=realtype) :: dx, dy, dz, update
    INTEGER(kind=inttype) :: ll
! Local parameters used in the Newton algorithm.
    INTEGER(kind=inttype), PARAMETER :: itermax=15
    REAL(kind=realtype), PARAMETER :: thresconv=1.e-12_realType
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC SQRT
    REAL(kind=realtype) :: y1
    REAL(kind=realtype) :: y2
! EXECUTION
! Initialize u and v to 0.5 and determine the
! corresponding coordinates on the face, which is the
! centroid.
    u = half
    v = half
! Newton loop to determine the point on the surface,
! which minimizes the distance to the given coordinate.
newtonquads:DO ll=1,itermax
! Store previous parametric coordinates
      u_old = u
      v_old = v
      CALL QUADPROJRESIDUAL(x1, x2, x3, x4, x, u, v, residual, invjac)
! Compute the updates (remember to flip signs)
      CALL DOTPROD(invjac(1, :), residual, du)
      CALL DOTPROD(invjac(2, :), residual, dv)
      du = -du
      dv = -dv
! Determine the new parameter values uu and vv. These
! are limited to 0 <= (uu,vv) <= 1.
      u = u + du
      IF (zero .LT. u) THEN
        y1 = u
      ELSE
        y1 = zero
      END IF
      IF (one .GT. y1) THEN
        u = y1
      ELSE
        u = one
      END IF
      v = v + dv
      IF (zero .LT. v) THEN
        y2 = v
      ELSE
        y2 = zero
      END IF
      IF (one .GT. y2) THEN
        v = y2
      ELSE
        v = one
      END IF
! Update error metric (after the cropping)
      du = u - u_old
      dv = v - v_old
      update = du*du + dv*dv
! Exit the loop if the update of the parametric
! weights is below the threshold
      IF (SQRT(update) .LE. thresconv) GOTO 100
    END DO newtonquads
! Call projection one more time for the updated value of u and v
 100 CALL QUADPROJOUTPUT(x1, x2, x3, x4, u, v, xf)
! Compute the distance squared between the given
! coordinate and the point xf.
    dx = x(1) - xf(1)
    dy = x(2) - xf(2)
    dz = x(3) - xf(3)
    val = dx*dx + dy*dy + dz*dz
  END SUBROUTINE QUADPROJECTION

!  Differentiation of quadprojresidual in reverse (adjoint) mode:
!   gradient     of useful results: residual
!   with respect to varying inputs: u v x residual x1 x2 x3 x4
!   RW status of diff variables: u:out v:out x:out residual:in-zero
!                x1:out x2:out x3:out x4:out
  SUBROUTINE QUADPROJRESIDUAL_B(x1, x1b, x2, x2b, x3, x3b, x4, x4b, x, &
&   xb, u, ub, v, vb, residual, residualb, invjac)
    IMPLICIT NONE
! DECLARATIONS
! Input variables
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x1, x2, x3, x4
    REAL(kind=realtype), DIMENSION(3) :: x1b, x2b, x3b, x4b
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x
    REAL(kind=realtype), DIMENSION(3) :: xb
    REAL(kind=realtype), INTENT(IN) :: u, v
    REAL(kind=realtype) :: ub, vb
! Output variables
    REAL(kind=realtype), DIMENSION(2) :: residual
    REAL(kind=realtype), DIMENSION(2) :: residualb
    REAL(kind=realtype), DIMENSION(2, 2) :: invjac
! Working variables
    REAL(kind=realtype), DIMENSION(3) :: x10, x21, x41, x3142, dummyvec
    REAL(kind=realtype), DIMENSION(3) :: x10b, x21b, x41b, x3142b, &
&   dummyvecb
    REAL(kind=realtype), DIMENSION(9) :: a
    REAL(kind=realtype), DIMENSION(9) :: ab
    REAL(kind=realtype), DIMENSION(2, 9) :: graduv
    REAL(kind=realtype), DIMENSION(2, 9) :: graduvb
    REAL(kind=realtype), DIMENSION(2) :: graddist2
    REAL(kind=realtype), DIMENSION(2) :: graddist2b
    REAL(kind=realtype), DIMENSION(2, 2) :: jac
    REAL(kind=realtype) :: dotresult
    REAL(kind=realtype) :: dotresultb
! EXECUTION
! Determine auxiliary vectors
    x10 = x1 - x
    x21 = x2 - x1
    x41 = x4 - x1
    x3142 = x3 - x1 - x21 - x41
! Determine vector of coefficients (A)
    dummyvec = x10
    CALL DOTPROD(x10, dummyvec, dotresult)
    a(1) = dotresult
    CALL DOTPROD(x10, x21, dotresult)
    a(2) = 2*dotresult
    CALL DOTPROD(x10, x41, dotresult)
    a(3) = 2*dotresult
    dummyvec = x21
    CALL DOTPROD(x21, dummyvec, dotresult)
    a(4) = dotresult
    CALL DOTPROD(x10, x3142, dotresult)
    a(5) = 2*dotresult
    CALL DOTPROD(x21, x41, dotresult)
    a(5) = a(5) + 2*dotresult
    dummyvec = x41
    CALL DOTPROD(x41, dummyvec, dotresult)
    a(6) = dotresult
    CALL DOTPROD(x21, x3142, dotresult)
    a(7) = 2*dotresult
    CALL DOTPROD(x41, x3142, dotresult)
    a(8) = 2*dotresult
    dummyvec = x3142
    CALL DOTPROD(x3142, dummyvec, dotresult)
    a(9) = dotresult
! Assemble the gradient of the vector of independent variables (grad(X))
! gradUV(1,:) are derivatives with respect to u
! gradUV(2,:) are derivatives with respect to v
    graduv(1, 1) = 0.0
    graduv(1, 2) = 1.0
    graduv(1, 3) = 0.0
    graduv(1, 4) = 2.0*u
    graduv(1, 5) = v
    graduv(1, 6) = 0.0
    graduv(1, 7) = 2.0*u*v
    graduv(1, 8) = v*v
    graduv(1, 9) = 2.0*u*v*v
    graduv(2, 1) = 0.0
    graduv(2, 2) = 0.0
    graduv(2, 3) = 1.0
    graduv(2, 4) = 0.0
    graduv(2, 5) = u
    graduv(2, 6) = 2.0*v
    graduv(2, 7) = u*u
    graduv(2, 8) = 2.0*u*v
    graduv(2, 9) = 2.0*u*u*v
! Now compute the gradient of the objective function (grad(dist2))
! The residual is the objective function gradient
! Now assemble the Jacobian of the function we are solving (Jac(grad(dist2)))
! Invert the Jacobian
    graddist2b = 0.0_8
    graddist2b = residualb
    ab = 0.0_8
    graduvb = 0.0_8
    CALL DOTPROD_B(a, ab, graduv(2, :), graduvb(2, :), graddist2(2), &
&            graddist2b(2))
    graddist2b(2) = 0.0_8
    CALL DOTPROD_B(a, ab, graduv(1, :), graduvb(1, :), graddist2(1), &
&            graddist2b(1))
    graddist2b(1) = 0.0_8
    ub = 2*u*v*2.0*graduvb(2, 9) + v*2.0*graduvb(2, 8) + 2*u*graduvb(2, &
&     7) + graduvb(2, 5) + v**2*2.0*graduvb(1, 9) + v*2.0*graduvb(1, 7) &
&     + 2.0*graduvb(1, 4)
    vb = u**2*2.0*graduvb(2, 9) + u*2.0*graduvb(2, 8) + 2.0*graduvb(2, 6&
&     ) + 2*v*u*2.0*graduvb(1, 9) + 2*v*graduvb(1, 8) + u*2.0*graduvb(1&
&     , 7) + graduvb(1, 5)
    graduvb(2, 9) = 0.0_8
    graduvb(2, 8) = 0.0_8
    graduvb(2, 7) = 0.0_8
    graduvb(2, 6) = 0.0_8
    graduvb(2, 5) = 0.0_8
    graduvb(2, 4) = 0.0_8
    graduvb(2, 3) = 0.0_8
    graduvb(2, 2) = 0.0_8
    graduvb(2, 1) = 0.0_8
    graduvb(1, 9) = 0.0_8
    graduvb(1, 8) = 0.0_8
    graduvb(1, 7) = 0.0_8
    graduvb(1, 6) = 0.0_8
    graduvb(1, 5) = 0.0_8
    dotresultb = ab(9)
    ab(9) = 0.0_8
    x3142b = 0.0_8
    dummyvecb = 0.0_8
    CALL DOTPROD_B(x3142, x3142b, dummyvec, dummyvecb, dotresult, &
&            dotresultb)
    x3142b = x3142b + dummyvecb
    dotresultb = 2*ab(8)
    ab(8) = 0.0_8
    x41b = 0.0_8
    CALL DOTPROD_B(x41, x41b, x3142, x3142b, dotresult, dotresultb)
    dotresultb = 2*ab(7)
    ab(7) = 0.0_8
    x21b = 0.0_8
    CALL DOTPROD_B(x21, x21b, x3142, x3142b, dotresult, dotresultb)
    dotresultb = ab(6)
    ab(6) = 0.0_8
    dummyvec = x41
    dummyvecb = 0.0_8
    CALL DOTPROD_B(x41, x41b, dummyvec, dummyvecb, dotresult, dotresultb&
&           )
    x41b = x41b + dummyvecb
    dotresultb = 2*ab(5)
    CALL DOTPROD_B(x21, x21b, x41, x41b, dotresult, dotresultb)
    dotresultb = 2*ab(5)
    ab(5) = 0.0_8
    x10b = 0.0_8
    CALL DOTPROD_B(x10, x10b, x3142, x3142b, dotresult, dotresultb)
    dotresultb = ab(4)
    ab(4) = 0.0_8
    dummyvec = x21
    dummyvecb = 0.0_8
    CALL DOTPROD_B(x21, x21b, dummyvec, dummyvecb, dotresult, dotresultb&
&           )
    x21b = x21b + dummyvecb
    dotresultb = 2*ab(3)
    ab(3) = 0.0_8
    CALL DOTPROD_B(x10, x10b, x41, x41b, dotresult, dotresultb)
    dotresultb = 2*ab(2)
    ab(2) = 0.0_8
    CALL DOTPROD_B(x10, x10b, x21, x21b, dotresult, dotresultb)
    dotresultb = ab(1)
    dummyvec = x10
    dummyvecb = 0.0_8
    CALL DOTPROD_B(x10, x10b, dummyvec, dummyvecb, dotresult, dotresultb&
&           )
    x10b = x10b + dummyvecb
    x1b = 0.0_8
    x3b = 0.0_8
    x3b = x3142b
    x21b = x21b - x3142b
    x41b = x41b - x3142b
    x1b = x10b - x3142b - x41b - x21b
    x4b = 0.0_8
    x4b = x41b
    x2b = 0.0_8
    x2b = x21b
    xb = 0.0_8
    xb = -x10b
    residualb = 0.0_8
  END SUBROUTINE QUADPROJRESIDUAL_B

  SUBROUTINE QUADPROJRESIDUAL(x1, x2, x3, x4, x, u, v, residual, invjac)
    IMPLICIT NONE
! DECLARATIONS
! Input variables
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x1, x2, x3, x4
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x
    REAL(kind=realtype), INTENT(IN) :: u, v
! Output variables
    REAL(kind=realtype), DIMENSION(2), INTENT(OUT) :: residual
    REAL(kind=realtype), DIMENSION(2, 2), INTENT(OUT) :: invjac
! Working variables
    REAL(kind=realtype), DIMENSION(3) :: x10, x21, x41, x3142, dummyvec
    REAL(kind=realtype), DIMENSION(9) :: a
    REAL(kind=realtype), DIMENSION(2, 9) :: graduv
    REAL(kind=realtype), DIMENSION(2) :: graddist2
    REAL(kind=realtype), DIMENSION(2, 2) :: jac
    REAL(kind=realtype) :: dotresult
! EXECUTION
! Determine auxiliary vectors
    x10 = x1 - x
    x21 = x2 - x1
    x41 = x4 - x1
    x3142 = x3 - x1 - x21 - x41
! Determine vector of coefficients (A)
    dummyvec = x10
    CALL DOTPROD(x10, dummyvec, dotresult)
    a(1) = dotresult
    CALL DOTPROD(x10, x21, dotresult)
    a(2) = 2*dotresult
    CALL DOTPROD(x10, x41, dotresult)
    a(3) = 2*dotresult
    dummyvec = x21
    CALL DOTPROD(x21, dummyvec, dotresult)
    a(4) = dotresult
    CALL DOTPROD(x10, x3142, dotresult)
    a(5) = 2*dotresult
    CALL DOTPROD(x21, x41, dotresult)
    a(5) = a(5) + 2*dotresult
    dummyvec = x41
    CALL DOTPROD(x41, dummyvec, dotresult)
    a(6) = dotresult
    CALL DOTPROD(x21, x3142, dotresult)
    a(7) = 2*dotresult
    CALL DOTPROD(x41, x3142, dotresult)
    a(8) = 2*dotresult
    dummyvec = x3142
    CALL DOTPROD(x3142, dummyvec, dotresult)
    a(9) = dotresult
! Assemble the gradient of the vector of independent variables (grad(X))
! gradUV(1,:) are derivatives with respect to u
! gradUV(2,:) are derivatives with respect to v
    graduv(1, 1) = 0.0
    graduv(1, 2) = 1.0
    graduv(1, 3) = 0.0
    graduv(1, 4) = 2.0*u
    graduv(1, 5) = v
    graduv(1, 6) = 0.0
    graduv(1, 7) = 2.0*u*v
    graduv(1, 8) = v*v
    graduv(1, 9) = 2.0*u*v*v
    graduv(2, 1) = 0.0
    graduv(2, 2) = 0.0
    graduv(2, 3) = 1.0
    graduv(2, 4) = 0.0
    graduv(2, 5) = u
    graduv(2, 6) = 2.0*v
    graduv(2, 7) = u*u
    graduv(2, 8) = 2.0*u*v
    graduv(2, 9) = 2.0*u*u*v
! Now compute the gradient of the objective function (grad(dist2))
    CALL DOTPROD(a, graduv(1, :), graddist2(1))
    CALL DOTPROD(a, graduv(2, :), graddist2(2))
! The residual is the objective function gradient
    residual = graddist2
! Now assemble the Jacobian of the function we are solving (Jac(grad(dist2)))
    jac(1, 1) = 2.0*(a(4)+v*a(7)+v*v*a(9))
    jac(1, 2) = a(5) + 2.0*(u*a(7)+v*a(8)+2*u*v*a(9))
    jac(2, 1) = jac(1, 2)
    jac(2, 2) = 2.0*(a(6)+u*a(8)+u*u*a(9))
! Invert the Jacobian
    CALL INVERT2X2(jac, invjac)
  END SUBROUTINE QUADPROJRESIDUAL

!  Differentiation of quadprojoutput in reverse (adjoint) mode:
!   gradient     of useful results: xf
!   with respect to varying inputs: u v xf x1 x2 x3 x4
!   RW status of diff variables: u:out v:out xf:in-zero x1:out
!                x2:out x3:out x4:out
!===============================================================
  SUBROUTINE QUADPROJOUTPUT_B(x1, x1b, x2, x2b, x3, x3b, x4, x4b, u, ub&
&   , v, vb, xf, xfb)
    IMPLICIT NONE
! DECLARATIONS
! Input variables
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x1, x2, x3, x4
    REAL(kind=realtype), DIMENSION(3) :: x1b, x2b, x3b, x4b
    REAL(kind=realtype), INTENT(IN) :: u, v
    REAL(kind=realtype) :: ub, vb
! Output variables
    REAL(kind=realtype), DIMENSION(3) :: xf
    REAL(kind=realtype), DIMENSION(3) :: xfb
! Working variables
    REAL(kind=realtype), DIMENSION(3) :: x21, x41, x3142
    REAL(kind=realtype), DIMENSION(3) :: x21b, x41b, x3142b
    REAL(kind=realtype) :: tempb
! EXECUTION
! Determine auxiliary vectors
    x21 = x2 - x1
    x41 = x4 - x1
    x3142 = x3 - x1 - x21 - x41
! Compute guess for projection point
    tempb = SUM(x3142*xfb)
    x1b = 0.0_8
    x3142b = 0.0_8
    x21b = 0.0_8
    x41b = 0.0_8
    ub = SUM(x21*xfb) + v*tempb
    vb = SUM(x41*xfb) + u*tempb
    x3142b = u*v*xfb
    x21b = u*xfb - x3142b
    x41b = v*xfb - x3142b
    x1b = xfb - x3142b - x41b - x21b
    x3b = 0.0_8
    x3b = x3142b
    x4b = 0.0_8
    x4b = x41b
    x2b = 0.0_8
    x2b = x21b
    xfb = 0.0_8
  END SUBROUTINE QUADPROJOUTPUT_B

!===============================================================
  SUBROUTINE QUADPROJOUTPUT(x1, x2, x3, x4, u, v, xf)
    IMPLICIT NONE
! DECLARATIONS
! Input variables
    REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: x1, x2, x3, x4
    REAL(kind=realtype), INTENT(IN) :: u, v
! Output variables
    REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: xf
! Working variables
    REAL(kind=realtype), DIMENSION(3) :: x21, x41, x3142
! EXECUTION
! Determine auxiliary vectors
    x21 = x2 - x1
    x41 = x4 - x1
    x3142 = x3 - x1 - x21 - x41
! Compute guess for projection point
    xf = x1 + u*x21 + v*x41 + u*v*x3142
  END SUBROUTINE QUADPROJOUTPUT

!  Differentiation of triaweights in reverse (adjoint) mode:
!   gradient     of useful results: u v weight
!   with respect to varying inputs: u v weight
!   RW status of diff variables: u:incr v:incr weight:in-zero
!===============================================================
!===============================================================
!===============================================================
! WEIGHT FUNCTIONS
  SUBROUTINE TRIAWEIGHTS_B(u, ub, v, vb, weight, weightb)
    IMPLICIT NONE
! This subroutine compute the interpolation weights based
! on parametric coordinates.
! DECLARATIONS
! Inputs variables
    REAL(kind=realtype), INTENT(IN) :: u, v
    REAL(kind=realtype) :: ub, vb
! Output variables
    REAL(kind=realtype), DIMENSION(8) :: weight
    REAL(kind=realtype), DIMENSION(8) :: weightb
! EXECUTION
! Initialize weight vector
! Update values according to the current element type
    vb = vb + weightb(3) - weightb(1)
    weightb(3) = 0.0_8
    ub = ub + weightb(2) - weightb(1)
    weightb(2) = 0.0_8
    weightb = 0.0_8
  END SUBROUTINE TRIAWEIGHTS_B

!===============================================================
!===============================================================
!===============================================================
! WEIGHT FUNCTIONS
  SUBROUTINE TRIAWEIGHTS(u, v, weight)
    IMPLICIT NONE
! This subroutine compute the interpolation weights based
! on parametric coordinates.
! DECLARATIONS
! Inputs variables
    REAL(kind=realtype), INTENT(IN) :: u, v
! Output variables
    REAL(kind=realtype), DIMENSION(8), INTENT(OUT) :: weight
! EXECUTION
! Initialize weight vector
    weight = 0.0
! Update values according to the current element type
    weight(1) = one - u - v
    weight(2) = u
    weight(3) = v
  END SUBROUTINE TRIAWEIGHTS

!  Differentiation of quadweights in reverse (adjoint) mode:
!   gradient     of useful results: u v weight
!   with respect to varying inputs: u v weight
!   RW status of diff variables: u:incr v:incr weight:in-zero
!===============================================================
  SUBROUTINE QUADWEIGHTS_B(u, ub, v, vb, weight, weightb)
    IMPLICIT NONE
! This subroutine compute the interpolation weights based
! on parametric coordinates.
! DECLARATIONS
! Inputs variables
    REAL(kind=realtype), INTENT(IN) :: u, v
    REAL(kind=realtype) :: ub, vb
! Output variables
    REAL(kind=realtype), DIMENSION(8) :: weight
    REAL(kind=realtype), DIMENSION(8) :: weightb
! EXECUTION
! Initialize weight vector
! Update values according to the current element type
    ub = ub + v*weightb(3) - v*weightb(4) + (one-v)*weightb(2) - (one-v)&
&     *weightb(1)
    vb = vb + (one-u)*weightb(4) + u*weightb(3) - u*weightb(2) - (one-u)&
&     *weightb(1)
    weightb(4) = 0.0_8
    weightb(3) = 0.0_8
    weightb(2) = 0.0_8
    weightb = 0.0_8
  END SUBROUTINE QUADWEIGHTS_B

!===============================================================
  SUBROUTINE QUADWEIGHTS(u, v, weight)
    IMPLICIT NONE
! This subroutine compute the interpolation weights based
! on parametric coordinates.
! DECLARATIONS
! Inputs variables
    REAL(kind=realtype), INTENT(IN) :: u, v
! Output variables
    REAL(kind=realtype), DIMENSION(8), INTENT(OUT) :: weight
! EXECUTION
! Initialize weight vector
    weight = 0.0
! Update values according to the current element type
    weight(1) = (one-u)*(one-v)
    weight(2) = u*(one-v)
    weight(3) = u*v
    weight(4) = (one-u)*v
  END SUBROUTINE QUADWEIGHTS

!  Differentiation of computenodalnormals in reverse (adjoint) mode:
!   gradient     of useful results: coor nodalnormals
!   with respect to varying inputs: coor nodalnormals
!   RW status of diff variables: coor:incr nodalnormals:in-zero
!===============================================================
!===============================================================
!===============================================================
  SUBROUTINE COMPUTENODALNORMALS_B(ncoor, ntria, nquads, coor, coorb, &
&   triaconn, quadsconn, nodalnormals, nodalnormalsb)
    IMPLICIT NONE
!
!       Subroutine arguments.
!
! Input
    INTEGER(kind=inttype), INTENT(IN) :: ncoor, ntria, nquads
    REAL(kind=realtype), DIMENSION(3, ncoor), INTENT(IN) :: coor
    REAL(kind=realtype), DIMENSION(3, ncoor) :: coorb
    INTEGER(kind=inttype), DIMENSION(3, ntria), INTENT(IN) :: triaconn
    INTEGER(kind=inttype), DIMENSION(4, nquads), INTENT(IN) :: quadsconn
! Output
    REAL(kind=realtype), DIMENSION(3, ncoor) :: nodalnormals
    REAL(kind=realtype), DIMENSION(3, ncoor) :: nodalnormalsb
! Working
    INTEGER(kind=inttype), DIMENSION(ncoor) :: connect_count
    REAL(kind=realtype) :: normal1(3), normal2(3), normal3(3), normal4(3&
&   )
    REAL(kind=realtype) :: normal1b(3)
    INTEGER(kind=inttype) :: i, ind1, ind2, ind3, ind4
    REAL(kind=realtype) :: x1(3), x2(3), x3(3), x4(3)
    REAL(kind=realtype) :: x1b(3), x2b(3), x3b(3), x4b(3)
    REAL(kind=realtype) :: x12(3), x23(3), x13(3), x24(3)
    REAL(kind=realtype) :: x12b(3), x23b(3), x13b(3), x24b(3)
    REAL(kind=realtype) :: dotresult, dummyvec(3)
    REAL(kind=realtype) :: dotresultb, dummyvecb(3)
    INTRINSIC SQRT
    REAL(kind=realtype) :: temp
!===============================================================
! Initialize cumulative variables
    nodalnormals = 0.0
    connect_count = 0
! Loop over triangle connectivities
    DO i=1,ntria
! Get the indices for each node of the triangle element
      ind1 = triaconn(1, i)
      ind2 = triaconn(2, i)
      ind3 = triaconn(3, i)
! Get the coordinates for each node of the triangle element
      x1 = coor(:, ind1)
      x2 = coor(:, ind2)
      x3 = coor(:, ind3)
! Compute relative vectors for the triangle sides
      x12 = x1 - x2
      x23 = x2 - x3
! Take the cross-product of these vectors to obtain the normal vector
      CALL CROSSPROD(x12, x23, normal1)
! Normalize this normal vector
      CALL PUSHREAL8ARRAY(dummyvec, 3)
      dummyvec = normal1
      CALL PUSHREAL8(dotresult)
      CALL DOTPROD(normal1, dummyvec, dotresult)
      CALL PUSHREAL8ARRAY(normal1, 3)
      normal1 = normal1/SQRT(dotresult)
! Add the contribution of this normal to the nodalNormals array
      nodalnormals(:, ind1) = nodalnormals(:, ind1) + normal1
      nodalnormals(:, ind2) = nodalnormals(:, ind2) + normal1
      nodalnormals(:, ind3) = nodalnormals(:, ind3) + normal1
! Add connectivity information to the connect_count array so we
! know how many edges are connected to a node.
! We divide the nodalNormals vector by this number to obtain the
! averaged nodal normal.
      connect_count(ind1) = connect_count(ind1) + 1
      connect_count(ind2) = connect_count(ind2) + 1
      connect_count(ind3) = connect_count(ind3) + 1
    END DO
! Loop over quad connectivities
    DO i=1,nquads
! Get the indices for each node of the quad element
      ind1 = quadsconn(1, i)
      ind2 = quadsconn(2, i)
      ind3 = quadsconn(3, i)
      ind4 = quadsconn(4, i)
! Get the coordinates for each node of the quad element
      x1 = coor(:, ind1)
      x2 = coor(:, ind2)
      x3 = coor(:, ind3)
      x4 = coor(:, ind4)
! Compute relative vectors for the quad sides
      x13 = x3 - x1
      x24 = x4 - x2
! Take the cross-product of these vectors to obtain the normal vectors
! Normalize these normal vectors
      CALL CROSSPROD(x13, x24, normal1)
      CALL PUSHREAL8ARRAY(dummyvec, 3)
      dummyvec = normal1
      CALL PUSHREAL8(dotresult)
      CALL DOTPROD(normal1, dummyvec, dotresult)
      CALL PUSHREAL8ARRAY(normal1, 3)
      normal1 = normal1/SQRT(dotresult)
! Add the contribution of this normal to the nodalNormals array
      nodalnormals(:, ind1) = nodalnormals(:, ind1) + normal1
      nodalnormals(:, ind2) = nodalnormals(:, ind2) + normal1
      nodalnormals(:, ind3) = nodalnormals(:, ind3) + normal1
      nodalnormals(:, ind4) = nodalnormals(:, ind4) + normal1
! Add connectivity information to the connect_count array so we
! know how many edges are connected to a node.
! We divide the nodalNormals vector by this number to obtain the
! averaged nodal normal.
      connect_count(ind1) = connect_count(ind1) + 1
      connect_count(ind2) = connect_count(ind2) + 1
      connect_count(ind3) = connect_count(ind3) + 1
      connect_count(ind4) = connect_count(ind4) + 1
    END DO
    DO i=1,3
! Divide the nodal normals by the number of edges that each node has
      nodalnormals(i, :) = nodalnormals(i, :)/connect_count
    END DO
    DO i=1,ncoor
! Normalize these new averaged nodal normals
      CALL PUSHREAL8ARRAY(normal1, 3)
      normal1 = nodalnormals(:, i)
      CALL PUSHREAL8ARRAY(dummyvec, 3)
      dummyvec = normal1
      CALL PUSHREAL8(dotresult)
      CALL DOTPROD(normal1, dummyvec, dotresult)
    END DO
    DO i=ncoor,1,-1
      normal1b = 0.0_8
      temp = SQRT(dotresult)
      normal1b = nodalnormalsb(:, i)/temp
      IF (dotresult .EQ. 0.0) THEN
        dotresultb = 0.0_8
      ELSE
        dotresultb = -(SUM(normal1*nodalnormalsb(:, i))/(2.0*temp**3))
      END IF
      dummyvec = normal1
      CALL POPREAL8(dotresult)
      dummyvecb = 0.0_8
      CALL DOTPROD_B(normal1, normal1b, dummyvec, dummyvecb, dotresult, &
&              dotresultb)
      CALL POPREAL8ARRAY(dummyvec, 3)
      normal1b = normal1b + dummyvecb
      nodalnormalsb(:, i) = normal1b
      CALL POPREAL8ARRAY(normal1, 3)
    END DO
    DO i=3,1,-1
      nodalnormalsb(i, :) = nodalnormalsb(i, :)/connect_count
    END DO
    normal1b = 0.0_8
    DO i=nquads,1,-1
      ind4 = quadsconn(4, i)
      ind3 = quadsconn(3, i)
      ind2 = quadsconn(2, i)
      ind1 = quadsconn(1, i)
      normal1b = normal1b + nodalnormalsb(:, ind4) + nodalnormalsb(:, &
&       ind3) + nodalnormalsb(:, ind2) + nodalnormalsb(:, ind1)
      CALL POPREAL8ARRAY(normal1, 3)
      temp = SQRT(dotresult)
      IF (dotresult .EQ. 0.0) THEN
        dotresultb = 0.0_8
      ELSE
        dotresultb = -(SUM(normal1*normal1b)/(2.0*temp**3))
      END IF
      normal1b = normal1b/temp
      CALL POPREAL8(dotresult)
      dummyvecb = 0.0_8
      CALL DOTPROD_B(normal1, normal1b, dummyvec, dummyvecb, dotresult, &
&              dotresultb)
      CALL POPREAL8ARRAY(dummyvec, 3)
      normal1b = normal1b + dummyvecb
      x2 = coor(:, ind2)
      x4 = coor(:, ind4)
      x24 = x4 - x2
      x1 = coor(:, ind1)
      x3 = coor(:, ind3)
      x13 = x3 - x1
      CALL CROSSPROD_B(x13, x13b, x24, x24b, normal1, normal1b)
      x2b = 0.0_8
      x4b = 0.0_8
      x4b = x24b
      x2b = -x24b
      x1b = 0.0_8
      x3b = 0.0_8
      x3b = x13b
      x1b = -x13b
      coorb(:, ind4) = coorb(:, ind4) + x4b
      coorb(:, ind3) = coorb(:, ind3) + x3b
      coorb(:, ind2) = coorb(:, ind2) + x2b
      coorb(:, ind1) = coorb(:, ind1) + x1b
    END DO
    DO i=ntria,1,-1
      ind3 = triaconn(3, i)
      ind2 = triaconn(2, i)
      ind1 = triaconn(1, i)
      normal1b = normal1b + nodalnormalsb(:, ind3) + nodalnormalsb(:, &
&       ind2) + nodalnormalsb(:, ind1)
      CALL POPREAL8ARRAY(normal1, 3)
      temp = SQRT(dotresult)
      IF (dotresult .EQ. 0.0) THEN
        dotresultb = 0.0_8
      ELSE
        dotresultb = -(SUM(normal1*normal1b)/(2.0*temp**3))
      END IF
      normal1b = normal1b/temp
      CALL POPREAL8(dotresult)
      dummyvecb = 0.0_8
      CALL DOTPROD_B(normal1, normal1b, dummyvec, dummyvecb, dotresult, &
&              dotresultb)
      CALL POPREAL8ARRAY(dummyvec, 3)
      normal1b = normal1b + dummyvecb
      x2 = coor(:, ind2)
      x3 = coor(:, ind3)
      x23 = x2 - x3
      x1 = coor(:, ind1)
      x12 = x1 - x2
      CALL CROSSPROD_B(x12, x12b, x23, x23b, normal1, normal1b)
      x2b = 0.0_8
      x3b = 0.0_8
      x2b = x23b - x12b
      x3b = -x23b
      x1b = 0.0_8
      x1b = x12b
      coorb(:, ind3) = coorb(:, ind3) + x3b
      coorb(:, ind2) = coorb(:, ind2) + x2b
      coorb(:, ind1) = coorb(:, ind1) + x1b
    END DO
    nodalnormalsb = 0.0_8
  END SUBROUTINE COMPUTENODALNORMALS_B

!===============================================================
!===============================================================
!===============================================================
  SUBROUTINE COMPUTENODALNORMALS(ncoor, ntria, nquads, coor, triaconn, &
&   quadsconn, nodalnormals)
    IMPLICIT NONE
!
!       Subroutine arguments.
!
! Input
    INTEGER(kind=inttype), INTENT(IN) :: ncoor, ntria, nquads
    REAL(kind=realtype), DIMENSION(3, ncoor), INTENT(IN) :: coor
    INTEGER(kind=inttype), DIMENSION(3, ntria), INTENT(IN) :: triaconn
    INTEGER(kind=inttype), DIMENSION(4, nquads), INTENT(IN) :: quadsconn
! Output
    REAL(kind=realtype), DIMENSION(3, ncoor), INTENT(OUT) :: &
&   nodalnormals
! Working
    INTEGER(kind=inttype), DIMENSION(ncoor) :: connect_count
    REAL(kind=realtype) :: normal1(3), normal2(3), normal3(3), normal4(3&
&   )
    INTEGER(kind=inttype) :: i, ind1, ind2, ind3, ind4
    REAL(kind=realtype) :: x1(3), x2(3), x3(3), x4(3)
    REAL(kind=realtype) :: x12(3), x23(3), x13(3), x24(3)
    REAL(kind=realtype) :: dotresult, dummyvec(3)
    INTRINSIC SQRT
!===============================================================
! Initialize cumulative variables
    nodalnormals = 0.0
    connect_count = 0
! Loop over triangle connectivities
    DO i=1,ntria
! Get the indices for each node of the triangle element
      ind1 = triaconn(1, i)
      ind2 = triaconn(2, i)
      ind3 = triaconn(3, i)
! Get the coordinates for each node of the triangle element
      x1 = coor(:, ind1)
      x2 = coor(:, ind2)
      x3 = coor(:, ind3)
! Compute relative vectors for the triangle sides
      x12 = x1 - x2
      x23 = x2 - x3
! Take the cross-product of these vectors to obtain the normal vector
      CALL CROSSPROD(x12, x23, normal1)
! Normalize this normal vector
      dummyvec = normal1
      CALL DOTPROD(normal1, dummyvec, dotresult)
      normal1 = normal1/SQRT(dotresult)
! Add the contribution of this normal to the nodalNormals array
      nodalnormals(:, ind1) = nodalnormals(:, ind1) + normal1
      nodalnormals(:, ind2) = nodalnormals(:, ind2) + normal1
      nodalnormals(:, ind3) = nodalnormals(:, ind3) + normal1
! Add connectivity information to the connect_count array so we
! know how many edges are connected to a node.
! We divide the nodalNormals vector by this number to obtain the
! averaged nodal normal.
      connect_count(ind1) = connect_count(ind1) + 1
      connect_count(ind2) = connect_count(ind2) + 1
      connect_count(ind3) = connect_count(ind3) + 1
    END DO
! Loop over quad connectivities
    DO i=1,nquads
! Get the indices for each node of the quad element
      ind1 = quadsconn(1, i)
      ind2 = quadsconn(2, i)
      ind3 = quadsconn(3, i)
      ind4 = quadsconn(4, i)
! Get the coordinates for each node of the quad element
      x1 = coor(:, ind1)
      x2 = coor(:, ind2)
      x3 = coor(:, ind3)
      x4 = coor(:, ind4)
! Compute relative vectors for the quad sides
      x13 = x3 - x1
      x24 = x4 - x2
! Take the cross-product of these vectors to obtain the normal vectors
! Normalize these normal vectors
      CALL CROSSPROD(x13, x24, normal1)
      dummyvec = normal1
      CALL DOTPROD(normal1, dummyvec, dotresult)
      normal1 = normal1/SQRT(dotresult)
! Add the contribution of this normal to the nodalNormals array
      nodalnormals(:, ind1) = nodalnormals(:, ind1) + normal1
      nodalnormals(:, ind2) = nodalnormals(:, ind2) + normal1
      nodalnormals(:, ind3) = nodalnormals(:, ind3) + normal1
      nodalnormals(:, ind4) = nodalnormals(:, ind4) + normal1
! Add connectivity information to the connect_count array so we
! know how many edges are connected to a node.
! We divide the nodalNormals vector by this number to obtain the
! averaged nodal normal.
      connect_count(ind1) = connect_count(ind1) + 1
      connect_count(ind2) = connect_count(ind2) + 1
      connect_count(ind3) = connect_count(ind3) + 1
      connect_count(ind4) = connect_count(ind4) + 1
    END DO
    DO i=1,3
! Divide the nodal normals by the number of edges that each node has
      nodalnormals(i, :) = nodalnormals(i, :)/connect_count
    END DO
    DO i=1,ncoor
! Normalize these new averaged nodal normals
      normal1 = nodalnormals(:, i)
      dummyvec = normal1
      CALL DOTPROD(normal1, dummyvec, dotresult)
      nodalnormals(:, i) = normal1/SQRT(dotresult)
    END DO
  END SUBROUTINE COMPUTENODALNORMALS

!  Differentiation of crossprod in reverse (adjoint) mode:
!   gradient     of useful results: c
!   with respect to varying inputs: a b c
!===============================================================
!===============================================================
!===============================================================
  SUBROUTINE CROSSPROD_B(a, ab, b, bb, c, cb)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: a(3), b(3)
    REAL(kind=realtype) :: ab(3), bb(3)
    REAL(kind=realtype) :: c(3)
    REAL(kind=realtype) :: cb(3)
    ab = 0.0_8
    bb = 0.0_8
    ab(1) = ab(1) + b(2)*cb(3) - b(3)*cb(2)
    bb(2) = bb(2) + a(1)*cb(3) - a(3)*cb(1)
    ab(2) = ab(2) + b(3)*cb(1) - b(1)*cb(3)
    bb(1) = bb(1) + a(3)*cb(2) - a(2)*cb(3)
    cb(3) = 0.0_8
    ab(3) = ab(3) + b(1)*cb(2) - b(2)*cb(1)
    bb(3) = bb(3) + a(2)*cb(1) - a(1)*cb(2)
    cb(2) = 0.0_8
    cb(1) = 0.0_8
  END SUBROUTINE CROSSPROD_B

!===============================================================
!===============================================================
!===============================================================
  SUBROUTINE CROSSPROD(a, b, c)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: a(3), b(3)
    REAL(kind=realtype), INTENT(OUT) :: c(3)
    c(1) = a(2)*b(3) - a(3)*b(2)
    c(2) = a(3)*b(1) - a(1)*b(3)
    c(3) = a(1)*b(2) - a(2)*b(1)
  END SUBROUTINE CROSSPROD

!  Differentiation of dotprod in reverse (adjoint) mode:
!   gradient     of useful results: a b c
!   with respect to varying inputs: a b
!===============================================================
  SUBROUTINE DOTPROD_B(a, ab, b, bb, c, cb)
    IMPLICIT NONE
! DECLARATIONS
! Input variables
    REAL(kind=realtype), DIMENSION(:), INTENT(IN) :: a, b
    REAL(kind=realtype), DIMENSION(:) :: ab, bb
! Output variables
    REAL(kind=realtype) :: c
    REAL(kind=realtype) :: cb
! Working variables
    INTEGER(kind=inttype) :: ii
    INTRINSIC SUM
! EXECUTION
    ab = ab + b*cb
    bb = bb + a*cb
  END SUBROUTINE DOTPROD_B

!===============================================================
  SUBROUTINE DOTPROD(a, b, c)
    IMPLICIT NONE
! DECLARATIONS
! Input variables
    REAL(kind=realtype), DIMENSION(:), INTENT(IN) :: a, b
! Output variables
    REAL(kind=realtype), INTENT(OUT) :: c
! Working variables
    INTEGER(kind=inttype) :: ii
    INTRINSIC SUM
! EXECUTION
    c = SUM(a*b)
  END SUBROUTINE DOTPROD

!===============================================================
  SUBROUTINE INVERT2X2(a, ainv)
    IMPLICIT NONE
! DECLARATIONS
! Input variables
    REAL(kind=realtype), DIMENSION(2, 2), INTENT(IN) :: a
! Output variables
    REAL(kind=realtype), DIMENSION(2, 2), INTENT(OUT) :: ainv
! Working variables
    REAL(kind=realtype) :: detinv
! EXECUTION
! Compute the determinant
    detinv = 1.0/(a(1, 1)*a(2, 2)-a(1, 2)*a(2, 1))
! Compute inverted matrix
    ainv(1, 1) = a(2, 2)*detinv
    ainv(1, 2) = -(a(1, 2)*detinv)
    ainv(2, 1) = -(a(2, 1)*detinv)
    ainv(2, 2) = a(1, 1)*detinv
  END SUBROUTINE INVERT2X2

END MODULE ADTPROJECTIONS_B

