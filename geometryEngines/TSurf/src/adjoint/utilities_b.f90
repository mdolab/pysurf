!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
!
MODULE UTILITIES_B
  USE PRECISION
  IMPLICIT NONE

CONTAINS
!============================================================
  SUBROUTINE CONDENSEBARNODES_MAIN(nnodes, nelem, disttol, coor, &
&   barsconn, nuniquenodes)
    IMPLICIT NONE
! INPUTS
    INTEGER(kind=inttype), INTENT(IN) :: nnodes, nelem
    REAL(kind=realtype), INTENT(IN) :: disttol
! INPUTS/OUTPUTS
    REAL(kind=realtype), DIMENSION(3, nnodes), INTENT(INOUT) :: coor
    INTEGER(kind=inttype), DIMENSION(2, nelem), INTENT(INOUT) :: &
&   barsconn
! OUTPUTS
    INTEGER(kind=inttype), INTENT(OUT) :: nuniquenodes
! WORKING
    INTEGER(kind=inttype) :: ncopies
    INTEGER(kind=inttype) :: currnodeid, prevnodeid, link, elemid
    REAL(kind=realtype), DIMENSION(3) :: currcoor, prevcoor
    REAL(kind=realtype) :: dist
    INTEGER(kind=inttype), DIMENSION(SIZE(coor, 2)) :: linkold2new
    INTRINSIC SIZE
    REAL(kind=realtype), DIMENSION(3) :: arg1
! EXECUTION
! Initialize number of unique nodes found so far.
! The first node is a unique one =P!
    nuniquenodes = 1
! As the first node is unique, its old-to-new link should point to itself
    linkold2new(1) = 1
! Loop over the nodes to find the unique ones
    DO currnodeid=2,nnodes
! Get coordinates of current node
      currcoor = coor(:, currnodeid)
! Now loop over the previous nodes to find if it is repeated
      DO prevnodeid=1,currnodeid-1
! Get coordinates of the previous node
        prevcoor = coor(:, prevnodeid)
! Compute distance between nodes
        arg1(:) = currcoor - prevcoor
        dist = NORM(arg1(:))
! Check if the distance is below the merging tolerance
        IF (dist .LE. disttol) THEN
! Update link array.
! The array linkOld2New will contain newCoor indices that correspond to each
! coor index.
! So the current node should use the same link as the previous node, as they will
! point to the same index of the new coordinate array.
          linkold2new(currnodeid) = linkold2new(prevnodeid)
          GOTO 100
        END IF
      END DO
! We can jump out of the prevNode do loop and check the next node.
! Check if we did not find any copy. In this case, we need to initialize a new
! unique node
 100  IF (prevnodeid .EQ. currnodeid) THEN
! Increase the number of unique nodes found so far
        nuniquenodes = nuniquenodes + 1
! Create new link
        linkold2new(currnodeid) = nuniquenodes
      END IF
    END DO
! Initialize number of nodes copied so far
    ncopies = 0
! We loop once again over the nodes so we can copy the unique values
    DO currnodeid=1,nnodes
! Get index of the current node in the new coordinate array
      link = linkold2new(currnodeid)
! Check if the new link is already used
      IF (link .GT. ncopies) THEN
! Get coordinates of current node
        currcoor = coor(:, currnodeid)
! Increment number of copies done so far
        ncopies = ncopies + 1
! Copy coordinates
        coor(:, ncopies) = currcoor
      END IF
    END DO
! Now zero out the unused point in coor
    coor(:, ncopies+1:nnodes) = 0.0
! Now the last step is updating the bars connectivity.
! Loop over the elements
    DO elemid=1,nelem
! Update connectivities
      barsconn(1, elemid) = linkold2new(barsconn(1, elemid))
      barsconn(2, elemid) = linkold2new(barsconn(2, elemid))
    END DO
  END SUBROUTINE CONDENSEBARNODES_MAIN
!  Differentiation of dot in reverse (adjoint) mode:
!   gradient     of useful results: dot a b
!   with respect to varying inputs: a b
!============================================================
  SUBROUTINE DOT_B(a, ab, b, bb, dotb)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: a(3), b(3)
    REAL(kind=realtype) :: ab(3), bb(3)
    REAL(kind=realtype) :: dot
    REAL(kind=realtype) :: dotb
    ab(1) = ab(1) + b(1)*dotb
    bb(1) = bb(1) + a(1)*dotb
    ab(2) = ab(2) + b(2)*dotb
    bb(2) = bb(2) + a(2)*dotb
    ab(3) = ab(3) + b(3)*dotb
    bb(3) = bb(3) + a(3)*dotb
  END SUBROUTINE DOT_B
!============================================================
  FUNCTION NORM(a)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: a(3)
    REAL(kind=realtype) :: norm
    INTRINSIC SQRT
    REAL(kind=realtype) :: result1
    result1 = DOT(a, a)
    norm = SQRT(result1)
  END FUNCTION NORM
!============================================================
  FUNCTION DOT(a, b)
    IMPLICIT NONE
    REAL(kind=realtype), INTENT(IN) :: a(3), b(3)
    REAL(kind=realtype) :: dot
    dot = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
  END FUNCTION DOT
END MODULE UTILITIES_B
